.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::AlignIO::phylip 3pm"
.TH Bio::AlignIO::phylip 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::AlignIO::phylip \- PHYLIP format sequence input/output stream
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Do not use this module directly.  Use it via the Bio::AlignIO class.
.PP
This example shows how to write to phylip format:
.PP
.Vb 2
\&    use Bio::AlignIO;
\&    use Bio::SimpleAlign;
\&
\&    # Use \-idlength to set the name length to something other than
\&    # the default 10 if you need longer ids.
\&    my $phylipstream = Bio::AlignIO\->new(\-format   => \*(Aqphylip\*(Aq,
\&                                         \-fh       => \e*STDOUT,
\&                                         \-idlength => 30);
\&    # Convert data from one format to another
\&    my $gcgstream = Bio::AlignIO\->new(\-format => \*(Aqmsf\*(Aq,
\&                                      \-file   => \*(Aqt/data/cysprot1a.msf\*(Aq);
\&
\&    while( my $aln = $gcgstream\->next_aln ) {
\&        $phylipstream\->write_aln($aln);
\&    }
\&
\&    # With phylip sequential format format
\&    $phylipstream\->interleaved(0);
\&    # Or initialize the object like this
\&    $phylipstream = Bio::AlignIO\->new(\-interleaved => 0,
\&                                      \-format      => \*(Aqphylip\*(Aq,
\&                                      \-fh          => \e*STDOUT,
\&                                      \-idlength    => 20 );
\&    $gcgstream = Bio::AlignIO\->new(\-format => \*(Aqmsf\*(Aq,
\&                                   \-file   => \*(Aqt/data/cysprot1a.msf\*(Aq);
\&
\&    while( my $aln = $gcgstream\->next_aln ) {
\&        $phylipstream\->write_aln($aln);
\&    }
.Ve
.PP
This example shows how to read phylip format:
.PP
.Vb 6
\&    my $in = Bio::AlignIO\->new(
\&      \-file        => $inFile,
\&      \-format      => \*(Aqphylip\*(Aq,
\&      \-interleaved => 0,
\&      \-longid      => 1
\&    );
\&
\&    my $out = Bio::AlignIO\->new(
\&      \-file   => ">$outFile",
\&      \-format => \*(Aqfasta\*(Aq
\&    );
\&
\&    while ( my $aln = $in\->next_aln() ) {
\&      $out\->write_aln($aln);
\&    }
.Ve
.PP
The \-longid argument is required if the input phylip format file
has ids with lengths greater then 10 characters.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object can transform Bio::SimpleAlign objects to and from \s-1PHYLIP\s0
format. By default it works with the interleaved format. By specifying
the flag \-interleaved => 0 in the initialization the module can
read or write data in sequential format.
.PP
Reading phylip format with long IDs up to 50 characters is supported by
the flag \-longid =>1. \s-1ID\s0 strings can be surrounded by single quotes.
They are mandatory only if the IDs contain spaces.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHORS \- Heikki Lehvaslaiho and Jason Stajich"
.IX Header "AUTHORS - Heikki Lehvaslaiho and Jason Stajich"
Email: heikki at ebi.ac.uk
Email: jason at bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : my $alignio = Bio::AlignIO\->new(\-format => \*(Aqphylip\*(Aq
\&            \-file   => \*(Aq>file\*(Aq,
\&            \-idlength => 10,
\&            \-idlinebreak => 1);
\& Function: Initialize a new L<Bio::AlignIO::phylip> reader or writer
\& Returns : L<Bio::AlignIO> object
\& Args    : [specific for writing of phylip format files]
\&           \-idlength => integer \- length of the id (will pad w/
\&                        spaces if needed) when writing phylip
\&           \-interleaved => boolean \- whether interleaved
\&                           or sequential format required
\&           \-line_length  => integer of how long a sequence lines should be
\&           \-idlinebreak => insert a line break after the sequence id
\&                           so that sequence starts on the next line
\&           \-flag_SI => whether or not write a "S" or "I" just after
\&                       the num.seq. and line len., in the first line
\&           \-tag_length => integer of how long the tags have to be in
\&                         each line between the space separator. set it
\&                         to 0 to have 1 tag only.
\&           \-wrap_sequential => boolean for whether or not sequential
\&                               format should be broken up or a single line
\&                               default is false (single line)
\&           \-longid => boolean to read arbitrary long IDs (default is false)
.Ve
.SS "next_aln"
.IX Subsection "next_aln"
.Vb 7
\& Title   : next_aln
\& Usage   : $aln = $stream\->next_aln()
\& Function: returns the next alignment in the stream.
\&           Throws an exception if trying to read in PHYLIP
\&           sequential format.
\& Returns : L<Bio::SimpleAlign> object
\& Args    :
.Ve
.SS "write_aln"
.IX Subsection "write_aln"
.Vb 5
\& Title   : write_aln
\& Usage   : $stream\->write_aln(@aln)
\& Function: writes the $aln object into the stream in phylip format
\& Returns : 1 for success and 0 for error
\& Args    : L<Bio::Align::AlignI> object
.Ve
.SS "interleaved"
.IX Subsection "interleaved"
.Vb 5
\& Title   : interleaved
\& Usage   : my $interleaved = $obj\->interleaved
\& Function: Get/Set Interleaved status
\& Returns : boolean
\& Args    : boolean
.Ve
.SS "flag_SI"
.IX Subsection "flag_SI"
.Vb 7
\& Title   : flag_SI
\& Usage   : my $flag = $obj\->flag_SI
\& Function: Get/Set if the Sequential/Interleaved flag has to be shown
\&           after the number of sequences and sequence length
\& Example :
\& Returns : boolean
\& Args    : boolean
.Ve
.SS "idlength"
.IX Subsection "idlength"
.Vb 5
\& Title   : idlength
\& Usage   : my $idlength = $obj\->idlength
\& Function: Get/Set value of id length
\& Returns : string
\& Args    : string
.Ve
.SS "line_length"
.IX Subsection "line_length"
.Vb 5
\& Title   : line_length
\& Usage   : $obj\->line_length($newval)
\& Function:
\& Returns : value of line_length
\& Args    : newvalue (optional)
.Ve
.SS "tag_length"
.IX Subsection "tag_length"
.Vb 6
\& Title   : tag_length
\& Usage   : $obj\->tag_length($newval)
\& Function:
\& Example : my $tag_length = $obj\->tag_length
\& Returns : value of the length for each space\-separated tag in a line
\& Args    : newvalue (optional) \- set to zero to have one tag per line
.Ve
.SS "id_linebreak"
.IX Subsection "id_linebreak"
.Vb 5
\& Title   : id_linebreak
\& Usage   : $obj\->id_linebreak($newval)
\& Function:
\& Returns : value of id_linebreak
\& Args    : newvalue (optional)
.Ve
.SS "wrap_sequential"
.IX Subsection "wrap_sequential"
.Vb 5
\& Title   : wrap_sequential
\& Usage   : $obj\->wrap_sequential($newval)
\& Function:
\& Returns : value of wrap_sequential
\& Args    : newvalue (optional)
.Ve
.SS "longid"
.IX Subsection "longid"
.Vb 5
\& Title   : longid
\& Usage   : $obj\->longid($newval)
\& Function:
\& Returns : value of longid
\& Args    : newvalue (optional)
.Ve
