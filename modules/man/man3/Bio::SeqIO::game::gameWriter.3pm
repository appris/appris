.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::SeqIO::game::gameWriter 3pm"
.TH Bio::SeqIO::game::gameWriter 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SeqIO::game::gameWriter \-\- a class for writing game\-XML
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::SeqIO;
\&
\&  my $in  = Bio::SeqIO\->new( \-format => \*(Aqgenbank\*(Aq,
\&                             \-file => \*(Aqmyfile.gbk\*(Aq );
\&  my $out = Bio::SeqIO\->new( \-format => \*(Aqgame\*(Aq,
\&                             \-file => \*(Aqmyfile.xml\*(Aq );
\&
\&  # get a sequence object
\&  my $seq = $in\->next_seq;
\&
\&  #write it in GAME format
\&  $out\->write_seq($seq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::SeqIO::game::gameWriter writes GAME-XML (v. 1.2) that is readable
by Apollo.  It is best not used directly.  It is accessed via
Bio::SeqIO.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.
.PP
Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Sheldon McKay"
.IX Header "AUTHOR - Sheldon McKay"
Email mckays@cshl.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 12
\& Title   : new
\& Usage   : my $writer = Bio::SeqIO::game::gameWriter\->new($seq);
\& Function: constructor method for gameWriter 
\& Returns : a game writer object 
\& Args    : a Bio::SeqI implementing object
\&           optionally, an argument to set map_position to on.
\&           ( map => 1 ).  This will create a map_position elemant
\&           that will cause the feature coordinates to be remapped to
\&           a parent seqeunce.  A sequence name in the format seq:xxx\-xxx
\&           is expected to determine the offset for the map_position.
\&           The default behavior is to have features mapped relative to 
\&           the sequence contained in the GAME\-XML file
.Ve
.SS "write_to_game"
.IX Subsection "write_to_game"
.Vb 5
\& Title   : write_to_game
\& Usage   : $writer\->write_to_game
\& Function: writes the sequence object to game\-XML 
\& Returns : xml as a multiline string
\& Args    : none
.Ve
.SS "_rearrange_hierarchies"
.IX Subsection "_rearrange_hierarchies"
.Vb 8
\& Title   : _rearrange_hierarchies
\& Usage   : $self\->_rearrange_hierarchies($seq)
\& Function: internal method to rearrange gene containment hierarchies
\&           so that snRNA or transposon features contain their genes
\&           rather than the other way around
\& Returns : nothing
\& Args    : a Bio::RichSeq object
\& Note    : Not currently used, may be removed
.Ve
.SS "_write_feature"
.IX Subsection "_write_feature"
.Vb 6
\& Title   : _write_feature
\& Usage   : $seld\->_write_feature($feat, 1)
\& Function: internal method for writing generic features as <annotation> elements
\& Returns : nothing
\& Args    : a Bio::SeqFeature::Generic object and an optional flag to write a
\&           bare feature set with no annotation wrapper
.Ve
.SS "_write_gene"
.IX Subsection "_write_gene"
.Vb 10
\& Title   : _write_gene
\& Usage   : $self\->_write_gene($feature)
\& Function: internal method for rendering gene containment hierarchies into 
\&           a nested <annotation> element 
\& Returns : nothing
\& Args    : a nested Bio::SeqFeature::Generic gene feature
\& Note    : A nested gene hierarchy (gene\->mRNA\->CDS\->exon) is expected.  If other gene 
\&           subfeatures occur as level one subfeatures (same level as mRNA subfeats) 
\&           an attempt will be made to link them to transcripts via the \*(Aqstandard_name\*(Aq
\&           qualifier
.Ve
.SS "_check_cds"
.IX Subsection "_check_cds"
.Vb 11
\& Title   : _check_cds
\& Usage   : $self\->_check_cds($cds, $name)
\& Function: internal method to check if the CDS associated with an mRNA is
\&           the correct alternative splice variant
\& Returns : a Bio::SeqFeature::Generic CDS object
\& Args    : the CDS object plus the transcript\e\*(Aqs \*(Aqstandard_name\*(Aq
\& Note    : this method only works if alternatively spliced transcripts are bound
\&           together by a \*(Aqstandard_name\*(Aq or \*(AqmRNA\*(Aq qualifier.  If none is present, 
\&           we will hope that the exons were derived from a segmented RNA or a CDS 
\&           with no associated mRNA feature.  Neither of these two cases would be 
\&           confounded by alternative splice variants.
.Ve
.SS "_comp_analysis"
.IX Subsection "_comp_analysis"
.Vb 6
\&  Usage:
\&  Desc :
\&  Ret  :
\&  Args :
\&  Side Effects:
\&  Example:
.Ve
.SS "_comp_result"
.IX Subsection "_comp_result"
.Vb 5
\&  Usage:
\&  Desc : recursively render a feature and its subfeatures as
\&         <result_set> and <result_span> elements
\&  Ret  : nothing meaningful
\&  Args : a feature
.Ve
.SS "_comp_result_span"
.IX Subsection "_comp_result_span"
.Vb 8
\&  Usage: _comp_result_span(\*(Aqfoo12\*(Aq,$feature);
\&  Desc : write GAME XML for a Bio::SeqFeature::Computation feature
\&         that has no subfeatures
\&  Ret  : nothing meaningful
\&  Args : name for this span (some kind of identifier),
\&         SeqFeature object to put into this span
\&  Side Effects:
\&  Example:
.Ve
.SS "_render_tags"
.IX Subsection "_render_tags"
.Vb 6
\&  Usage:
\&  Desc :
\&  Ret  :
\&  Args :
\&  Side Effects:
\&  Example:
.Ve
.SS "_render_output_tags"
.IX Subsection "_render_output_tags"
.Vb 5
\&  Usage:
\&  Desc : print out <output> elements, with contents
\&         taken from the SeqFeature::Computation\*(Aqs \*(Aqoutput\*(Aq tag
\&  Ret  : array of tag names this did not render
\&  Args : feature object, list of tag names to maybe render
\&
\&  In game xml, only <result_span> and <result_set> elements can
\&  have <output> elements.
.Ve
.SS "_render_tags_as_properties"
.IX Subsection "_render_tags_as_properties"
.Vb 6
\&  Usage:
\&  Desc :
\&  Ret  : empty array
\&  Args : feature object, array of tag names
\&  Side Effects:
\&  Example:
\&
\&  In game xml, <annotation>, <computational_analysis>,
\&  and <feature_set> elements can have properties.
.Ve
.SS "_render_comment_tags"
.IX Subsection "_render_comment_tags"
.Vb 6
\&  Usage:
\&  Desc :
\&  Ret  : names of tags that were not comment tags
\&  Args : feature object, tag names available for us to render
\&  Side Effects: writes XML
\&  Example:
\&
\&  In game xml, <annotation> and <feature_set> elements can
\&  have comments.
.Ve
.SS "_render_date_tags"
.IX Subsection "_render_date_tags"
.Vb 6
\&  Usage:
\&  Desc :
\&  Ret  : names of tags that were not date tags
\&  Args : feature, list of tag names available for us to render
\&  Side Effects: writes XML for <date> elements
\&  Example:
\&
\&  In game xml, <annotation>, <computational_analysis>,
\&  <transaction>, <comment>, and <feature_set> elements
\&  can have <date>s.
.Ve
.SS "_render_dbxref_tags"
.IX Subsection "_render_dbxref_tags"
.Vb 5
\&  Desc : look for xref tags and render them if they are there
\&  Ret  : tag names that we didn\*(Aqt render
\&  Args : feature object, list of tag names to render
\&  Side Effects: writes a <dbxref> element if a tag with name
\&                matching /xref$/i is present
\&
\&
\&  In game xml, <annotation> and <seq> elements can have dbxrefs.
.Ve
.SS "_render_target_tags"
.IX Subsection "_render_target_tags"
.Vb 7
\&  Usage:
\&  Desc : process any \*(AqTarget\*(Aq tags that would indicate a sequence alignment subject
\&  Ret  : array of tag names that we didn\*(Aqt render
\&  Args : feature object
\&  Side Effects: writes a <seq_relationship> of type \*(Aqsubject\*(Aq if it finds
\&                any properly formed tags named \*(AqTarget\*(Aq
\&  Example:
\&
\&  In game xml, <result_span>, <feature_span>, and <result_set> can have
\&  <seq_relationship>s.  <result_set> can only have one, a \*(Aqquery\*(Aq relation.
.Ve
.SS "_property"
.IX Subsection "_property"
.Vb 5
\& Title   : _property
\& Usage   : $self\->_property($tag => $value); 
\& Function: an internal method to write property XML elements
\& Returns : nothing
\& Args    : a tag/value pair
.Ve
.SS "_unflatten_attribute"
.IX Subsection "_unflatten_attribute"
.Vb 5
\& Title   : _unflatten_attribute
\& Usage   : $self\->_unflatten_attribute($name, $value)
\& Function: an internal method to unflatten and write comment or evidence elements
\& Returns : nothing
\& Args    : a list of strings
.Ve
.SS "_xref"
.IX Subsection "_xref"
.Vb 5
\& Title   : _xref
\& Usage   : $self\->_xref($value) 
\& Function: an internal method to write db_xref elements
\& Returns : nothing 
\& Args    : a list of strings
.Ve
.SS "_feature_span"
.IX Subsection "_feature_span"
.Vb 6
\& Title   : _feature_span
\& Usage   : $self\->_feature_span($name, $type, $loc)
\& Function: an internal method to write a feature_span element
\&          (the actual feature with coordinates)
\& Returns : nothing 
\& Args    : a feature name and Bio::SeqFeatureI\-compliant object
.Ve
.SS "_seq_relationship"
.IX Subsection "_seq_relationship"
.Vb 7
\& Title   : _seq_relationship
\& Usage   : $self\->_seq_relationship($type, $loc)
\& Function: an internal method to handle feature_span sequence relationships
\& Returns : nothing
\& Args    : feature type, a Bio::LocationI\-compliant object,
\&           (optional) sequence name (defaults to the query seq)
\&           and (optional) alignment string
.Ve
.SS "_element"
.IX Subsection "_element"
.Vb 11
\& Title   : _element
\& Usage   : $self\->_element($name, $chars, $atts)
\& Function: an internal method to generate \*(Aqgeneric\*(Aq XML elements
\& Example : 
\& my $name = \*(Aqfoo\*(Aq;
\& my $content = \*(Aqbar\*(Aq;
\& my $attributes = { baz => 1 }; 
\& # print the element
\& $self\->_element($name, $content, $attributes);
\& Returns : nothing 
\& Args    : the element name and content plus a ref to an attribute hash
.Ve
.SS "_span"
.IX Subsection "_span"
.Vb 5
\& Title   : _span
\& Usage   : $self\->_span($loc)
\& Function: an internal method to write the \*(Aqspan\*(Aq element
\& Returns : nothing
\& Args    : a Bio::LocationI\-compliant object
.Ve
.SS "_seq"
.IX Subsection "_seq"
.Vb 5
\& Title   : _seq
\& Usage   : $self\->_seq($seq, $dna) 
\& Function: an internal method to print the \*(Aqsequence\*(Aq element
\& Returns : nothing
\& Args    : and Bio::SeqI\-compliant object and a reference to an attribute  hash
.Ve
.SS "_find_name"
.IX Subsection "_find_name"
.Vb 5
\& Title   : _find_name
\& Usage   : my $name = $self\->_find_name($feature)
\& Function: an internal method to look for a gene name
\& Returns : a string 
\& Args    : a Bio::SeqFeatureI\-compliant object
.Ve
