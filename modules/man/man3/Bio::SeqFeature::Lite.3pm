.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::SeqFeature::Lite 3pm"
.TH Bio::SeqFeature::Lite 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SeqFeature::Lite \- Lightweight Bio::SeqFeatureI class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& # create a simple feature with no internal structure
\& $f = Bio::SeqFeature::Lite\->new(\-start => 1000,
\&                                  \-stop  => 2000,
\&                                  \-type  => \*(Aqtranscript\*(Aq,
\&                                  \-name  => \*(Aqalpha\-1 antitrypsin\*(Aq,
\&                                  \-desc  => \*(Aqan enzyme inhibitor\*(Aq,
\&                                 );
\&
\& # create a feature composed of multiple segments, all of type "similarity"
\& $f = Bio::SeqFeature::Lite\->new(\-segments => [[1000,1100],[1500,1550],[1800,2000]],
\&                                  \-name     => \*(AqABC\-3\*(Aq,
\&                                  \-type     => \*(Aqgapped_alignment\*(Aq,
\&                                  \-subtype  => \*(Aqsimilarity\*(Aq);
\&
\& # build up a gene exon by exon
\& $e1 = Bio::SeqFeature::Lite\->new(\-start=>1,\-stop=>100,\-type=>\*(Aqexon\*(Aq);
\& $e2 = Bio::SeqFeature::Lite\->new(\-start=>150,\-stop=>200,\-type=>\*(Aqexon\*(Aq);
\& $e3 = Bio::SeqFeature::Lite\->new(\-start=>300,\-stop=>500,\-type=>\*(Aqexon\*(Aq);
\& $f  = Bio::SeqFeature::Lite\->new(\-segments=>[$e1,$e2,$e3],\-type=>\*(Aqgene\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a simple Bio::SeqFeatureI\-compliant object that is compatible
with Bio::Graphics::Panel.  With it you can create lightweight feature
objects for drawing.
.PP
All methods are as described in Bio::SeqFeatureI with the following additions:
.SS "The \fBnew()\fP Constructor"
.IX Subsection "The new() Constructor"
.Vb 1
\& $feature = Bio::SeqFeature::Lite\->new(@args);
.Ve
.PP
This method creates a new feature object.  You can create a simple
feature that contains no subfeatures, or a hierarchically nested object.
.PP
Arguments are as follows:
.PP
.Vb 10
\&  \-seq_id      the reference sequence
\&  \-start       the start position of the feature
\&  \-end         the stop position of the feature
\&  \-stop        an alias for end
\&  \-name        the feature name (returned by seqname())
\&  \-type        the feature type (returned by primary_tag())
\&  \-primary_tag the same as \-type
\&  \-source      the source tag
\&  \-score       the feature score (for GFF compatibility)
\&  \-desc        a description of the feature
\&  \-segments    a list of subfeatures (see below)
\&  \-subtype     the type to use when creating subfeatures
\&  \-strand      the strand of the feature (one of \-1, 0 or +1)
\&  \-phase       the phase of the feature (0..2)
\&  \-seq         a dna or protein sequence string to attach to feature
\&  \-id          an alias for \-name
\&  \-seqname     an alias for \-name
\&  \-display_id  an alias for \-name
\&  \-display_name an alias for \-name  (do you get the idea the API has changed?)
\&  \-primary_id  unique database ID
\&  \-url         a URL to link to when rendered with Bio::Graphics
\&  \-attributes  a hashref of tag value attributes, in which the key is the tag
\&               and the value is an array reference of values
\&  \-factory     a reference to a feature factory, used for compatibility with
\&               more obscure parts of Bio::DB::GFF
.Ve
.PP
The subfeatures passed in \-segments may be an array of
Bio::SeqFeature::Lite objects, or an array of [$start,$stop]
pairs. Each pair should be a two-element array reference.  In the
latter case, the feature type passed in \-subtype will be used when
creating the subfeatures.
.PP
If no feature type is passed, then it defaults to \*(L"feature\*(R".
.SS "Non-SeqFeatureI methods"
.IX Subsection "Non-SeqFeatureI methods"
A number of new methods are provided for compatibility with
Ace::Sequence, which has a slightly different \s-1API\s0 from SeqFeatureI:
.IP "\fBurl()\fR" 4
.IX Item "url()"
Get/set the \s-1URL\s0 that the graphical rendering of this feature will link to.
.IP "add_segment(@segments)" 4
.IX Item "add_segment(@segments)"
Add one or more segments (a subfeature).  Segments can either be
Feature objects, or [start,stop] arrays, as in the \-segments argument
to \fBnew()\fR.  The feature endpoints are automatically adjusted.
.IP "\fBsegments()\fR" 4
.IX Item "segments()"
An alias for \fBsub_SeqFeature()\fR.
.IP "\fBget_SeqFeatures()\fR" 4
.IX Item "get_SeqFeatures()"
Alias for \fBsub_SeqFeature()\fR
.IP "\fBget_all_SeqFeatures()\fR" 4
.IX Item "get_all_SeqFeatures()"
Alias for \fBsub_SeqFeature()\fR
.IP "\fBmerged_segments()\fR" 4
.IX Item "merged_segments()"
Another alias for \fBsub_SeqFeature()\fR.
.IP "\fBstop()\fR" 4
.IX Item "stop()"
An alias for \fBend()\fR.
.IP "\fBname()\fR" 4
.IX Item "name()"
An alias for \fBseqname()\fR.
.IP "\fBexons()\fR" 4
.IX Item "exons()"
An alias for \fBsub_SeqFeature()\fR (you don't want to know why!)
.SS "display_name"
.IX Subsection "display_name"
.Vb 4
\& Title   : display_name
\& Usage   : $id = $obj\->display_name or $obj\->display_name($newid);
\& Function: Gets or sets the display id, also known as the common name of
\&           the Seq object.
\&
\&           The semantics of this is that it is the most likely string
\&           to be used as an identifier of the sequence, and likely to
\&           have "human" readability.  The id is equivalent to the LOCUS
\&           field of the GenBank/EMBL databanks and the ID field of the
\&           Swissprot/sptrembl database. In fasta format, the >(\eS+) is
\&           presumed to be the id, though some people overload the id
\&           to embed other information. Bioperl does not use any
\&           embedded information in the ID field, and people are
\&           encouraged to use other mechanisms (accession field for
\&           example, or extending the sequence object) to solve this.
\&
\&           Notice that $seq\->id() maps to this function, mainly for
\&           legacy/convenience issues.
\& Returns : A string
\& Args    : None or a new id
.Ve
.SS "accession_number"
.IX Subsection "accession_number"
.Vb 8
\& Title   : accession_number
\& Usage   : $unique_biological_key = $obj\->accession_number;
\& Function: Returns the unique biological id for a sequence, commonly
\&           called the accession_number. For sequences from established
\&           databases, the implementors should try to use the correct
\&           accession number. Notice that primary_id() provides the
\&           unique id for the implementation, allowing multiple objects
\&           to have the same accession number in a particular implementation.
\&
\&           For sequences with no accession number, this method should return
\&           "unknown".
\& Returns : A string
\& Args    : None
.Ve
.SS "alphabet"
.IX Subsection "alphabet"
.Vb 4
\& Title   : alphabet
\& Usage   : if( $obj\->alphabet eq \*(Aqdna\*(Aq ) { /Do Something/ }
\& Function: Returns the type of sequence being one of
\&           \*(Aqdna\*(Aq, \*(Aqrna\*(Aq or \*(Aqprotein\*(Aq. This is case sensitive.
\&
\&           This is not called <type> because this would cause
\&           upgrade problems from the 0.5 and earlier Seq objects.
\&
\& Returns : a string either \*(Aqdna\*(Aq,\*(Aqrna\*(Aq,\*(Aqprotein\*(Aq. NB \- the object must
\&           make a call of the type \- if there is no type specified it
\&           has to guess.
\& Args    : none
\& Status  : Virtual
.Ve
.SS "desc"
.IX Subsection "desc"
.Vb 6
\& Title   : desc
\& Usage   : $seqobj\->desc($string) or $seqobj\->desc()
\& Function: Sets or gets the description of the sequence
\& Example :
\& Returns : The description
\& Args    : The description or none
.Ve
.SS "location"
.IX Subsection "location"
.Vb 6
\& Title   : location
\& Usage   : my $location = $seqfeature\->location()
\& Function: returns a location object suitable for identifying location
\&           of feature on sequence or parent feature
\& Returns : Bio::LocationI object
\& Args    : none
.Ve
.SS "location_string"
.IX Subsection "location_string"
.Vb 5
\& Title   : location_string
\& Usage   : my $string = $seqfeature\->location_string()
\& Function: Returns a location string in a format recognized by gbrowse
\& Returns : a string
\& Args    : none
.Ve
.PP
This is a convenience function used by the generic genome browser. It
returns the location of the feature and its subfeatures in the compact
form \*(L"start1..end1,start2..end2,...\*(R".  Use
\&\f(CW$seqfeature\fR\->\fBlocation()\fR\->\fBtoFTString()\fR to obtain a standard
GenBank/EMBL location representation.
.SS "clone"
.IX Subsection "clone"
.Vb 5
\& Title   : clone
\& Usage   : my $feature = $seqfeature\->clone
\& Function: Create a deep copy of the feature
\& Returns : A copy of the feature
\& Args    : none
.Ve
.SS "refseq"
.IX Subsection "refseq"
.Vb 6
\& Title   : refseq
\& Usage   : $ref = $s\->refseq([$newseq] [,$newseqclass])
\& Function: get/set reference sequence
\& Returns : current reference sequence
\& Args    : new reference sequence and class (optional)
\& Status  : Public
.Ve
.PP
This method will get or set the reference sequence.  Called with no
arguments, it returns the current reference sequence.  Called with any
Bio::SeqFeatureI object that provides the \fBseq_id()\fR, \fBstart()\fR, \fBend()\fR and
\&\fBstrand()\fR methods.
.PP
The method will generate an exception if you attempt to set the
reference sequence to a sequence that has a different seq_id from the
current feature.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Graphics::Feature
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.edu>.
.PP
Copyright (c) 2006 Cold Spring Harbor Laboratory
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  See \s-1DISCLAIMER\s0.txt for
disclaimers of warranty.
