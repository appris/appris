.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Annotation::TagTree 3pm"
.TH Bio::Annotation::TagTree 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Annotation::TagTree \- AnnotationI with tree\-like hierarchal key\-value
relationships ('structured tags') that can be represented as simple text.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Bio::Annotation::TagTree;
\&   use Bio::Annotation::Collection;
\&
\&   my $col = Bio::Annotation::Collection\->new();
\&
\&   # data structure can be an array reference with a data structure
\&   # corresponding to that defined by Data::Stag:
\&
\&   my $sv = Bio::Annotation::TagTree\->new(\-tagname => \*(Aqmytag1\*(Aq,
\&                                          \-value => $data_structure);
\&   $col\->add_Annotation($sv);
\&
\&   # regular text passed is parsed based on the tagformat().
\&   my $sv2 = Bio::Annotation::TagTree\->new(\-tagname => \*(Aqmytag2\*(Aq,
\&                                          \-tagformat => \*(Aqxml\*(Aq,
\&                                          \-value => $xmltext);
\&   $col\->add_Annotation($sv2);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This takes tagged data values and stores them in a hierarchal structured
element-value hierarchy (complements of Chris Mungall's Data::Stag module). Data
can then be represented as text using a variety of output formats (indention,
itext, xml, spxr). Furthermore, the data structure can be queried using various
means. See Data::Stag for details.
.PP
Data passed in using \fBvalue()\fR or the '\-value' parameter upon instantiation
can either be:
.PP
1) an array reference corresponding to the data structure for Data::Stag;
.PP
2) a text string in 'xml', 'itext', 'spxr', or 'indent' format. The default
format is 'xml'; this can be changed using \fBtagformat()\fR prior to using \fBvalue()\fR or
by passing in the proper format using '\-tagformat' upon instantiation;
.PP
3) another Bio::Annotation::TagTree or Data::Stag node instance.  In both cases
a deep copy (duplicate) of the instance is generated.
.PP
Beyond checking for an array reference no format guessing occurs (so, for
roundtrip tests ensure that the \s-1IO\s0 formats correspond). For now, we recommend
when using text input to set \fBtagformat()\fR to one of these formats prior to data
loading to ensure the proper Data::Stag parser is selected. After data loading,
the \fBtagformat()\fR can be changed to change the text string format returned by
\&\fBvalue()\fR. (this may be rectified in the future)
.PP
This Annotation type is fully BioSQL compatible and could be considered a
temporary replacement for nested Bio::Annotation::Collections, at least until
BioSQL and bioperl-db can support nested annotation collections.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via
or the web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Fields
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal
methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 9
\& Title   : new
\& Usage   : my $sv = Bio::Annotation::TagTree\->new();
\& Function: Instantiate a new TagTree object
\& Returns : Bio::Annotation::TagTree object
\& Args    : \-value => $value to initialize the object data field [optional]
\&           \-tagname => $tag to initialize the tagname [optional]
\&           \-tagformat => format for output [optional]
\&                      (types \*(Aqxml\*(Aq, \*(Aqitext\*(Aq, \*(Aqsxpr\*(Aq, \*(Aqindent\*(Aq, default = \*(Aqitext\*(Aq)
\&           \-node => Data::Stag node or Bio::Annotation::TagTree instance
.Ve
.SH "AnnotationI implementing functions"
.IX Header "AnnotationI implementing functions"
.SS "as_text"
.IX Subsection "as_text"
.Vb 5
\& Title   : as_text
\& Usage   : my $text = $obj\->as_text
\& Function: return the string "Value: $v" where $v is the value
\& Returns : string
\& Args    : none
.Ve
.SS "display_text"
.IX Subsection "display_text"
.Vb 4
\& Title   : display_text
\& Usage   : my $str = $ann\->display_text();
\& Function: returns a string. Unlike as_text(), this method returns a string
\&           formatted as would be expected for the specific implementation.
\&
\&           One can pass a callback as an argument which allows custom text
\&           generation; the callback is passed the current instance and any text
\&           returned
\& Example :
\& Returns : a string
\& Args    : [optional] callback
.Ve
.SS "hash_tree"
.IX Subsection "hash_tree"
.Vb 7
\& Title   : hash_tree
\& Usage   : my $hashtree = $value\->hash_tree
\& Function: For supporting the AnnotationI interface just returns the value
\&           as a hashref with the key \*(Aqvalue\*(Aq pointing to the value
\&           Maybe reimplement using Data::Stag::hash()?
\& Returns : hashrf
\& Args    : none
.Ve
.SS "tagname"
.IX Subsection "tagname"
.Vb 3
\& Title   : tagname
\& Usage   : $obj\->tagname($newval)
\& Function: Get/set the tagname for this annotation value.
\&
\&           Setting this is optional. If set, it obviates the need to provide
\&           a tag to AnnotationCollection when adding this object.
\& Example :
\& Returns : value of tagname (a scalar)
\& Args    : new value (a scalar, optional)
.Ve
.SH "Specific accessors for TagTree"
.IX Header "Specific accessors for TagTree"
.SS "value"
.IX Subsection "value"
.Vb 5
\& Title   : value
\& Usage   : $obj\->value($newval)
\& Function: Get/set the value for this annotation.
\& Returns : value of value
\& Args    : newvalue (optional)
.Ve
.SS "tagformat"
.IX Subsection "tagformat"
.Vb 6
\& Title   : tagformat
\& Usage   : $obj\->tagformat($newval)
\& Function: Get/set the output tag format for this annotation.
\& Returns : value of tagformat
\& Args    : newvalue (optional) \- format for the data passed into value
\&           must be of values \*(Aqxml\*(Aq, \*(Aqindent\*(Aq, \*(Aqsxpr\*(Aq, \*(Aqitext\*(Aq, \*(Aqperl\*(Aq
.Ve
.SS "node"
.IX Subsection "node"
.Vb 7
\& Title   : node
\& Usage   : $obj\->node()
\& Function: Get/set the topmost Data::Stag node used for this annotation.  
\& Returns : Data::Stag node implementation
\&           (default is Data::Stag::StagImpl)
\& Args    : (optional) Data::Stag node implementation
\&           (optional)\*(Aqcopy\*(Aq => flag to create a copy of the node
.Ve
.SS "Data::Stag convenience methods"
.IX Subsection "Data::Stag convenience methods"
Because Data::Stag uses blessed arrays and the core Bioperl class uses blessed
hashes, TagTree uses an internal instance of a Data::Stag node for data storage.
Therefore the following methods actually delegate to the Data:::Stag internal
instance.
.PP
For consistency (since one could recursively check child nodes), methods retain
the same names as Data::Stag. Also, no 'magic' (\s-1AUTOLOAD\s0'ed) methods are
employed, simply b/c full-fledged Data::Stag functionality can be attained by
grabbing the Data::Stag instance using \fBnode()\fR.
.SS "element"
.IX Subsection "element"
.Vb 6
\& Title   : element
\& Usage   :
\& Function: Returns the element name (key name) for this node
\& Example :
\& Returns : scalar
\& Args    : none
.Ve
.SS "data"
.IX Subsection "data"
.Vb 6
\& Title   : data
\& Usage   :
\& Function: Returns the data structure (array ref) for this node
\& Example :
\& Returns : array ref
\& Args    : none
.Ve
.SS "children"
.IX Subsection "children"
.Vb 4
\& Title   : children
\& Usage   :
\& Function: Get the top\-level array of Data::Stag nodes or (if the top level is
\&           a terminal node) a scalar value.
\&
\&           This is similar to StructuredValue\*(Aqs get_values() method, with the
\&           key difference being instead of array refs and scalars you get either
\&           Data::Stag nodes or the value for this particular node.
\&
\&           For consistency (since one could recursively check nodes),
\&           we use the same method name as Data::Stag children().
\& Example :
\& Returns : an array
\& Args    : none
.Ve
.SS "subnodes"
.IX Subsection "subnodes"
.Vb 8
\& Title   : subnodes
\& Usage   :
\& Function: Get the top\-level array of Data::Stag nodes.  Unlike children(),
\&           this only returns an array of nodes (if this is a terminal node,
\&           no value is returned)
\& Example :
\& Returns : an array of nodes
\& Args    : none
.Ve
.SS "get"
.IX Subsection "get"
.Vb 7
\& Title   : get
\& Usage   : 
\& Function: Returns the nodes or value for the named element or path
\& Example : 
\& Returns : returns array of nodes or a scalar (if node is terminal)
\&           dependent on wantarray
\& Args    : none
.Ve
.SS "find"
.IX Subsection "find"
.Vb 7
\& Title   : find
\& Usage   : 
\& Function: Recursively searches for and returns the nodes or values for the
\&           named element or path
\& Example : 
\& Returns : returns array of nodes or scalars (for terminal nodes)
\& Args    : none
.Ve
.SS "findnode"
.IX Subsection "findnode"
.Vb 7
\& Title   : findnode
\& Usage   : 
\& Function: Recursively searches for and returns a list of nodes
\&           of the given element path
\& Example : 
\& Returns : returns array of nodes
\& Args    : none
.Ve
.SS "findval"
.IX Subsection "findval"
.Vb 6
\& Title   : findval
\& Usage   : 
\& Function: 
\& Example : 
\& Returns : returns array of nodes or values
\& Args    : none
.Ve
.SS "addchild"
.IX Subsection "addchild"
.Vb 5
\& Title   : addchild
\& Usage   : $struct\->addchild([\*(Aqname\*(Aq => [[\*(Aqfoo\*(Aq=> \*(Aqbar1\*(Aq]]]);
\& Function: add new child node to the current node.  One can pass in a node, TagTree,
\&           or data structure; for instance, in the above, this would translate
\&           to (in XML):
\&
\&           <name>
\&             <foo>bar1</foo>
\&           </name>
\&
\& Returns : node
\& Args    : first arg = element name
\&           all other args are added as tag\-value pairs
.Ve
.SS "add"
.IX Subsection "add"
.Vb 10
\& Title   : add
\& Usage   : $struct\->add(\*(Aqfoo\*(Aq, \*(Aqbar1\*(Aq, \*(Aqbar2\*(Aq, \*(Aqbar3\*(Aq);
\& Function: add tag\-value nodes to the current node.  In the above, this would
\&           translate to (in XML):
\&           <foo>bar1</foo>
\&           <foo>bar2</foo>
\&           <foo>bar3</foo>
\& Returns : 
\& Args    : first arg = element name
\&           all other args are added as tag\-value pairs
.Ve
.SS "set"
.IX Subsection "set"
.Vb 7
\& Title   : set
\& Usage   : $struct\->set(\*(Aqfoo\*(Aq,\*(Aqbar\*(Aq);
\& Function: sets a single tag\-value pair in the current node.  Note this
\&           differs from add() in that this replaces any data already present
\& Returns : node
\& Args    : first arg = element name
\&           all other args are added as tag\-value pairs
.Ve
.SS "unset"
.IX Subsection "unset"
.Vb 6
\& Title   : unset
\& Usage   : $struct\->unset(\*(Aqfoo\*(Aq);
\& Function: unsets all key\-value pairs of the passed element from the
\&           current node
\& Returns : node
\& Args    : element name
.Ve
.SS "free"
.IX Subsection "free"
.Vb 5
\& Title   : free
\& Usage   : $struct\->free
\& Function: removes all data from the current node
\& Returns : 
\& Args    :
.Ve
.SS "hash"
.IX Subsection "hash"
.Vb 6
\& Title   : hash
\& Usage   : $struct\->hash;
\& Function: turns the tag\-value tree into a hash, all data values are array refs
\& Returns : hash
\& Args    : first arg = element name
\&           all other args are added as tag\-value pairs
.Ve
.SS "pairs"
.IX Subsection "pairs"
.Vb 7
\& Title   : pairs
\& Usage   : $struct\->pairs;
\& Function: turns the tag\-value tree into a hash, all data values are scalar
\& Returns : hash
\& Args    : first arg = element name
\&           all other args are added as tag\-value pairs, note that duplicates
\&           will be lost
.Ve
.SS "qmatch"
.IX Subsection "qmatch"
.Vb 6
\& Title    : qmatch
\& Usage    : @persons = $s\->qmatch(\*(Aqperson\*(Aq, (\*(Aqname\*(Aq=>\*(Aqfred\*(Aq));
\& Function : returns all elements in the node tree which match the
\&            element name and the key\-value pair
\& Returns  : Array of nodes
\& Args     : return\-element str, match\-element str, match\-value str
.Ve
.SS "tnodes"
.IX Subsection "tnodes"
.Vb 5
\& Title    : tnodes
\& Usage    : @termini = $s\->tnodes;
\& Function : returns all terminal nodes below this node
\& Returns  : Array of nodes
\& Args     : return\-element str, match\-element str, match\-value str
.Ve
.SS "ntnodes"
.IX Subsection "ntnodes"
.Vb 5
\& Title    : ntnodes
\& Usage    : @termini = $s\->ntnodes;
\& Function : returns all nonterminal nodes below this node
\& Returns  : Array of nodes
\& Args     : return\-element str, match\-element str, match\-value str
.Ve
.SS "StructureValue-like methods"
.IX Subsection "StructureValue-like methods"
.SS "get_all_values"
.IX Subsection "get_all_values"
.Vb 5
\& Title    : get_all_values
\& Usage    : @termini = $s\->get_all_values;
\& Function : returns all terminal node values
\& Returns  : Array of values
\& Args     : return\-element str, match\-element str, match\-value str
.Ve
.PP
This is meant to emulate the values one would get from StructureValue's
\&\fBget_all_values()\fR method. Note, however, using this method dissociates the
tag-value relationship (i.e. you only get the value list, no elements)
