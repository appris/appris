.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::SeqFeature::Generic 3pm"
.TH Bio::SeqFeature::Generic 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SeqFeature::Generic \- Generic SeqFeature
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&   $feat = Bio::SeqFeature::Generic\->new( 
\&            \-start        => 10, 
\&            \-end          => 100,
\&            \-strand       => \-1, 
\&            \-primary      => \*(Aqrepeat\*(Aq, # \-primary_tag is a synonym
\&            \-source_tag   => \*(Aqrepeatmasker\*(Aq,
\&            \-display_name => \*(Aqalu family\*(Aq,
\&            \-score        => 1000,
\&            \-tag          => { new => 1,
\&                               author => \*(Aqsomeone\*(Aq,
\&                               sillytag => \*(Aqthis is silly!\*(Aq } );
\&
\&   $feat = Bio::SeqFeature::Generic\->new( \-gff_string => $string );
\&   # if you want explicitly GFF1
\&   $feat = Bio::SeqFeature::Generic\->new( \-gff1_string => $string );
\&
\&   # add it to an annotated sequence
\&
\&   $annseq\->add_SeqFeature($feat);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::SeqFeature::Generic is a generic implementation for the
Bio::SeqFeatureI interface, providing a simple object to provide all
the information for a feature on a sequence.
.PP
For many Features, this is all you will need to use (for example, this
is fine for Repeats in \s-1DNA\s0 sequence or Domains in protein
sequence). For other features, which have more structure, this is a
good base class to extend using inheritance to have new things: this
is what is done in the Bio::SeqFeature::Gene,
Bio::SeqFeature::Transcript and Bio::SeqFeature::Exon, which provide
well coordinated classes to represent genes on \s-1DNA\s0 sequence (for
example, you can get the protein sequence out from a transcript
class).
.PP
For many Features, you want to add some piece of information, for
example a common one is that this feature is 'new' whereas other
features are 'old'.  The tag system, which here is implemented using a
hash can be used here.  You can use the tag system to extend the
Bio::SeqFeature::Generic programmatically: that is, you know that you have
read in more information into the tag 'mytag' which you can then
retrieve. This means you do not need to know how to write inherited
Perl to provide more complex information on a feature, and/or, if you
do know but you do not want to write a new class every time you need
some extra piece of information, you can use the tag system to easily
store and then retrieve information.
.PP
The tag system can be written in/out of \s-1GFF\s0 format, and also into \s-1EMBL\s0
format via the Bio::SeqIO system
.SH "Implemented Interfaces"
.IX Header "Implemented Interfaces"
This class implements the following interfaces.
.IP "Bio::SeqFeatureI" 4
.IX Item "Bio::SeqFeatureI"
Note that this includes implementing Bio::RangeI.
.IP "Bio::AnnotatableI" 4
.IX Item "Bio::AnnotatableI"
.PD 0
.IP "Bio::FeatureHolderI" 4
.IX Item "Bio::FeatureHolderI"
.PD
Features held by a feature are essentially sub-features.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via 
the web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Ewan Birney <birney@sanger.ac.uk>
.SH "DEVELOPERS"
.IX Header "DEVELOPERS"
This class has been written with an eye out for inheritance. The fields
the actual object hash are:
.PP
.Vb 2
\&   _gsf_tag_hash  = reference to a hash for the tags
\&   _gsf_sub_array = reference to an array for subfeatures
.Ve
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "set_attributes"
.IX Subsection "set_attributes"
.Vb 7
\& Title   : set_attributes
\& Usage   :
\& Function: Sets a whole array of parameters at once.
\& Example :
\& Returns : none
\& Args    : Named parameters, in the form as they would otherwise be passed
\&           to new(). Currently recognized are:
\&
\&                    \-start          start position
\&                    \-end            end position
\&                    \-strand         strand
\&                    \-phase          the phase of the feature (0..2)
\&                    \-primary_tag    primary tag 
\&                    \-primary        (synonym for \-primary_tag)
\&                    \-source_tag     source tag
\&                    \-source         (synonym for \-source_tag)
\&                    \-frame          frame
\&                    \-score          score value
\&                    \-tag            a reference to a tag/value hash
\&                    \-gff_string     GFF v.2 string to initialize from
\&                    \-gff1_string    GFF v.1 string to initialize from
\&                    \-seq_id         the display name of the sequence
\&                    \-annotation     the AnnotationCollectionI object
\&                    \-location       the LocationI object
.Ve
.SS "direct_new"
.IX Subsection "direct_new"
.Vb 6
\& Title   : direct_new
\& Usage   : my $feat = Bio::SeqFeature::Generic\->direct_new;
\& Function: create a blessed hash \- for performance improvement in 
\&           object creation
\& Returns : Bio::SeqFeature::Generic object
\& Args    : none
.Ve
.SS "location"
.IX Subsection "location"
.Vb 6
\& Title   : location
\& Usage   : my $location = $feat\->location();
\& Function: returns a location object suitable for identifying location 
\&           of feature on sequence or parent feature  
\& Returns : Bio::LocationI object
\& Args    : [optional] Bio::LocationI object to set the value to.
.Ve
.SS "start"
.IX Subsection "start"
.Vb 6
\& Title   : start
\& Usage   : my $start = $feat\->start;
\&           $feat\->start(20);
\& Function: Get/set on the start coordinate of the feature
\& Returns : integer
\& Args    : none
.Ve
.SS "end"
.IX Subsection "end"
.Vb 6
\& Title   : end
\& Usage   : my $end = $feat\->end;
\&           $feat\->end($end);
\& Function: get/set on the end coordinate of the feature
\& Returns : integer
\& Args    : none
.Ve
.SS "length"
.IX Subsection "length"
.Vb 6
\& Title   : length
\& Usage   : my $len = $feat\->length;
\& Function: Get the feature length computed as:
\&              $feat\->end \- $feat\->start + 1
\& Returns : integer
\& Args    : none
.Ve
.SS "strand"
.IX Subsection "strand"
.Vb 6
\& Title   : strand
\& Usage   : my $strand = $feat\->strand();
\&           $feat\->strand($strand);
\& Function: get/set on strand information, being 1,\-1 or 0
\& Returns : \-1,1 or 0
\& Args    : none
.Ve
.SS "score"
.IX Subsection "score"
.Vb 6
\& Title   : score
\& Usage   : my $score = $feat\->score();
\&           $feat\->score($score);
\& Function: get/set on score information
\& Returns : float
\& Args    : none if get, the new value if set
.Ve
.SS "frame"
.IX Subsection "frame"
.Vb 6
\& Title   : frame
\& Usage   : my $frame = $feat\->frame();
\&           $feat\->frame($frame);
\& Function: get/set on frame information
\& Returns : 0,1,2, \*(Aq.\*(Aq
\& Args    : none if get, the new value if set
.Ve
.SS "primary_tag"
.IX Subsection "primary_tag"
.Vb 7
\& Title   : primary_tag
\& Usage   : my $tag = $feat\->primary_tag();
\&           $feat\->primary_tag(\*(Aqexon\*(Aq);
\& Function: get/set on the primary tag for a feature,
\&           eg \*(Aqexon\*(Aq
\& Returns : a string
\& Args    : none
.Ve
.SS "source_tag"
.IX Subsection "source_tag"
.Vb 7
\& Title   : source_tag
\& Usage   : my $tag = $feat\->source_tag();
\&           $feat\->source_tag(\*(Aqgenscan\*(Aq);
\& Function: Returns the source tag for a feature,
\&           eg, \*(Aqgenscan\*(Aq
\& Returns : a string
\& Args    : none
.Ve
.SS "has_tag"
.IX Subsection "has_tag"
.Vb 6
\& Title   : has_tag
\& Usage   : my $value = $feat\->has_tag(\*(Aqsome_tag\*(Aq);
\& Function: Tests whether a feature containings a tag
\& Returns : TRUE if the SeqFeature has the tag,
\&           and FALSE otherwise.
\& Args    : The name of a tag
.Ve
.SS "add_tag_value"
.IX Subsection "add_tag_value"
.Vb 4
\& Title   : add_tag_value
\& Usage   : $feat\->add_tag_value(\*(Aqnote\*(Aq,"this is a note");
\& Returns : TRUE on success
\& Args    : tag (string) and one or more values (any scalar(s))
.Ve
.SS "get_tag_values"
.IX Subsection "get_tag_values"
.Vb 6
\& Title   : get_tag_values
\& Usage   : my @values = $feat\->get_tag_values(\*(Aqnote\*(Aq);
\& Function: Returns a list of all the values stored
\&           under a particular tag.
\& Returns : A list of scalars
\& Args    : The name of the tag
.Ve
.SS "get_all_tags"
.IX Subsection "get_all_tags"
.Vb 5
\& Title   : get_all_tags
\& Usage   : my @tags = $feat\->get_all_tags();
\& Function: Get a list of all the tags in a feature
\& Returns : An array of tag names
\& Args    : none
.Ve
.PP
# added a sort so that tags will be returned in a predictable order
# I still think we should be able to specify a sort function
# to the object at some point
# \-js
.SS "remove_tag"
.IX Subsection "remove_tag"
.Vb 5
\& Title   : remove_tag
\& Usage   : $feat\->remove_tag(\*(Aqsome_tag\*(Aq);
\& Function: removes a tag from this feature
\& Returns : the array of values for this tag before removing it
\& Args    : tag (string)
.Ve
.SS "attach_seq"
.IX Subsection "attach_seq"
.Vb 8
\& Title   : attach_seq
\& Usage   : $feat\->attach_seq($seq);
\& Function: Attaches a Bio::Seq object to this feature. This
\&           Bio::Seq object is for the *entire* sequence: ie
\&           from 1 to 10000
\& Example :
\& Returns : TRUE on success
\& Args    : a Bio::PrimarySeqI compliant object
.Ve
.SS "seq"
.IX Subsection "seq"
.Vb 9
\& Title   : seq
\& Usage   : my $tseq = $feat\->seq();
\& Function: returns the truncated sequence (if there) for this
\& Example :
\& Returns : sub seq (a Bio::PrimarySeqI compliant object) on attached sequence
\&           bounded by start & end, or undef if there is no sequence attached.
\&           If the strand is defined and set to \-1, the returned sequence is
\&           the reverse\-complement of the region
\& Args    : none
.Ve
.SS "entire_seq"
.IX Subsection "entire_seq"
.Vb 7
\& Title   : entire_seq
\& Usage   : my $whole_seq = $feat\->entire_seq();
\& Function: gives the entire sequence that this seqfeature is attached to
\& Example :
\& Returns : a Bio::PrimarySeqI compliant object, or undef if there is no
\&           sequence attached
\& Args    :
.Ve
.SS "seq_id"
.IX Subsection "seq_id"
.Vb 6
\& Title   : seq_id
\& Usage   : $feat\->seq_id($newval)
\& Function: There are many cases when you make a feature that you
\&           do know the sequence name, but do not know its actual
\&           sequence. This is an attribute such that you can store
\&           the ID (e.g., display_id) of the sequence.
\&
\&           This attribute should *not* be used in GFF dumping, as
\&           that should come from the collection in which the seq
\&           feature was found.
\& Returns : value of seq_id
\& Args    : newvalue (optional)
.Ve
.SS "display_name"
.IX Subsection "display_name"
.Vb 6
\& Title   : display_name
\& Usage   : my $featname = $feat\->display_name;
\& Function: Implements the display_name() method, which is a human\-readable
\&           name for the feature. 
\& Returns : value of display_name (a string)
\& Args    : Optionally, on set the new value or undef
.Ve
.SH "Methods for implementing Bio::AnnotatableI"
.IX Header "Methods for implementing Bio::AnnotatableI"
.SS "annotation"
.IX Subsection "annotation"
.Vb 4
\& Title   : annotation
\& Usage   : $feat\->annotation($annot_obj);
\& Function: Get/set the annotation collection object for annotating this
\&           feature.
\&
\& Example : 
\& Returns : A Bio::AnnotationCollectionI object
\& Args    : newvalue (optional)
.Ve
.SH "Methods to implement Bio::FeatureHolderI"
.IX Header "Methods to implement Bio::FeatureHolderI"
This includes methods for retrieving, adding, and removing
features. Since this is already a feature, features held by this
feature holder are essentially sub-features.
.SS "get_SeqFeatures"
.IX Subsection "get_SeqFeatures"
.Vb 5
\& Title   : get_SeqFeatures
\& Usage   : my @feats = $feat\->get_SeqFeatures();
\& Function: Returns an array of sub Sequence Features
\& Returns : An array
\& Args    : none
.Ve
.SS "add_SeqFeature"
.IX Subsection "add_SeqFeature"
.Vb 7
\& Title   : add_SeqFeature
\& Usage   : $feat\->add_SeqFeature($subfeat);
\&           $feat\->add_SeqFeature($subfeat,\*(AqEXPAND\*(Aq);
\& Function: Adds a SeqFeature into the subSeqFeature array.
\&           With no \*(AqEXPAND\*(Aq qualifer, subfeat will be tested
\&           as to whether it lies inside the parent, and throw
\&           an exception if not.
\&
\&           If EXPAND is used, the parent\*(Aqs start/end/strand will
\&           be adjusted so that it grows to accommodate the new
\&           subFeature
\&
\&           !IMPORTANT! The coordinates of the subfeature should not be relative
\&           to the parent feature it is attached to, but relative to the sequence
\&           the parent feature is located on.
\&
\& Returns : nothing
\& Args    : An object which has the SeqFeatureI interface
.Ve
.SS "remove_SeqFeatures"
.IX Subsection "remove_SeqFeatures"
.Vb 3
\& Title   : remove_SeqFeatures
\& Usage   : $feat\->remove_SeqFeatures;
\& Function: Removes all SeqFeatures
\&
\&           If you want to remove only a subset of features then remove that 
\&           subset from the returned array, and add back the rest.
\& Example :
\& Returns : The array of Bio::SeqFeatureI implementing features that was
\&           deleted.
\& Args    : none
.Ve
.SH "GFF-related methods"
.IX Header "GFF-related methods"
.SS "gff_format"
.IX Subsection "gff_format"
.Vb 7
\& Title   : gff_format
\& Usage   : # get:
\&           my $gffio = $feat\->gff_format();
\&           # set (change the default version of GFF2):
\&           $feat\->gff_format(Bio::Tools::GFF\->new(\-gff_version => 1));
\& Function: Get/set the GFF format interpreter. This object is supposed to 
\&           format and parse GFF. See Bio::Tools::GFF for the interface.
\&
\&           If this method is called as class method, the default for all
\&           newly created instances will be changed. Otherwise only this
\&           instance will be affected.
\& Example : 
\& Returns : a Bio::Tools::GFF compliant object
\& Args    : On set, an instance of Bio::Tools::GFF or a derived object.
.Ve
.SS "gff_string"
.IX Subsection "gff_string"
.Vb 4
\& Title   : gff_string
\& Usage   : my $str = $feat\->gff_string;
\&           my $str = $feat\->gff_string($gff_formatter);
\& Function: Provides the feature information in GFF format.
\&
\&           We override this here from Bio::SeqFeatureI in order to use the
\&           formatter returned by gff_format().
\&
\& Returns : A string
\& Args    : Optionally, an object implementing gff_string().
.Ve
.SS "slurp_gff_file"
.IX Subsection "slurp_gff_file"
.Vb 4
\& Title   : slurp_file
\& Usage   : my @features = Bio::SeqFeature::Generic::slurp_gff_file(\e*FILE);
\& Function: Sneaky function to load an entire file as in memory objects.
\&           Beware of big files.
\&
\&           This method is deprecated. Use Bio::Tools::GFF instead, which can
\&           also handle large files.
\&
\& Example :
\& Returns :
\& Args    :
.Ve
.SS "_from_gff_string"
.IX Subsection "_from_gff_string"
.Vb 3
\& Title   : _from_gff_string
\& Usage   :
\& Function: Set feature properties from GFF string. 
\&
\&           This method uses the object returned by gff_format() for the
\&           actual interpretation of the string. Set a different GFF format
\&           interpreter first if you need a specific version, like GFF1. (The
\&           default is GFF2.)
\& Example :
\& Returns : 
\& Args    : a GFF\-formatted string
.Ve
.SS "_expand_region"
.IX Subsection "_expand_region"
.Vb 4
\& Title   : _expand_region
\& Usage   : $feat\->_expand_region($feature);
\& Function: Expand the total region covered by this feature to
\&           accommodate for the given feature.
\&
\&           May be called whenever any kind of subfeature is added to this
\&           feature. add_SeqFeature() already does this.
\& Returns : 
\& Args    : A Bio::SeqFeatureI implementing object.
.Ve
.SS "_parse"
.IX Subsection "_parse"
.Vb 6
\& Title   : _parse
\& Usage   :
\& Function: Parsing hints
\& Example :
\& Returns :
\& Args    :
.Ve
.SS "_tag_value"
.IX Subsection "_tag_value"
.Vb 6
\& Title   : _tag_value
\& Usage   : 
\& Function: For internal use only. Convenience method for those tags that
\&           may only have a single value.
\& Returns : The first value under the given tag as a scalar (string)
\& Args    : The tag as a string. Optionally, the value on set.
.Ve
