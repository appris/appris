.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::DB::IndexedBase 3pm"
.TH Bio::DB::IndexedBase 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::IndexedBase \- Base class for modules using indexed sequence files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::DB::XXX; # a made\-up class that uses Bio::IndexedBase
\&
\&  # 1/ Bio::SeqIO\-style access
\&
\&  # Index some sequence files
\&  my $db = Bio::DB::XXX\->new(\*(Aq/path/to/file\*(Aq);    # from a single file
\&  my $db = Bio::DB::XXX\->new([\*(Aqfile1\*(Aq, \*(Aqfile2\*(Aq]); # from multiple files
\&  my $db = Bio::DB::XXX\->new(\*(Aq/path/to/files/\*(Aq);  # from a directory
\&
\&  # Get IDs of all the sequences in the database
\&  my @ids = $db\->get_all_primary_ids;
\&
\&  # Get a specific sequence
\&  my $seq = $db\->get_Seq_by_id(\*(AqCHROMOSOME_I\*(Aq);
\&
\&  # Loop through all sequences
\&  my $stream = $db\->get_PrimarySeq_stream;
\&  while (my $seq = $stream\->next_seq) {
\&    # Do something...
\&  }
\&
\&
\&  # 2/ Access via filehandle
\&  my $fh = Bio::DB::XXX\->newFh(\*(Aq/path/to/file\*(Aq);
\&  while (my $seq = <$fh>) {
\&    # Do something...
\&  }
\&
\&
\&  # 3/ Tied\-hash access
\&  tie %sequences, \*(AqBio::DB::XXX\*(Aq, \*(Aq/path/to/file\*(Aq;
\&  print $sequences{\*(AqCHROMOSOME_I:1,20000\*(Aq};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::DB::IndexedBase provides a base class for modules that want to index
and read sequence files and provides persistent, random access to each sequence
entry, without bringing the entire file into memory. This module is compliant
with the Bio::SeqI interface and both. Bio::DB::Fasta and Bio::DB::Qual both use
Bio::DB::IndexedBase.
.PP
When you initialize the module, you point it at a single file, several files, or
a directory of files. The first time it is run, the module generates an index
of the content of the files using the AnyDBM_File module (BerkeleyDB preferred,
followed by GDBM_File, NDBM_File, and SDBM_File). Subsequently, it uses the
index file to find the sequence file and offset for any requested sequence. If
one of the source files is updated, the module reindexes just that one file. You
can also force reindexing manually at any time. For improved performance, the
module keeps a cache of open filehandles, closing less-recently used ones when
the cache is full.
.PP
Entries may have any line length up to 65,536 characters, and different line
lengths are allowed in the same file.  However, within a sequence entry, all
lines must be the same length except for the last. An error will be thrown if
this is not the case!
.PP
This module was developed for use with the C. elegans and human genomes, and has
been tested with sequence segments as large as 20 megabases. Indexing the C.
elegans genome (100 megabases of genomic sequence plus 100,000 ESTs) takes ~5
minutes on my 300 MHz pentium laptop. On the same system, average access time
for any 200\-mer within the C. elegans genome was <0.02s.
.SH "DATABASE CREATION AND INDEXING"
.IX Header "DATABASE CREATION AND INDEXING"
The two constructors for this class are \fBnew()\fR and \fBnewFh()\fR. The former creates a
Bio::DB::IndexedBase object which is accessed via method calls. The latter
creates a tied filehandle which can be used Bio::SeqIO style to fetch sequence
objects in a stream fashion. There is also a tied hash interface.
.ie n .IP "$db = Bio::DB::IndexedBase\->new($path [,%options])" 4
.el .IP "\f(CW$db\fR = Bio::DB::IndexedBase\->new($path [,%options])" 4
.IX Item "$db = Bio::DB::IndexedBase->new($path [,%options])"
Create a new Bio::DB::IndexedBase object from the files designated by \f(CW$path\fR
\&\f(CW$path\fR may be a single file, an arrayref of files, or a directory containing
such files.
.Sp
After the database is created, you can use methods like \fBget_all_primary_ids()\fR
and \fBget_Seq_by_id()\fR to retrieve sequence objects.
.ie n .IP "$fh = Bio::DB::IndexedBase\->newFh($path [,%options])" 4
.el .IP "\f(CW$fh\fR = Bio::DB::IndexedBase\->newFh($path [,%options])" 4
.IX Item "$fh = Bio::DB::IndexedBase->newFh($path [,%options])"
Create a tied filehandle opened on a Bio::DB::IndexedBase object. Reading
from this filehandle with <> will return a stream of sequence objects,
Bio::SeqIO style. The path and the options should be specified as for \fBnew()\fR.
.ie n .IP "$obj = tie %db,'Bio::DB::IndexedBase', '/path/to/file' [,@args]" 4
.el .IP "\f(CW$obj\fR = tie \f(CW%db\fR,'Bio::DB::IndexedBase', '/path/to/file' [,@args]" 4
.IX Item "$obj = tie %db,'Bio::DB::IndexedBase', '/path/to/file' [,@args]"
Create a tied-hash by tieing \f(CW%db\fR to Bio::DB::IndexedBase using the indicated
path to the files. The optional \f(CW@args\fR list is the same set used by \fBnew()\fR. If
successful, \fBtie()\fR returns the tied object, undef otherwise.
.Sp
Once tied, you can use the hash to retrieve an individual sequence by
its \s-1ID,\s0 like this:
.Sp
.Vb 1
\&  my $seq = $db{CHROMOSOME_I};
.Ve
.Sp
The \fBkeys()\fR and \fBvalues()\fR functions will return the sequence IDs and their
sequences, respectively.  In addition, \fBeach()\fR can be used to iterate over the
entire data set:
.Sp
.Vb 3
\& while (my ($id,$sequence) = each %db) {
\&    print "$id => $sequence\en";
\& }
.Ve
.Sp
When dealing with very large sequences, you can avoid bringing them into memory
by calling \fBeach()\fR in a scalar context.  This returns the key only.  You can then
use tied(%db) to recover the Bio::DB::IndexedBase object and call its methods.
.Sp
.Vb 4
\& while (my $id = each %db) {
\&    print "$id: $db{$sequence:1,100}\en";
\&    print "$id: ".tied(%db)\->length($id)."\en";
\& }
.Ve
.Sp
In addition, you may invoke the \s-1FIRSTKEY\s0 and \s-1NEXTKEY\s0 tied hash methods directly
to retrieve the first and next \s-1ID\s0 in the database, respectively. This allows one to
write the following iterative loop using just the object-oriented interface:
.Sp
.Vb 4
\& my $db = Bio::DB::IndexedBase\->new(\*(Aq/path/to/file\*(Aq);
\& for (my $id=$db\->FIRSTKEY; $id; $id=$db\->NEXTKEY($id)) {
\&    # do something with sequence
\& }
.Ve
.SH "INDEX CONTENT"
.IX Header "INDEX CONTENT"
Several attributes of each sequence are stored in the index file. Given a
sequence \s-1ID,\s0 these attributes can be retrieved using the following methods:
.IP "offset($id)" 4
.IX Item "offset($id)"
Get the offset of the indicated sequence from the beginning of the file in which
it is located. The offset points to the beginning of the sequence, not the
beginning of the header line.
.IP "strlen($id)" 4
.IX Item "strlen($id)"
Get the number of characters in the sequence string.
.IP "length($id)" 4
.IX Item "length($id)"
Get the number of residues of the sequence.
.IP "linelen($id)" 4
.IX Item "linelen($id)"
Get the length of the line for this sequence. If the sequence is wrapped, then
\&\fBlinelen()\fR is likely to be much shorter than \fBstrlen()\fR.
.IP "headerlen($id)" 4
.IX Item "headerlen($id)"
Get the length of the header line for the indicated sequence.
.IP "header_offset" 4
.IX Item "header_offset"
Get the offset of the header line for the indicated sequence from the beginning
of the file in which it is located. This attribute is not stored. It is
calculated from \fBoffset()\fR and \fBheaderlen()\fR.
.IP "alphabet($id)" 4
.IX Item "alphabet($id)"
Get the molecular type (alphabet) of the indicated sequence. This method handles
residues according to the \s-1IUPAC\s0 convention.
.IP "file($id)" 4
.IX Item "file($id)"
Get the the name of the file in which the indicated sequence can be found.
.SH "INTERFACE COMPLIANCE NOTES"
.IX Header "INTERFACE COMPLIANCE NOTES"
Bio::DB::IndexedBase is compliant with the Bio::DB::SeqI and hence with the
Bio::RandomAccessI interfaces.
.PP
Database do not necessarily provide any meaningful internal primary \s-1ID\s0 for the
sequences they store. However, Bio::DB::IndexedBase's internal primary IDs are
the IDs of the sequences. This means that the same \s-1ID\s0 passed to \fBget_Seq_by_id()\fR
and \fBget_Seq_by_primary_id()\fR will return the same sequence.
.PP
Since this database index has no notion of sequence version or namespace, the
\&\fBget_Seq_by_id()\fR, \fBget_Seq_by_acc()\fR and \fBget_Seq_by_version()\fR are identical.
.SH "BUGS"
.IX Header "BUGS"
When a sequence is deleted from one of the files, this deletion is not detected
by the module and removed from the index. As a result, a \*(L"ghost\*(R" entry will
remain in the index and will return garbage results if accessed.
.PP
Also, if you are indexing a directory, it is wise to not add or remove files
from it.
.PP
In case you have changed the files in a directory, or the sequences in a file,
you can to rebuild the entire index, either by deleting it manually, or by
passing \-reindex=>1 to \fBnew()\fR when initializing the module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DB_File
.PP
Bio::DB::Fasta
.PP
Bio::DB::Qual
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2001 Cold Spring Harbor Laboratory.
.PP
Florent Angly (for the modularization)
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  See \s-1DISCLAIMER\s0.txt for
disclaimers of warranty.
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : my $db = Bio::DB::IndexedBase\->new($path, \-reindex => 1);
\& Function: Initialize a new database object
\& Returns : A Bio::DB::IndexedBase object
\& Args    : A single file, or path to dir, or arrayref of files
\&           Optional arguments:
\&
\& Option        Description                                         Default
\& \-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-                                         \-\-\-\-\-\-\-
\& \-glob         Glob expression to search for files in directories  *
\& \-makeid       A code subroutine for transforming IDs              None
\& \-maxopen      Maximum size of filehandle cache                    32
\& \-debug        Turn on status messages                             0
\& \-reindex      Force the index to be rebuilt                       0
\& \-dbmargs      Additional arguments to pass to the DBM routine     None
\& \-index_name   Name of the file that will hold the indices
\& \-clean        Remove the index file when finished                 0
.Ve
.PP
The \-dbmargs option can be used to control the format of the index. For example,
you can pass \f(CW$DB_BTREE\fR to this argument so as to force the IDs to be sorted and
retrieved alphabetically. Note that you must use the same arguments every time
you open the index!
.PP
The \-makeid option gives you a chance to modify sequence IDs during indexing.
For example, you may wish to extract a portion of the gi|gb|abc|xyz nonsense
that GenBank Fasta files use. The original header line can be recovered later.
The option value for \-makeid should be a code reference that takes a scalar
argument (the full header line) and returns a scalar or an array of scalars (the
\&\s-1ID\s0 or IDs you want to assign). For example:
.PP
.Vb 1
\&  $db = Bio::DB::IndexedBase\->new(\*(Aqfile.fa\*(Aq, \-makeid => \e&extract_gi);
\&
\&  sub extract_gi {
\&      # Extract GI from GenBank
\&      my $header = shift;
\&      my ($id) = ($header =~ /gi\e|(\ed+)/m);
\&      return $id || \*(Aq\*(Aq;
\&  }
.Ve
.PP
\&\fBextract_gi()\fR will be called with the full header line, e.g. a Fasta line would
include the \*(L">\*(R", the \s-1ID\s0 and the description:
.PP
.Vb 1
\& >gi|352962132|ref|NG_030353.1| Homo sapiens sal\-like 3 (Drosophila) (SALL3)
.Ve
.PP
In the database, this sequence can now be retrieved by its \s-1GI\s0 instead of its
complete \s-1ID:\s0
.PP
.Vb 1
\& my $seq = $db\->get_Seq_by_id(352962132);
.Ve
.PP
The \-makeid option is ignored after the index is constructed.
.SS "newFh"
.IX Subsection "newFh"
.Vb 5
\& Title   : newFh
\& Usage   : my $fh = Bio::DB::IndexedBase\->newFh(\*(Aq/path/to/files/\*(Aq, %options);
\& Function: Index and get a new Fh for a single file, several files or a directory
\& Returns : Filehandle object
\& Args    : Same as new()
.Ve
.SS "dbmargs"
.IX Subsection "dbmargs"
.Vb 5
\& Title   : dbmargs
\& Usage   : my @args = $db\->dbmargs;
\& Function: Get stored dbm arguments
\& Returns : Array
\& Args    : None
.Ve
.SS "glob"
.IX Subsection "glob"
.Vb 5
\& Title   : glob
\& Usage   : my $glob = $db\->glob;
\& Function: Get the expression used to match files in directories
\& Returns : String
\& Args    : None
.Ve
.SS "index_dir"
.IX Subsection "index_dir"
.Vb 6
\& Title   : index_dir
\& Usage   : $db\->index_dir($dir);
\& Function: Index the files that match \-glob in the given directory
\& Returns : Hashref of offsets
\& Args    : Dirname
\&           Boolean to force a reindexing the directory
.Ve
.SS "get_all_primary_ids"
.IX Subsection "get_all_primary_ids"
.Vb 7
\& Title   : get_all_primary_ids, get_all_ids, ids
\& Usage   : my @ids = $db\->get_all_primary_ids;
\& Function: Get the IDs stored in all indexes. This is a Bio::DB::SeqI method
\&           implementation. Note that in this implementation, the internal
\&           database primary IDs are also the sequence IDs.
\& Returns : List of ids
\& Args    : None
.Ve
.SS "index_file"
.IX Subsection "index_file"
.Vb 6
\& Title   : index_file
\& Usage   : $db\->index_file($filename);
\& Function: Index the given file
\& Returns : Hashref of offsets
\& Args    : Filename
\&           Boolean to force reindexing the file
.Ve
.SS "index_files"
.IX Subsection "index_files"
.Vb 6
\& Title   : index_files
\& Usage   : $db\->index_files(\e@files);
\& Function: Index the given files
\& Returns : Hashref of offsets
\& Args    : Arrayref of filenames
\&           Boolean to force reindexing the files
.Ve
.SS "index_name"
.IX Subsection "index_name"
.Vb 5
\& Title   : index_name
\& Usage   : my $indexname = $db\->index_name($path);
\& Function: Get the full name of the index file
\& Returns : String
\& Args    : None
.Ve
.SS "path"
.IX Subsection "path"
.Vb 7
\& Title   : path
\& Usage   : my $path = $db\->path($path);
\& Function: When a single file or a directory of files is indexed, this returns
\&           the file directory. When indexing an arbitrary list of files, the
\&           return value is the path of the current working directory.
\& Returns : String
\& Args    : None
.Ve
.SS "get_PrimarySeq_stream"
.IX Subsection "get_PrimarySeq_stream"
.Vb 8
\& Title   : get_PrimarySeq_stream
\& Usage   : my $stream = $db\->get_PrimarySeq_stream();
\& Function: Get a SeqIO\-like stream of sequence objects. The stream supports a
\&           single method, next_seq(). Each call to next_seq() returns a new
\&           PrimarySeqI compliant sequence object, until no more sequences remain.
\&           This is a Bio::DB::SeqI method implementation.
\& Returns : A Bio::DB::Indexed::Stream object
\& Args    : None
.Ve
.SS "get_Seq_by_id"
.IX Subsection "get_Seq_by_id"
.Vb 6
\& Title   : get_Seq_by_id, get_Seq_by_acc, get_Seq_by_version, get_Seq_by_primary_id
\& Usage   : my $seq = $db\->get_Seq_by_id($id);
\& Function: Given an ID, fetch the corresponding sequence from the database.
\&           This is a Bio::DB::SeqI and Bio::DB::RandomAccessI method implementation.
\& Returns : A sequence object
\& Args    : ID
.Ve
.SS "_calculate_offsets"
.IX Subsection "_calculate_offsets"
.Vb 7
\& Title   : _calculate_offsets
\& Usage   : $db\->_calculate_offsets($filename, $offsets);
\& Function: This method calculates the sequence offsets in a file based on ID and
\&           should be implemented by classes that use Bio::DB::IndexedBase.
\& Returns : Hash of offsets
\& Args    : File to process
\&           Hashref of file offsets keyed by IDs.
.Ve
.SS "offset"
.IX Subsection "offset"
.Vb 7
\& Title   : offset
\& Usage   : my $offset = $db\->offset($id);
\& Function: Get the offset of the indicated sequence from the beginning of the
\&           file in which it is located. The offset points to the beginning of
\&           the sequence, not the beginning of the header line.
\& Returns : String
\& Args    : ID of sequence
.Ve
.SS "strlen"
.IX Subsection "strlen"
.Vb 5
\& Title   : strlen
\& Usage   : my $length = $db\->strlen($id);
\& Function: Get the number of characters in the sequence string.
\& Returns : Integer
\& Args    : ID of sequence
.Ve
.SS "length"
.IX Subsection "length"
.Vb 5
\& Title   : length
\& Usage   : my $length = $db\->length($id);
\& Function: Get the number of residues of the sequence.
\& Returns : Integer
\& Args    : ID of sequence
.Ve
.SS "linelen"
.IX Subsection "linelen"
.Vb 5
\& Title   : linelen
\& Usage   : my $linelen = $db\->linelen($id);
\& Function: Get the length of the line for this sequence.
\& Returns : Integer
\& Args    : ID of sequence
.Ve
.SS "headerlen"
.IX Subsection "headerlen"
.Vb 5
\& Title   : headerlen
\& Usage   : my $length = $db\->headerlen($id);
\& Function: Get the length of the header line for the indicated sequence.
\& Returns : Integer
\& Args    : ID of sequence
.Ve
.SS "header_offset"
.IX Subsection "header_offset"
.Vb 6
\& Title   : header_offset
\& Usage   : my $offset = $db\->header_offset($id);
\& Function: Get the offset of the header line for the indicated sequence from
\&           the beginning of the file in which it is located.
\& Returns : String
\& Args    : ID of sequence
.Ve
.SS "alphabet"
.IX Subsection "alphabet"
.Vb 5
\& Title   : alphabet
\& Usage   : my $alphabet = $db\->alphabet($id);
\& Function: Get the molecular type of the indicated sequence: dna, rna or protein
\& Returns : String
\& Args    : ID of sequence
.Ve
.SS "file"
.IX Subsection "file"
.Vb 6
\& Title   : file
\& Usage   : my $file = $db\->file($id);
\& Function: Get the the name of the file in which the indicated sequence can be
\&           found.
\& Returns : String
\& Args    : ID of sequence
.Ve
