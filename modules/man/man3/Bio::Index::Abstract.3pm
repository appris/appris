.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Index::Abstract 3pm"
.TH Bio::Index::Abstract 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Index::Abstract \- Abstract interface for indexing a flat file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
You should not be using this module directly
.SH "USING DB_FILE"
.IX Header "USING DB_FILE"
To use DB_File and not \s-1SDBM\s0 for this index, pass the value:
.PP
.Vb 1
\&    \-dbm_package => \*(AqDB_File\*(Aq
.Ve
.PP
to new (see below).
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object provides the basic mechanism to associate positions
in files with names. The position and filenames are stored in \s-1DBM\s0
which can then be accessed later on. It is the equivalent of flat
file indexing (eg, \s-1SRS\s0 or efetch).
.PP
This object is the guts to the mechanism, which will be used by the
specific objects inheriting from it.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Ewan Birney, James Gilbert"
.IX Header "AUTHOR - Ewan Birney, James Gilbert"
Email \- birney@sanger.ac.uk, jgrg@sanger.ac.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal
methods are usually preceded with an \*(L"_\*(R" (underscore).
.SS "new"
.IX Subsection "new"
.Vb 10
\&  Usage   : $index = Bio::Index::Abstract\->new(
\&                \-filename    => $dbm_file,
\&                \-write_flag  => 0,
\&                \-dbm_package => \*(AqDB_File\*(Aq,
\&                \-verbose     => 0);
\&  Function: Returns a new index object.  If filename is
\&            specified, then open_dbm() is immediately called.
\&            Bio::Index::Abstract\->new() will usually be called
\&            directly only when opening an existing index.
\&  Returns : A new index object
\&  Args    : \-filename    The name of the dbm index file.
\&            \-write_flag  TRUE if write access to the dbm file is
\&                         needed.
\&            \-dbm_package The Perl dbm module to use for the
\&                         index.
\&            \-verbose     Print debugging output to STDERR if
\&                         TRUE.
.Ve
.SS "filename"
.IX Subsection "filename"
.Vb 7
\& Title   : filename
\& Usage   : $value = $self\->filename();
\&           $self\->filename($value);
\& Function: Gets or sets the name of the dbm index file.
\& Returns : The current value of filename
\& Args    : Value of filename if setting, or none if
\&           getting the value.
.Ve
.SS "write_flag"
.IX Subsection "write_flag"
.Vb 9
\& Title   : write_flag
\& Usage   : $value = $self\->write_flag();
\&           $self\->write_flag($value);
\& Function: Gets or sets the value of write_flag, which
\&           is whether the dbm file should be opened with
\&           write access.
\& Returns : The current value of write_flag (default 0)
\& Args    : Value of write_flag if setting, or none if
\&           getting the value.
.Ve
.SS "dbm_package"
.IX Subsection "dbm_package"
.Vb 2
\& Usage   : $value = $self\->dbm_package();
\&           $self\->dbm_package($value);
\&
\& Function: Gets or sets the name of the Perl dbm module used.
\&           If the value is unset, then it returns the value of
\&           the package variable $USE_DBM_TYPE or if that is
\&           unset, then it chooses the best available dbm type,
\&           choosing \*(AqDB_File\*(Aq in preference to \*(AqSDBM_File\*(Aq.
\&           Bio::Abstract::Index may work with other dbm file
\&           types.
\&
\& Returns : The current value of dbm_package
\& Args    : Value of dbm_package if setting, or none if
\&           getting the value.
.Ve
.SS "db"
.IX Subsection "db"
.Vb 10
\&  Title   : db
\&  Usage   : $index\->db
\&  Function: Returns a ref to the hash which is tied to the dbm
\&            file.  Used internally when adding and retrieving
\&            data from the database.
\&  Example : $db = $index\->db();
\&            $db\->{ $some_key } = $data
\&            $data = $index\->db\->{ $some_key };
\&  Returns : ref to HASH
\&  Args    : NONE
.Ve
.SS "get_stream"
.IX Subsection "get_stream"
.Vb 4
\& Title   : get_stream
\& Usage   : $stream = $index\->get_stream( $id );
\& Function: Returns a file handle with the file pointer
\&           at the approprite place
\&
\&           This provides for a way to get the actual
\&           file contents and not an object
\&
\&           WARNING: you must parse the record deliminter
\&           *yourself*. Abstract won\*(Aqt do this for you
\&           So this code
\&
\&           $fh = $index\->get_stream($myid);
\&           while( <$fh> ) {
\&              # do something
\&           }
\&           will parse the entire file if you don\*(Aqt put in
\&           a last statement in, like
\&
\&           while( <$fh> ) {
\&              /^\e/\e// && last; # end of record
\&              # do something
\&           }
\&
\& Returns : A filehandle object
\& Args    : string represents the accession number
\& Notes   : This method should not be used without forethought
.Ve
.SS "cachesize"
.IX Subsection "cachesize"
.Vb 5
\&  Usage   : $index\->cachesize(1000000)
\&  Function: Sets the dbm file cache size for the index.
\&            Needs to be set before the DBM file gets opened.
\&  Example : $index\->cachesize(1000000)
\&  Returns : size of the curent cache
.Ve
.SS "ffactor"
.IX Subsection "ffactor"
.Vb 3
\&  Usage   : $index\->ffactor(1000000)
\&  Function: Sets the dbm file fill factor.
\&                        Needs to be set before the DBM file gets opened.
\&
\&  Example : $index\->ffactor(1000000)
\&  Returns : size of the curent cache
.Ve
.SS "open_dbm"
.IX Subsection "open_dbm"
.Vb 8
\&  Usage   : $index\->open_dbm()
\&  Function: Opens the dbm file associated with the index
\&            object.  Write access is only given if explicitly
\&            asked for by calling new(\-write => 1) or having set
\&            the write_flag(1) on the index object.  The type of
\&            dbm file opened is that returned by dbm_package().
\&            The name of the file to be is opened is obtained by
\&            calling the filename() method.
\&
\&  Example : $index\->_open_dbm()
\&  Returns : 1 on success
.Ve
.SS "_version"
.IX Subsection "_version"
.Vb 9
\&  Title   : _version
\&  Usage   : $type = $index\->_version()
\&  Function: Returns a string which identifes the version of an
\&            index module.  Used to permanently identify an index
\&            file as having been created by a particular version
\&            of the index module.  Must be provided by the sub class
\&  Example :
\&  Returns :
\&  Args    : none
.Ve
.SS "_code_base"
.IX Subsection "_code_base"
.Vb 6
\& Title   : _code_base
\& Usage   : $code = $db\->_code_base();
\& Function:
\& Example :
\& Returns : Code package to be used with this
\& Args    :
.Ve
.SS "_type_and_version"
.IX Subsection "_type_and_version"
.Vb 9
\&  Title   : _type_and_version
\&  Usage   : Called by _initalize
\&  Function: Checks that the index opened is made by the same index
\&            module and version of that module that made it.  If the
\&            index is empty, then it adds the information to the
\&            database.
\&  Example :
\&  Returns : 1 or exception
\&  Args    : none
.Ve
.SS "_check_file_sizes"
.IX Subsection "_check_file_sizes"
.Vb 9
\&  Title   : _check_file_sizes
\&  Usage   : $index\->_check_file_sizes()
\&  Function: Verifies that the files listed in the database
\&            are the same size as when the database was built,
\&            or throws an exception.  Called by the new()
\&            function.
\&  Example :
\&  Returns : 1 or exception
\&  Args    :
.Ve
.SS "make_index"
.IX Subsection "make_index"
.Vb 11
\&  Title   : make_index
\&  Usage   : $index\->make_index( FILE_LIST )
\&  Function: Takes a list of file names, checks that they are
\&            all fully qualified, and then calls _filename() on
\&            each.  It supplies _filename() with the name of the
\&            file, and an integer which is stored with each record
\&            created by _filename().  Can be called multiple times,
\&            and can be used to add to an existing index file.
\&  Example : $index\->make_index( \*(Aq/home/seqs1\*(Aq, \*(Aq/home/seqs2\*(Aq, \*(Aq/nfs/pub/big_db\*(Aq );
\&  Returns : Number of files indexed
\&  Args    : LIST OF FILES
.Ve
.SS "pathtype"
.IX Subsection "pathtype"
.Vb 10
\&  Title   : pathtype
\&  Usage   : $index\->pathtype($pathtype)
\&  Function: Set the type of the file path
\&            Only two values are supported, \*(Aqrelative\*(Aq or \*(Aqabsolute\*(Aq.
\&            If the user does not give any value, it is set to
\&            absolute by default. Thus it mimics the default
\&            behavior of Bio::Index::Abstract module.
\&  Example : my $index = Bio::Index::Abstract\->(\-pathtype => \*(Aqrelative\*(Aq,
\&                                               \-file     => $file.inx,
\&                                              );
\&            or
\&            $index\->pathtype(\*(Aqrelative\*(Aq);
\&  Returns : Type of the path.
\&  Args    : String (relative|absolute)
.Ve
.SS "_filename"
.IX Subsection "_filename"
.Vb 6
\&  Title   : _filename
\&  Usage   : $index\->_filename( FILE INT )
\&  Function: Indexes the file
\&  Example :
\&  Returns :
\&  Args    :
.Ve
.SS "_file_handle"
.IX Subsection "_file_handle"
.Vb 10
\&  Title   : _file_handle
\&  Usage   : $fh = $index\->_file_handle( INT )
\&  Function: Returns an open filehandle for the file
\&            index INT.  On opening a new filehandle it
\&            caches it in the @{$index\->_filehandle} array.
\&            If the requested filehandle is already open,
\&            it simply returns it from the array.
\&  Example : $first_file_indexed = $index\->_file_handle( 0 );
\&  Returns : ref to a filehandle
\&  Args    : INT
.Ve
.SS "_file_count"
.IX Subsection "_file_count"
.Vb 9
\&  Title   : _file_count
\&  Usage   : $index\->_file_count( INT )
\&  Function: Used by the index building sub in a sub class to
\&            track the number of files indexed.  Sets or gets
\&            the number of files indexed when called with or
\&            without an argument.
\&  Example :
\&  Returns : INT
\&  Args    : INT
.Ve
.SS "add_record"
.IX Subsection "add_record"
.Vb 10
\&  Title   : add_record
\&  Usage   : $index\->add_record( $id, @stuff );
\&  Function: Calls pack_record on @stuff, and adds the result
\&            of pack_record to the index database under key $id.
\&            If $id is a reference to an array, then a new entry
\&            is added under a key corresponding to each element
\&            of the array.
\&  Example : $index\->add_record( $id, $fileNumber, $begin, $end )
\&  Returns : TRUE on success or FALSE on failure
\&  Args    : ID LIST
.Ve
.SS "pack_record"
.IX Subsection "pack_record"
.Vb 8
\&  Title   : pack_record
\&  Usage   : $packed_string = $index\->pack_record( LIST )
\&  Function: Packs an array of scalars into a single string
\&            joined by ASCII 034 (which is unlikely to be used
\&            in any of the strings), and returns it.
\&  Example : $packed_string = $index\->pack_record( $fileNumber, $begin, $end )
\&  Returns : STRING or undef
\&  Args    : LIST
.Ve
.SS "unpack_record"
.IX Subsection "unpack_record"
.Vb 7
\&  Title   : unpack_record
\&  Usage   : $index\->unpack_record( STRING )
\&  Function: Splits the sting provided into an array,
\&            splitting on ASCII 034.
\&  Example : ( $fileNumber, $begin, $end ) = $index\->unpack_record( $self\->db\->{$id} )
\&  Returns : A 3 element ARRAY
\&  Args    : STRING containing ASCII 034
.Ve
.SS "count_records"
.IX Subsection "count_records"
.Vb 6
\& Title   : count_records
\& Usage   : $recs = $seqdb\->count_records()
\& Function: return count of all recs in the index
\& Example :
\& Returns : a scalar
\& Args    : none
.Ve
.SS "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
.Vb 6
\& Title   : DESTROY
\& Usage   : Called automatically when index goes out of scope
\& Function: Closes connection to database and handles to
\&           sequence files
\& Returns : NEVER
\& Args    : NONE
.Ve
