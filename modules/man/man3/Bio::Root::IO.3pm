.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Root::IO 3pm"
.TH Bio::Root::IO 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Root::IO \- BioPerl base IO handling class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    # Use stream I/O in your module
\&    $self\->{\*(Aqio\*(Aq} = Bio::Root::IO\->new(\-file => "myfile");
\&    $self\->{\*(Aqio\*(Aq}\->_print("some stuff");
\&    my $line = $self\->{\*(Aqio\*(Aq}\->_readline();
\&    $self\->{\*(Aqio\*(Aq}\->_pushback($line);
\&    $self\->{\*(Aqio\*(Aq}\->close();
\&
\&    # obtain platform\-compatible filenames
\&    $path = Bio::Root::IO\->catfile($dir, $subdir, $filename);
\&    # obtain a temporary file (created in $TEMPDIR)
\&    ($handle) = $io\->tempfile();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides methods that will usually be needed for any sort
of file\- or stream-related input/output, e.g., keeping track of a file
handle, transient printing and reading from the file handle, a close
method, automatically closing the handle on garbage collection, etc.
.PP
To use this for your own code you will either want to inherit from
this module, or instantiate an object for every file or stream you are
dealing with. In the first case this module will most likely not be
the first class off which your class inherits; therefore you need to
call \fB_initialize_io()\fR with the named parameters in order to set file
handle, open file, etc automatically.
.PP
Most methods start with an underscore, indicating they are private. In
\&\s-1OO\s0 speak, they are not private but protected, that is, use them in
your module code, but a client code of your module will usually not
want to call them (except those not starting with an underscore).
.PP
In addition this module contains a couple of convenience methods for
cross-platform safe tempfile creation and similar tasks. There are
some \s-1CPAN\s0 modules related that may not be available on all
platforms. At present, File::Spec and File::Temp are attempted. This
module defines \f(CW$PATHSEP\fR, \f(CW$TEMPDIR\fR, and \f(CW$ROOTDIR\fR, which will always be set,
and \f(CW$OPENFLAGS\fR, which will be set if either of File::Spec or File::Temp fails.
.PP
The \-noclose boolean (accessed via the noclose method) prevents a
filehandle from being closed when the \s-1IO\s0 object is cleaned up.  This
is special behavior when a object like a parser might share a
filehandle with an object like an indexer where it is not proper to
close the filehandle as it will continue to be reused until the end of the
stream is reached.  In general you won't want to play with this flag.
.SH "AUTHOR Hilmar Lapp"
.IX Header "AUTHOR Hilmar Lapp"
.SS "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : my $io = Bio::Root::IO\->new( \-file => \*(Aqdata.txt\*(Aq );
\& Function: Create new class instance. It automatically calls C<_initialize_io>.
\& Args    : Same named parameters as C<_initialize_io>.
\& Returns : A Bio::Root::IO object
.Ve
.SS "_initialize_io"
.IX Subsection "_initialize_io"
.Vb 10
\& Title   : _initialize_io
\& Usage   : $io\->_initialize_io(@params);
\& Function: Initializes filehandle and other properties from the parameters.
\& Args    : The following named parameters are currently recognized:
\&              \-file     name of file to read or write to
\&              \-fh       file handle to read or write to (mutually exclusive
\&                        with \-file and \-string)
\&              \-input    name of file, or filehandle (GLOB or IO::Handle object)
\&                        to read of write to
\&              \-string   string to read from (will be converted to filehandle)
\&              \-url      name of URL to open
\&              \-flush    boolean flag to autoflush after each write
\&              \-noclose  boolean flag, when set to true will not close a
\&                        filehandle (must explicitly call close($io\->_fh)
\&              \-retries  number of times to try a web fetch before failure
\&              \-ua_parms when using \-url, hashref of key => value parameters
\&                        to pass to LWP::UserAgent\->new(). A useful value might
\&                        be, for example, {timeout => 60 } (ua defaults to 180s)
\& Returns : True
.Ve
.SS "_fh"
.IX Subsection "_fh"
.Vb 5
\& Title   : _fh
\& Usage   : $io\->_fh($newval);
\& Function: Get or set the file handle for the stream encapsulated.
\& Args    : Optional filehandle to use
\& Returns : Filehandle for the stream
.Ve
.SS "mode"
.IX Subsection "mode"
.Vb 12
\& Title   : mode
\& Usage   : $io\->mode();
\&           $io\->mode(\-force => 1);
\& Function: Determine if the object was opened for reading or writing
\& Args    : \-force: Boolean. Once mode() has been called, the mode is cached for
\&                   further calls to mode(). Use this argument to override this
\&                   behavior and re\-check the object\*(Aqs mode.
\& Returns : Mode of the object:
\&            \*(Aqr\*(Aq  for readable
\&            \*(Aqw\*(Aq  for writable
\&            \*(Aqrw\*(Aq for readable and writable
\&            \*(Aq?\*(Aq  if mode could not be determined (e.g. for a \-url)
.Ve
.SS "file"
.IX Subsection "file"
.Vb 7
\& Title   : file
\& Usage   : $io\->file(\*(Aq>\*(Aq.$file);
\&           my $file = $io\->file;
\& Function: Get or set the name of the file to read or write.
\& Args    : Optional file name (including its mode, e.g. \*(Aq<\*(Aq for reading or \*(Aq>\*(Aq
\&           for writing)
\& Returns : A string representing the filename and its mode.
.Ve
.SS "cleanfile"
.IX Subsection "cleanfile"
.Vb 6
\& Title   : cleanfile
\& Usage   : my ($mode, $file) = $io\->cleanfile;
\& Function: Get the name of the file to read or write, stripped of its mode
\&           (\*(Aq>\*(Aq, \*(Aq<\*(Aq, \*(Aq+>\*(Aq, \*(Aq>>\*(Aq, etc).
\& Args    : None
\& Returns : In array context, an array of the mode and the clean filename.
.Ve
.SS "format"
.IX Subsection "format"
.Vb 6
\& Title   : format
\& Usage   : $io\->format($newval)
\& Function: Get the format of a Bio::Root::IO sequence file or filehandle. Every
\&           object inheriting Bio::Root::IO is guaranteed to have a format.
\& Args    : None
\& Returns : Format of the file or filehandle, e.g. fasta, fastq, genbank, embl.
.Ve
.SS "variant"
.IX Subsection "variant"
.Vb 10
\& Title   : format
\& Usage   : $io\->format($newval)
\& Function: Get the variant of a Bio::Root::IO sequence file or filehandle.
\&           The format variant depends on the specific format used. Note that
\&           not all formats have variants. Also, the Bio::Root::IO\-implementing
\&           modules that require access to variants need to define a global hash
\&           that has the allowed variants as its keys.
\& Args    : None
\& Returns : Variant of the file or filehandle, e.g. sanger, solexa or illumina for
\&           the fastq format, or undef for formats that do not have variants.
.Ve
.SS "_print"
.IX Subsection "_print"
.Vb 5
\& Title   : _print
\& Usage   : $io\->_print(@lines)
\& Function: Print lines of text to the IO stream object.
\& Args    : List of strings to print
\& Returns : True on success, undef on failure
.Ve
.SS "_insert"
.IX Subsection "_insert"
.Vb 6
\& Title   : _insert
\& Usage   : $io\->_insert($string,1)
\& Function: Insert some text in a file at the given line number (1\-based).
\& Args    : * string to write in file
\&           * line number to insert the string at
\& Returns : True
.Ve
.SS "_readline"
.IX Subsection "_readline"
.Vb 6
\& Title   : _readline
\& Usage   : local $Bio::Root::IO::HAS_EOL = 1;
\&           my $io = Bio::Root::IO\->new(\-file => \*(Aqdata.txt\*(Aq);
\&           my $line = $io\->_readline();
\&           $io\->close;
\& Function: Read a line of input and normalize all end of line characters.
\&
\&           End of line characters are typically "\en" on Linux platforms, "\er\en"
\&           on Windows and "\er" on older Mac OS. By default, the _readline()
\&           method uses the value of $/, Perl\*(Aqs input record separator, to
\&           detect the end of each line. This means that you will not get the
\&           expected lines if your input has Mac\-formatted end of line characters.
\&           Also, note that the current implementation does not handle pushed
\&           back input correctly unless the pushed back input ends with the
\&           value of $/. For each line parsed, its line ending, e.g. "\er\en" is
\&           converted to "\en", unless you provide the \-raw argument.
\&
\&           Altogether it is easier to let the PerlIO::eol module automatically
\&           detect the proper end of line character and normalize it to "\en". Do
\&           so by setting $Bio::Root::IO::HAS_EOL to 1.
\&
\& Args    : \-raw : Avoid converting end of line characters to "\en" This option
\&                  has no effect when using $Bio::Root::IO::HAS_EOL = 1.
\& Returns : Line of input, or undef when there is nothing to read anymore
.Ve
.SS "_pushback"
.IX Subsection "_pushback"
.Vb 4
\& Title   : _pushback
\& Usage   : $io\->_pushback($newvalue)
\& Function: Puts a line previously read with _readline back into a buffer.
\&           buffer can hold as many lines as system memory permits.
\&
\&           Note that this is only supported for pushing back data ending with
\&           the current, localized value of $/. Using this method to push
\&           modified data back onto the buffer stack is not supported; see bug
\&           843.
\&
\& Args    : newvalue
\& Returns : True
.Ve
.SS "close"
.IX Subsection "close"
.Vb 6
\& Title   : close
\& Usage   : $io\->close()
\& Function: Closes the file handle associated with this IO instance,
\&           excepted if \-noclose was specified.
\& Args    : None
\& Returns : True
.Ve
.SS "flush"
.IX Subsection "flush"
.Vb 5
\& Title   : flush
\& Usage   : $io\->flush()
\& Function: Flushes the filehandle
\& Args    : None
\& Returns : True
.Ve
.SS "noclose"
.IX Subsection "noclose"
.Vb 7
\& Title   : noclose
\& Usage   : $io\->noclose($newval)
\& Function: Get or set the NOCLOSE flag \- setting this to true will prevent a
\&           filehandle from being closed when an object is cleaned up or
\&           explicitly closed.
\& Args    : Optional new value (a scalar or undef)
\& Returns : Value of noclose (a scalar)
.Ve
.SS "_io_cleanup"
.IX Subsection "_io_cleanup"
.SS "exists_exe"
.IX Subsection "exists_exe"
.Vb 11
\& Title   : exists_exe
\& Usage   : $exists = $io\->exists_exe(\*(Aqclustalw\*(Aq);
\&           $exists = Bio::Root::IO\->exists_exe(\*(Aqclustalw\*(Aq)
\&           $exists = Bio::Root::IO::exists_exe(\*(Aqclustalw\*(Aq)
\& Function: Determines whether the given executable exists either as file
\&           or within the path environment. The latter requires File::Spec
\&           to be installed.
\&           On Win32\-based system, .exe is automatically appended to the program
\&           name unless the program name already ends in .exe.
\& Args    : Name of the executable
\& Returns : 1 if the given program is callable as an executable, and 0 otherwise
.Ve
.SS "tempfile"
.IX Subsection "tempfile"
.Vb 10
\& Title   : tempfile
\& Usage   : my ($handle,$tempfile) = $io\->tempfile();
\& Function: Create a temporary filename and a handle opened for reading and
\&           writing.
\&           Caveats: If you do not have File::Temp on your system you should
\&           avoid specifying TEMPLATE and SUFFIX.
\& Args    : Named parameters compatible with File::Temp: DIR (defaults to
\&           $Bio::Root::IO::TEMPDIR), TEMPLATE, SUFFIX.
\& Returns : A 2\-element array, consisting of temporary handle and temporary
\&           file name.
.Ve
.SS "tempdir"
.IX Subsection "tempdir"
.Vb 3
\& Title   : tempdir
\& Usage   : my ($tempdir) = $io\->tempdir(CLEANUP=>1);
\& Function: Creates and returns the name of a new temporary directory.
\&
\&           Note that you should not use this function for obtaining "the"
\&           temp directory. Use $Bio::Root::IO::TEMPDIR for that. Calling this
\&           method will in fact create a new directory.
\&
\& Args    : args \- ( key CLEANUP ) indicates whether or not to cleanup
\&           dir on object destruction, other keys as specified by File::Temp
\& Returns : The name of a new temporary directory.
.Ve
.SS "catfile"
.IX Subsection "catfile"
.Vb 3
\& Title   : catfile
\& Usage   : $path = Bio::Root::IO\->catfile(@dirs, $filename);
\& Function: Constructs a full pathname in a cross\-platform safe way.
\&
\&           If File::Spec exists on your system, this routine will merely
\&           delegate to it. Otherwise it tries to make a good guess.
\&
\&           You should use this method whenever you construct a path name
\&           from directory and filename. Otherwise you risk cross\-platform
\&           compatibility of your code.
\&
\&           You can call this method both as a class and an instance method.
\&
\& Args    : components of the pathname (directories and filename, NOT an
\&           extension)
\& Returns : a string
.Ve
.SS "rmtree"
.IX Subsection "rmtree"
.Vb 3
\& Title   : rmtree
\& Usage   : Bio::Root::IO\->rmtree($dirname );
\& Function: Remove a full directory tree
\&
\&           If File::Path exists on your system, this routine will merely
\&           delegate to it. Otherwise it runs a local version of that code.
\&
\&           You should use this method to remove directories which contain
\&           files.
\&
\&           You can call this method both as a class and an instance method.
\&
\& Args    : roots \- rootdir to delete or reference to list of dirs
\&
\&           verbose \- a boolean value, which if TRUE will cause
\&                     C<rmtree> to print a message each time it
\&                     examines a file, giving the name of the file, and
\&                     indicating whether it\*(Aqs using C<rmdir> or
\&                     C<unlink> to remove it, or that it\*(Aqs skipping it.
\&                     (defaults to FALSE)
\&
\&           safe \- a boolean value, which if TRUE will cause C<rmtree>
\&                  to skip any files to which you do not have delete
\&                  access (if running under VMS) or write access (if
\&                  running under another OS).  This will change in the
\&                  future when a criterion for \*(Aqdelete permission\*(Aq
\&                  under OSs other than VMS is settled.  (defaults to
\&                  FALSE)
\& Returns : number of files successfully deleted
.Ve
.SS "_flush_on_write"
.IX Subsection "_flush_on_write"
.Vb 7
\& Title   : _flush_on_write
\& Usage   : $io\->_flush_on_write($newval)
\& Function: Boolean flag to indicate whether to flush
\&           the filehandle on writing when the end of
\&           a component is finished (Sequences, Alignments, etc)
\& Args    : Optional new value
\& Returns : Value of _flush_on_write
.Ve
.SS "save_tempfiles"
.IX Subsection "save_tempfiles"
.Vb 5
\& Title   : save_tempfiles
\& Usage   : $io\->save_tempfiles(1)
\& Function: Boolean flag to indicate whether to retain tempfiles/tempdir
\& Args    : Value evaluating to TRUE or FALSE
\& Returns : Boolean value : 1 = save tempfiles/tempdirs, 0 = remove (default)
.Ve
