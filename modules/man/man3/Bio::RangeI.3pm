.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::RangeI 3pm"
.TH Bio::RangeI 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::RangeI \- Range interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #Do not run this module directly
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This provides a standard BioPerl range interface that should be
implemented by any object that wants to be treated as a range. This
serves purely as an abstract base class for implementers and can not
be instantiated.
.PP
Ranges are modeled as having (start, end, length, strand). They use
Bio-coordinates \- all points >= start and <= end are within the
range. End is always greater-than or equal-to start, and length is
greater than or equal to 1. The behaviour of a range is undefined if
ranges with negative numbers or zero are used.
.PP
So, in summary:
.PP
.Vb 3
\&  length = end \- start + 1
\&  end >= start
\&  strand = (\-1 | 0 | +1)
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Heikki Lehvaslaiho"
.IX Header "AUTHOR - Heikki Lehvaslaiho"
Email:  heikki-at-bioperl-dot-org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Juha Muilu (muilu@ebi.ac.uk)
Sendu Bala (bix@sendu.me.uk)
Malcolm Cook (mec@stowers\-institute.org)
Stephen Montgomery (sm8 at sanger.ac.uk)
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SH "Abstract methods"
.IX Header "Abstract methods"
These methods must be implemented in all subclasses.
.SS "start"
.IX Subsection "start"
.Vb 6
\&  Title   : start
\&  Usage   : $start = $range\->start();
\&  Function: get/set the start of this range
\&  Returns : the start of this range
\&  Args    : optionally allows the start to be set
\&            using $range\->start($start)
.Ve
.SS "end"
.IX Subsection "end"
.Vb 6
\&  Title   : end
\&  Usage   : $end = $range\->end();
\&  Function: get/set the end of this range
\&  Returns : the end of this range
\&  Args    : optionally allows the end to be set
\&            using $range\->end($end)
.Ve
.SS "length"
.IX Subsection "length"
.Vb 6
\&  Title   : length
\&  Usage   : $length = $range\->length();
\&  Function: get/set the length of this range
\&  Returns : the length of this range
\&  Args    : optionally allows the length to be set
\&             using $range\->length($length)
.Ve
.SS "strand"
.IX Subsection "strand"
.Vb 6
\&  Title   : strand
\&  Usage   : $strand = $range\->strand();
\&  Function: get/set the strand of this range
\&  Returns : the strandedness (\-1, 0, +1)
\&  Args    : optionally allows the strand to be set
\&            using $range\->strand($strand)
.Ve
.SH "Boolean Methods"
.IX Header "Boolean Methods"
These methods return true or false. They throw an error if start and
end are not defined.
.PP
.Vb 1
\&  $range\->overlaps($otherRange) && print "Ranges overlap\en";
.Ve
.SS "overlaps"
.IX Subsection "overlaps"
.Vb 6
\&  Title   : overlaps
\&  Usage   : if($r1\->overlaps($r2)) { do stuff }
\&  Function: tests if $r2 overlaps $r1
\&  Args    : arg #1 = a range to compare this one to (mandatory)
\&            arg #2 = optional strand\-testing arg (\*(Aqstrong\*(Aq, \*(Aqweak\*(Aq, \*(Aqignore\*(Aq)
\&  Returns : true if the ranges overlap, false otherwise
.Ve
.SS "contains"
.IX Subsection "contains"
.Vb 7
\&  Title   : contains
\&  Usage   : if($r1\->contains($r2) { do stuff }
\&  Function: tests whether $r1 totally contains $r2
\&  Args    : arg #1 = a range to compare this one to (mandatory)
\&                     alternatively, integer scalar to test
\&            arg #2 = optional strand\-testing arg (\*(Aqstrong\*(Aq, \*(Aqweak\*(Aq, \*(Aqignore\*(Aq)
\&  Returns : true if the argument is totally contained within this range
.Ve
.SS "equals"
.IX Subsection "equals"
.Vb 6
\&  Title   : equals
\&  Usage   : if($r1\->equals($r2))
\&  Function: test whether $r1 has the same start, end, length as $r2
\&  Args    : arg #1 = a range to compare this one to (mandatory)
\&            arg #2 = optional strand\-testing arg (\*(Aqstrong\*(Aq, \*(Aqweak\*(Aq, \*(Aqignore\*(Aq)
\&  Returns : true if they are describing the same range
.Ve
.SH "Geometrical methods"
.IX Header "Geometrical methods"
These methods do things to the geometry of ranges, and return
Bio::RangeI compliant objects or triplets (start, stop, strand) from
which new ranges could be built.
.SS "intersection"
.IX Subsection "intersection"
.Vb 10
\& Title   : intersection
\& Usage   : ($start, $end, $strand) = $r1\->intersection($r2); OR
\&           ($start, $end, $strand) = Bio::Range\->intersection(\e@ranges); OR
\&           my $containing_range = $r1\->intersection($r2); OR
\&           my $containing_range = Bio::Range\->intersection(\e@ranges);
\& Function: gives the range that is contained by all ranges
\& Returns : undef if they do not overlap or if @ranges has only a
\&           single range, else returns the range that they do
\&           overlap. In scalar contex, the return value is an object of
\&           the same class as the calling one. In array context the
\&           return value is a three element array.
\& Args    : arg #1 = [REQUIRED] a Bio::RangeI to compare this one to,
\&                    or an array ref of ranges
\&           arg #2 = optional strand\-testing arg (\*(Aqstrong\*(Aq, \*(Aqweak\*(Aq, \*(Aqignore\*(Aq)
.Ve
.SS "union"
.IX Subsection "union"
.Vb 6
\&   Title   : union
\&    Usage   : ($start, $end, $strand) = $r1\->union($r2);
\&            : ($start, $end, $strand) = Bio::Range\->union(@ranges);
\&              my $newrange = Bio::Range\->union(@ranges);
\&    Function: finds the minimal Range that contains all of the Ranges
\&    Args    : a Range or list of Range objects
\&
\&    Returns : the range containing all of the range. In scalar contex,
\&              the return value is an object of the same class as the
\&              calling one. In array context the return value is a
\&              three element array.
.Ve
.SS "overlap_extent"
.IX Subsection "overlap_extent"
.Vb 9
\& Title   : overlap_extent
\& Usage   : ($a_unique,$common,$b_unique) = $a\->overlap_extent($b)
\& Function: Provides actual amount of overlap between two different
\&           ranges
\& Example :
\& Returns : array of values containing the length unique to the calling
\&           range, the length common to both, and the length unique to
\&           the argument range
\& Args    : a range
.Ve
.SS "disconnected_ranges"
.IX Subsection "disconnected_ranges"
.Vb 8
\&    Title   : disconnected_ranges
\&    Usage   : my @disc_ranges = Bio::Range\->disconnected_ranges(@ranges);
\&    Function: finds the minimal set of ranges such that each input range
\&              is fully contained by at least one output range, and none of
\&              the output ranges overlap
\&    Args    : a list of ranges
\&    Returns : a list of objects of the same type as the input
\&              (conforms to RangeI)
.Ve
.SS "offsetStranded"
.IX Subsection "offsetStranded"
.Vb 7
\&    Title    : offsetStranded
\&    Usage    : $rnge\->ofsetStranded($fiveprime_offset, $threeprime_offset)
\&    Function : destructively modifies RangeI implementing object to
\&               offset its start and stop coordinates by values $fiveprime_offset and
\&               $threeprime_offset (positive values being in the strand direction).
\&    Args     : two integer offsets: $fiveprime_offset and $threeprime_offset
\&    Returns  : $self, offset accordingly.
.Ve
.SS "subtract"
.IX Subsection "subtract"
.Vb 9
\&  Title   : subtract
\&  Usage   : my @subtracted = $r1\->subtract($r2)
\&  Function: Subtract range r2 from range r1
\&  Args    : arg #1 = a range to subtract from this one (mandatory)
\&            arg #2 = strand option (\*(Aqstrong\*(Aq, \*(Aqweak\*(Aq, \*(Aqignore\*(Aq) (optional)
\&  Returns : undef if they do not overlap or r2 contains this RangeI,
\&            or an arrayref of Range objects (this is an array since some
\&            instances where the subtract range is enclosed within this range
\&            will result in the creation of two new disjoint ranges)
.Ve
