.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Factory::SequenceProcessorI 3pm"
.TH Bio::Factory::SequenceProcessorI 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Factory::SequenceProcessorI \- Interface for chained sequence 
                                   processing algorithms
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Bio::SeqIO;
\&    use MySeqProcessor; # is\-a Bio::Factory::SequenceProcessorI
\&
\&    # obtain your source stream, e.g., an EMBL file
\&    my $seqin = Bio::SeqIO\->new(\-fh => \e*STDIN, \-format => \*(Aqembl\*(Aq);
\&    # create your processor (it must implement this interface)
\&    my $seqalgo = MySeqProcessor\->new();
\&    # chain together
\&    $seqalgo\->source_stream($seqin);
\&    # you could create more processors and chain them one after another
\&    # ...
\&    # finally, the last link in the chain is your SeqIO stream
\&    my $seqpipe = $seqalgo;
\&
\&    # once you\*(Aqve established the pipeline, proceed as if you had a
\&    # single SeqIO stream
\&    while(my $seq = $seqpipe\->next_seq()) {
\&        # ... do something ...
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This defines an interface that allows seamless chaining of sequence
processing algorithms encapsulated in modules while retaining the
overall Bio::SeqIO interface at the end of the pipeline.
.PP
This is especially useful if you want an easily configurable
processing pipeline of re-usable algorithms as building blocks instead
of (hard\-)coding the whole algorithm in a single script.
.PP
There are literally no restrictions as to what an individual module
can do with a sequence object it obtains from the source stream before
it makes it available through its own \fBnext_seq()\fR method. It can
manipulate the sequence object, but otherwise keep it intact, but it
can also create any number of new sequence objects from it, or it can
discard some, or any combination thereof. The only requirement is that
its \fBnext_seq()\fR method return Bio::PrimarySeqI compliant objects. In
order to play nice, if a processor creates new objects it should try
to use the same sequence factory that the source stream uses, but this
is not strongly mandated.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp at gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "source_stream"
.IX Subsection "source_stream"
.Vb 4
\& Title   : source_stream
\& Usage   : $obj\->source_stream($newval)
\& Function: Get/set the source sequence stream for this sequence
\&           processor.
\&
\&           An implementation is not required to allow set, but will
\&           usually do so.
\&
\& Example : 
\& Returns : A Bio::Factory::SequenceStreamI compliant object
\& Args    : on set, new value (a Bio::Factory::SequenceStreamI compliant
\&           object)
.Ve
.SH "Bio::Factory::SequenceStreamI methods"
.IX Header "Bio::Factory::SequenceStreamI methods"
.Vb 8
\& The requirement to implement these methods is inherited from
\& L<Bio::Factory::SequenceStreamI>. An implementation may not
\& necessarily have to implement all methods in a meaningful way. Which
\& methods will be necessary very much depends on the context in which
\& an implementation of this interface is used. E.g., if it is only used
\& for post\-processing sequences read from a SeqIO stream, write_seq()
\& will not be used and hence does not need to be implemented in a
\& meaningful way (it may in fact even throw an exception).
\&
\& Also, since an implementor will already receive built objects from a
\& sequence stream, sequence_factory() may or may not be relevant,
\& depending on whether the processing method does or does not involve
\& creating new objects.
.Ve
.SS "next_seq"
.IX Subsection "next_seq"
.Vb 3
\& Title   : next_seq
\& Usage   : $seq = stream\->next_seq
\& Function: Reads the next sequence object from the stream and returns it.
\&
\&           In the case of a non\-recoverable situation an exception
\&           will be thrown.  Do not assume that you can resume parsing
\&           the same stream after catching the exception. Note that you
\&           can always turn recoverable errors into exceptions by
\&           calling $stream\->verbose(2).
\&
\& Returns : a Bio::Seq sequence object
\& Args    : none
.Ve
.PP
See Bio::Root::RootI
.SS "write_seq"
.IX Subsection "write_seq"
.Vb 5
\& Title   : write_seq
\& Usage   : $stream\->write_seq($seq)
\& Function: writes the $seq object into the stream
\& Returns : 1 for success and 0 for error
\& Args    : Bio::Seq object
.Ve
.SS "sequence_factory"
.IX Subsection "sequence_factory"
.Vb 5
\& Title   : sequence_factory
\& Usage   : $seqio\->sequence_factory($seqfactory)
\& Function: Get the Bio::Factory::SequenceFactoryI
\& Returns : Bio::Factory::SequenceFactoryI
\& Args    : none
.Ve
