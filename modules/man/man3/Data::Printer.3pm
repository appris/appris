.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Data::Printer 3pm"
.TH Data::Printer 3pm "2021-03-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Printer \- colored & full\-featured pretty print of Perl data structures and objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Want to see what's inside a variable in a complete, colored and human-friendly way?
.PP
.Vb 1
\&    use DDP;  # same as \*(Aquse Data::Printer\*(Aq
\&
\&    p $some_var;
\&    p $some_var, as => "This label will be printed too!";
\&
\&    # no need to use \*(Aq\e\*(Aq before arrays or hashes!
\&    p @array;
\&    p %hash;
\&
\&    # for anonymous array/hash references, use postderef (on perl 5.24 or later):
\&    p [ $one, $two, $three ]\->@*;
\&    p { foo => $foo, bar => $bar }\->%*;
\&
\&    # or deref the anonymous ref:
\&    p @{[ $one, $two, $three ]};
\&    p %{{ foo => $foo, bar => $bar }};
\&
\&    # or put \*(Aq&\*(Aq in front of the call:
\&    &p( [ $one, $two, $three ] );
\&    &p( { foo => $foo, bar => $bar } );
.Ve
.PP
The snippets above will print the contents of the chosen variables to \s-1STDERR\s0
on your terminal, with colors and a few extra features to help you debug
your code.
.PP
If you wish to grab the output and handle it yourself, call \f(CW\*(C`np()\*(C'\fR:
.PP
.Vb 1
\&    my $dump = np $var;
\&
\&    die "this is what happened: " . np %data;
.Ve
.PP
The \f(CW\*(C`np()\*(C'\fR function is the same as \f(CW\*(C`p()\*(C'\fR but will return the string
containing the dump. By default it has no colors, but you can change that
easily too.
.PP
That's pretty much it :)
.PP
Data::Printer is fully customizable, even
on a per-module basis! Once you figure out your own preferences, create a
\&.dataprinter configuration file
for yourself (or one for each project) and Data::Printer will automatically
use it!
.SH "FEATURES"
.IX Header "FEATURES"
Here's what Data::Printer offers Perl developers, out of the box:
.IP "\(bu" 4
Variable dumps designed for \fIeasy parsing by the human brain\fR,
not a machine.
.IP "\(bu" 4
\&\fBHighly customizable\fR, from indentation size to depth level.
You can even rename the exported \f(CW\*(C`p()\*(C'\fR function!
.IP "\(bu" 4
\&\fBBeautiful (and customizable) colors\fR to highlight variable dumps
and make issues stand-out quickly on your console. Comes bundled with
several themes for you to pick that work on light
and dark terminal backgrounds, and you can create your own as well.
.IP "\(bu" 4
\&\fBFilters for specific data structures and objects\fR to make
debugging much, much easier. Includes filters for many popular classes
from \s-1CPAN\s0 like JSON::*, \s-1URI,\s0 HTTP::*, \s-1LWP,\s0 Digest::*, \s-1DBI\s0 and DBIx::Class.
printing what really matters to developers debugging code. It also lets you
create your own custom filters easily.
.IP "\(bu" 4
Lets you \fBinspect information that's otherwise difficult to find/debug\fR
in Perl 5, like circular references, reference counting (refcount),
weak/read\-only information, overloaded operators, tainted data, ties,
dual vars, even estimated data size \- all to help you spot issues with your
data like leaks without having to know a lot about internal data structures
or install hardcore tools like Devel::Peek and Devel::Gladiator.
.IP "\(bu" 4
keep your custom settings on a
\&.dataprinter file that allows
\&\fBdifferent options per module\fR being analyzed! You may also create a
custom profile class with your preferences and
filters and upload it to \s-1CPAN.\s0
.IP "\(bu" 4
\&\fBoutput to many different targets\fR like files, variables or open
handles (defaults to \s-1STDERR\s0). You can send your dumps to the screen
or anywhere else, and customize this setting on a per-project or even
per-module basis, like print everything from Some::Module to a debug.log
file with extra info, and everything else to \s-1STDERR.\s0
.IP "\(bu" 4
\&\fBEasy to learn, easy to master\fR. Seriously, the synopsis above
and the customization section below cover about 90% of all use cases.
.IP "\(bu" 4
Works on \fBPerl 5.8 and later\fR. Because you can't control where
you debug, we try our best to be compatible with all versions of Perl 5.
.IP "\(bu" 4
Best of all? All that with \fBNo non-core dependencies\fR,
Zero. Nada. So don't worry about adding extra weight to your project, as
Data::Printer can be easily added/removed.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The ever-popular Data::Dumper is a fantastic tool, meant to stringify
data structures in a way they are suitable for being \*(L"eval\*(R"'ed back in.
The thing is, a lot of people keep using it (and similar ones, like
Data::Dump) to print data structures and objects on screen for inspection
and debugging, and while you \fIcan\fR use those modules for that, it doesn't
mean you \fIshould\fR.
.PP
This is where Data::Printer comes in. It is meant to do one thing and one
thing only:
.PP
\&\fIformat Perl variables and objects to be inspected by a human\fR
.PP
If you want to serialize/store/restore Perl data structures, this module
will \s-1NOT\s0 help you. Try Storable, Data::Dumper, \s-1JSON,\s0 or whatever. \s-1CPAN\s0 is
full of such solutions!
.PP
Whenever you type \f(CW\*(C`use Data::Printer\*(C'\fR or \f(CW\*(C`use DDP\*(C'\fR, we export two functions
to your namespace:
.SS "p()"
.IX Subsection "p()"
This function pretty-prints the contents of whatever variable to \s-1STDERR\s0
(by default), and will use colors by default if your terminal supports it.
.PP
.Vb 3
\&    p @some_array;
\&    p %some_hash;
\&    p $scalar_or_ref;
.Ve
.PP
Note that anonymous structures will only work if you postderef them:
.PP
.Vb 1
\&    p [$foo, $bar, $baz]\->@*;
.Ve
.PP
you may also deref it manually:
.PP
.Vb 1
\&    p %{{ foo => $foo }};
.Ve
.PP
or prefix \f(CW\*(C`p()\*(C'\fR with \f(CW\*(C`&\*(C'\fR:
.PP
.Vb 1
\&    &p( [$foo, $bar, $baz] );    # & (note mandatory parenthesis)
.Ve
.PP
You can pass custom options that will work only on that particular call:
.PP
.Vb 2
\&    p @var, as => "some label", colorized => 0;
\&    p %var, show_memsize => 1;
.Ve
.PP
By default, \f(CW\*(C`p()\*(C'\fR prints to \s-1STDERR\s0 and returns the same variable being
dumped. This lets you quickly wrap variables with \f(CW\*(C`p()\*(C'\fR without worrying
about changing return values. It means that if you change this:
.PP
.Vb 1
\&    sub foo { my $x = shift + 13; $x }
.Ve
.PP
to this:
.PP
.Vb 1
\&    sub foo { my $x = shift + 13; p($x) }
.Ve
.PP
The function will still return \f(CW$x\fR after printing the contents. This form
of handling data even allows method chaining, so if you want to inspect what's
going on in the middle of this:
.PP
.Vb 1
\&    $object\->foo\->bar\->baz;
.Ve
.PP
You can just add \f(CW\*(C`DDP::p\*(C'\fR anywhere:
.PP
.Vb 1
\&    $object\->foo\->DDP::p\->bar\->baz; # what happens to $object after \->foo?
.Ve
.PP
Check out the customization quick reference
section below for all available options, including changing the return type,
output target and a lot more.
.SS "\fBnp()\fP"
.IX Subsection "np()"
The \f(CW\*(C`np()\*(C'\fR function behaves exactly like \f(CW\*(C`p()\*(C'\fR except it always returns
the string containing the dump (thus ignoring any setting regarding dump
mode or destination), and contains no colors by default. In fact, the only
way to force a colored \f(CW\*(C`np()\*(C'\fR is to pass \f(CW\*(C`colored => 1\*(C'\fR as an argument
to each call. It is meant to provide an easy way to fetch the dump and send
it to some unsupported target, or appended to some other text (like part of
a log message).
.SH "CUSTOMIZATION"
.IX Header "CUSTOMIZATION"
There are 3 possible ways to customize Data::Printer:
.PP
1. \fB[\s-1RECOMMENDED\s0]\fR Creating a \f(CW\*(C`.dataprinter\*(C'\fR file either on your home
directory or your project's base directory, or both,  or wherever you set
the \f(CW\*(C`DATAPRINTERRC\*(C'\fR environment variable to.
.PP
2. Setting custom properties on module load. This will override any
setting from your config file on the namespace (package/module) it was called:
.PP
.Vb 1
\&    use DDP max_depth => 2, deparse => 1;
.Ve
.PP
3. Setting custom properties on the actual call to \f(CW\*(C`p()\*(C'\fR or \f(CW\*(C`np()\*(C'\fR. This
overrides all other settings:
.PP
.Vb 1
\&    p $var, show_tainted => 1, indent => 2;
.Ve
.SS "The .dataprinter configuration file"
.IX Subsection "The .dataprinter configuration file"
The most powerful way to customize Data::Printer is to have a \f(CW\*(C`.dataprinter\*(C'\fR
file in your home directory or your project's root directory. The format
is super simple and can be understood in the example below:
.PP
.Vb 4
\&    # global settings (note that only full line comments are accepted)
\&    max_depth       = 1
\&    theme           = Monokai
\&    class.stringify = 0
\&
\&    # use quotes if you want spaces to be significant:
\&    hash_separator  = " => "
\&
\&    # You can set rules that apply only to a specific
\&    # caller module (in this case, MyApp::Some::Module):
\&    [MyApp::Some::Module]
\&    max_depth    = 2
\&    class.expand = 0
\&    escape_chars = nonlatin1
\&
\&    [MyApp::Other::Module]
\&    multiline = 0
\&    output    = /var/log/myapp/debug.data
.Ve
.PP
Note that if you set custom properties as arguments to \f(CW\*(C`p()\*(C'\fR or \f(CW\*(C`np()\*(C'\fR, you
should group suboptions as a hashref. So while the \f(CW\*(C`.dataprinter\*(C'\fR file has
"\f(CW\*(C`class.expand = 0\*(C'\fR\*(L" and \*(R"\f(CW\*(C`class.inherited = none\*(C'\fR\*(L", the equivalent
code is \*(R"\f(CW\*(C`class => { expand => 0, inherited => \*(Aqnone\*(Aq }\*(C'\fR".
.SS "Properties Quick Reference"
.IX Subsection "Properties Quick Reference"
Below are (almost) all available properties and their (hopefully sane)
default values. See Data::Printer::Object for further information on
each of them:
.PP
.Vb 11
\&    # scalar options
\&    show_tainted      = 1
\&    show_unicode      = 1
\&    show_lvalue       = 1
\&    print_escapes     = 0
\&    scalar_quotes     = "
\&    escape_chars      = none
\&    string_max        = 4096
\&    string_preserve   = begin
\&    string_overflow   = \*(Aq(...skipping _\|_SKIPPED_\|_ chars...)\*(Aq
\&    unicode_charnames = 0
\&
\&    # array options
\&    array_max      = 100
\&    array_preserve = begin
\&    array_overflow = \*(Aq(...skipping _\|_SKIPPED_\|_ items...)\*(Aq
\&    index          = 1
\&
\&    # hash options
\&    hash_max       = 100
\&    hash_preserve  = begin
\&    hash_overflow  = \*(Aq(...skipping _\|_SKIPPED_\|_ keys...)\*(Aq
\&    hash_separator = \*(Aq   \*(Aq
\&    align_hash     = 1
\&    sort_keys      = 1
\&    quote_keys     = auto
\&
\&    # general options
\&    name           = var
\&    return_value   = pass
\&    output         = stderr
\&    use_prototypes = 1
\&    indent         = 4
\&    show_readonly  = 1
\&    show_tied      = 1
\&    show_dualvar   = lax
\&    show_weak      = 1
\&    show_refcount  = 0
\&    show_memsize   = 0
\&    memsize_unit   = auto
\&    separator      = ,
\&    end_separator  = 0
\&    caller_info    = 0
\&    caller_message = \*(AqPrinting in line _\|_LINE_\|_ of _\|_FILENAME_\|_\*(Aq
\&    max_depth      = 0
\&    deparse        = 0
\&    alias          = p
\&    warnings       = 1
\&
\&    # colorization (see Colors & Themes below)
\&    colored = auto
\&    theme   = Material
\&
\&    # object output
\&    class_method             = _data_printer
\&    class.parents            = 1
\&    class.linear_isa         = auto
\&    class.universal          = 1
\&    class.expand             = 1
\&    class.stringify          = 1
\&    class.show_reftype       = 0
\&    class.show_overloads     = 1
\&    class.show_methods       = all
\&    class.sort_methods       = 1
\&    class.inherited          = none
\&    class.format_inheritance = string
\&    class.parent_filters     = 1
\&    class.internals          = 1
.Ve
.PP
\fISettings' shortcuts\fR
.IX Subsection "Settings' shortcuts"
.IP "\(bu" 4
\&\fBas\fR \- prints a string before the dump. So:
.Sp
.Vb 1
\&    p $some_var, as => \*(Aqhere!\*(Aq;
.Ve
.Sp
is a shortcut to:
.Sp
.Vb 1
\&    p $some_var, caller_info => 1, caller_message => \*(Aqhere!\*(Aq;
.Ve
.IP "\(bu" 4
\&\fBmultiline\fR \- lets you create shorter dumps. By setting it to 0,
we use a single space as linebreak and disable the array index. Setting it
to 1 (the default) goes back to using \*(L"\en\*(R" as linebreak and restore whatever
array index you had originally.
.IP "\(bu" 4
\&\fBfulldump\fR \- when set to 1, disables all max string/hash/array
values. Use this to generate complete (full) dumps of all your content,
which is trimmed by default.
.SS "Colors & Themes"
.IX Subsection "Colors & Themes"
Data::Printer lets you set custom colors for pretty much every part of the
content being printed. For example, if you want numbers to be shown in
bright green, just put \f(CW\*(C`colors.number = #00ff00\*(C'\fR on your configuration
file.
.PP
See Data::Printer::Theme for the full list of labels, ways to represent
and customize colors, and even how to group them in your own custom theme.
.PP
The colorization is set by the \f(CW\*(C`colored\*(C'\fR property. It can be set to 0
(never colorize), 1 (always colorize) or 'auto' (the default), which will
colorize \f(CW\*(C`p()\*(C'\fR only when there is no \f(CW\*(C`ANSI_COLORS_DISABLED\*(C'\fR environment
variable, the output is going to the terminal (\s-1STDOUT\s0 or \s-1STDERR\s0) and your
terminal actually supports colors.
.SS "Profiles"
.IX Subsection "Profiles"
You may bundle your settings and filters into a profile module.
It works like a configuration file but gives you the power and flexibility
to use Perl code to find out what to print and how to print. It also lets
you use \s-1CPAN\s0 to store your preferred settings and install them into your
projects just like a regular dependency.
.PP
.Vb 1
\&    use DDP profile => \*(AqProfileName\*(Aq;
.Ve
.PP
See Data::Printer::Profile for all the ways to load a profile, a list
of available profiles and how to make one yourself.
.SS "Filters"
.IX Subsection "Filters"
Data::Printer works by passing your variable to a different set of filters,
depending on whether it's a scalar, a hash, an array, an object, etc. It
comes bundled with filters for all native data types (always enabled, but
overwritable), including a generic object filter that pretty-prints regular
and Moo(se) objects and is even aware of Role::Tiny.
.PP
Data::Printer also comes with filter bundles that can be quickly activated
to make it easier to debug binary data
and many popular \s-1CPAN\s0 modules that handle
date and time,
databases (yes, even DBIx::Class),
message digests like \s-1MD5\s0 and \s-1SHA1,\s0 and
\&\s-1JSON\s0 and Web content like \s-1HTTP\s0 requests and
responses.
.PP
So much so we recommend everyone to activate all bundled filters by putting
the following line on your \f(CW\*(C`.dataprinter\*(C'\fR file:
.PP
.Vb 1
\&    filters = ContentType, DateTime, DB, Digest, Web
.Ve
.PP
Creating your custom filters is very easy, and
you're encouraged to upload them to \s-1CPAN.\s0 There are many options available
under the \f(CW\*(C`Data::Printer::Filter::*\*(C'\fR namespace. Check
Data::Printer::Filter for more information!
.SS "Making your classes DDP-aware (without adding any dependencies!)"
.IX Subsection "Making your classes DDP-aware (without adding any dependencies!)"
The default object filter will first check if the class implements a sub
called '\f(CW\*(C`_data_printer()\*(C'\fR' (or whatever you set the \*(L"class_method\*(R" option
to in your settings). If so, Data::Printer will use it to get the string to
print instead of making a regular class dump.
.PP
This means you could have the following in one of your classes:
.PP
.Vb 4
\&  sub _data_printer {
\&      my ($self, $ddp) = @_;
\&      return \*(AqHey, no peeking! But foo contains \*(Aq . $self\->foo;
\&  }
.Ve
.PP
Notice that \fByou can do this without adding Data::Printer as a dependency\fR
to your project! Just write your sub and it will be called with the object to
be printed and a \f(CW$ddp\fR object ready for you. See
Data::Printer::Object
for how to use it to pretty-print your data.
.PP
Finally, if your object implements string overload or provides a method called
\&\*(L"to_string\*(R", \*(L"as_string\*(R" or \*(L"stringify\*(R", Data::Printer will use it. To disable
this behaviour, set \f(CW\*(C`class.stringify = 0\*(C'\fR on your \f(CW\*(C`.dataprinter\*(C'\fR
file, or call p() with \f(CW\*(C`class => { stringify => 0 }\*(C'\fR.
.PP
Loading a filter for that particular class will of course override these settings.
.SH "CAVEATS"
.IX Header "CAVEATS"
You can't pass more than one variable at a time.
.PP
.Vb 2
\&   p $foo, $bar;       # wrong
\&   p $foo; p $bar;     # right
.Ve
.PP
You can't use it in variable declarations (it will most likely not do what
you want):
.PP
.Vb 2
\&    p my @array = qw(a b c d);          # wrong
\&    my @array = qw(a b c d); p @array;  # right
.Ve
.PP
If you pass a nonexistant key/index to \s-1DDP\s0 using prototypes, they
will trigger autovivification:
.PP
.Vb 3
\&    use DDP;
\&    my %foo;
\&    p $foo{bar}; # undef, but will create the \*(Aqbar\*(Aq key (with undef)
\&
\&    my @x;
\&    p $x[5]; # undef, but will initialize the array with 5 elements (all undef)
.Ve
.PP
Slices (both array and hash) must be coerced into actual arrays (or hashes)
to properly shown. So if you want to print a slice, instead of doing something
like this:
.PP
.Vb 1
\&    p @somevar[1..10]; # WRONG! DON\*(AqT DO THIS!
.Ve
.PP
try one of those:
.PP
.Vb 3
\&    my @x = @somevar[1..10]; p @x;   # works!
\&    p [ @somevar[1..0] ]\->@*;        # also works!
\&    p @{[@somevar[1..0]]};           # this works too!!
.Ve
.PP
Finally, as mentioned before, you cannot pass anonymous references on the
default mode of \f(CW\*(C`use_prototypes = 1\*(C'\fR:
.PP
.Vb 5
\&    p { foo => 1 };       # wrong!
\&    p %{{ foo => 1 }};    # right
\&    p { foo => 1 }\->%*;   # right on perl 5.24+
\&    &p( { foo => 1 } );   # right, but requires the parenthesis
\&    sub pp { p @_ };      # wrapping it also lets you use anonymous data.
\&
\&    use DDP use_prototypes => 0;
\&    p { foo => 1 };   # works, but now p(@foo) will fail, you must always pass a ref,
\&                      # e.g. p(\e@foo)
.Ve
.SH "BACKWARDS INCOMPATIBLE CHANGES"
.IX Header "BACKWARDS INCOMPATIBLE CHANGES"
While we make a genuine effort not to break anything on new releases,
sometimes we do. To make things easier for people migrating their
code, we have aggregated here a list of all incompatible changes since ever:
.IP "\(bu" 4
1.00 \- some defaults changed!
Because we added a bunch of new features (including color themes), you may
notice some difference on the default output of Data::Printer. Hopefully it's
for the best.
.IP "\(bu" 4
1.00 \- new \f(CW\*(C`.dataprinter\*(C'\fR file format.
\&\fIThis should only affect you if you have a \f(CI\*(C`.dataprinter\*(C'\fI file.\fR
The change was required to avoid calling \f(CW\*(C`eval\*(C'\fR on potentially tainted/unknown
code. It also provided a much cleaner interface.
.IP "\(bu" 4
1.00 \- new way of creating external filters.
\&\fIThis only affects you if you write or use external filters.\fR
Previously, the sub in your \f(CW\*(C`filters\*(C'\fR call would get the reference to be
parsed and a properties hash. The properties hash has been replaced with a
Data::Printer::Object instance, providing much more power and flexibility.
Because of that, the filter call does not export \f(CW\*(C`p()\*(C'\fR/\f(CW\*(C`np()\*(C'\fR anymore,
replaced by methods in Data::Printer::Object.
.IP "\(bu" 4
1.00 \- new way to call filters.
\&\fIThis affects you if you load your own inline filters\fR.
The fix is quick and Data::Printer will generate a warning explaining how
to do it. Basically, \f(CW\*(C`filters => { ... }\*(C'\fR became
\&\f(CW\*(C`filters => [{ ... }]\*(C'\fR and you must replace \f(CW\*(C`\-external => [1,2]\*(C'\fR
with \f(CW\*(C`filters => [1, 2]\*(C'\fR, or \f(CW\*(C`filters => [1, 2, {...}]\*(C'\fR if you
also have inline filters. This allowed us much more power and flexibility
with filters, and hopefully also makes things clearer.
.IP "\(bu" 4
0.36 \- \f(CW\*(C`p()\*(C'\fR's default return value changed from 'dump' to 'pass'.
This was a very important change to ensure chained calls and to prevent
weird side-effects when \f(CW\*(C`p()\*(C'\fR is the last statement in a sub.
Read the full discussion <https://github.com/garu/Data-Printer/issues/16>.
.PP
Any undocumented change was probably unintended. If you bump into one,
please file an issue on Github!
.SH "TIPS & TRICKS"
.IX Header "TIPS & TRICKS"
.SS "Using p() in some/all of your loaded modules"
.IX Subsection "Using p() in some/all of your loaded modules"
\&\fI(contributed by Matt S. Trout (mst))\fR
.PP
While debugging your software, you may want to use Data::Printer in some or
all loaded modules and not bother having to load it in each and every one of
them. To do this, in any module loaded by \f(CW\*(C`myapp.pl\*(C'\fR, simply write:
.PP
.Vb 1
\&  ::p @myvar;  # note the \*(Aq::\*(Aq in front of p()
.Ve
.PP
Then call your program like:
.PP
.Vb 1
\&  perl \-MDDP myapp.pl
.Ve
.PP
This also has the advantage that if you leave one p() call in by accident,
it will trigger a compile-time failure without the \-M, making it easier to
spot :)
.PP
If you really want to have p() imported into your loaded modules, use the
next tip instead.
.SS "Adding p() to all your loaded modules"
.IX Subsection "Adding p() to all your loaded modules"
\&\fI(contributed by Árpád Szász)\fR
.PP
If you wish to automatically add Data::Printer's \f(CW\*(C`p()\*(C'\fR function to
every loaded module in you app, you can do something like this to
your main program:
.PP
.Vb 12
\&    BEGIN {
\&        {
\&            no strict \*(Aqrefs\*(Aq;
\&            require Data::Printer;
\&            my $alias = \*(Aqp\*(Aq;
\&            foreach my $package ( keys %main:: ) {
\&                if ( $package =~ m/::$/ ) {
\&                    *{ $package . $alias } = \e&Data::Printer::p;
\&                }
\&            }
\&        }
\&    }
.Ve
.PP
\&\fB\s-1WARNING\s0\fR This will override all locally defined subroutines/methods that
are named \f(CW\*(C`p\*(C'\fR, if they exist, in every loaded module. If you already
have a subroutine named '\f(CW\*(C`p()\*(C'\fR', be sure to change \f(CW$alias\fR to
something custom.
.PP
If you rather avoid namespace manipulation altogether, use the previous
tip instead.
.SS "Using Data::Printer from the Perl debugger"
.IX Subsection "Using Data::Printer from the Perl debugger"
\&\fI(contributed by Árpád Szász and Marcel Grünauer (hanekomu))\fR
.PP
With DB::Pluggable, you can easily set the perl debugger to use
Data::Printer to print variable information, replacing the debugger's
standard \f(CW\*(C`p()\*(C'\fR function. All you have to do is add these lines to
your \f(CW\*(C`.perldb\*(C'\fR file:
.PP
.Vb 2
\&  use DB::Pluggable;
\&  DB::Pluggable\->run_with_config( \e\*(Aq[DataPrinter]\*(Aq );  # note the \*(Aq\e\*(Aq
.Ve
.PP
Then call the perl debugger as you normally would:
.PP
.Vb 1
\&  perl \-d myapp.pl
.Ve
.PP
Now Data::Printer's \f(CW\*(C`p()\*(C'\fR command will be used instead of the debugger's!
.PP
See perldebug for more information on how to use the perl debugger, and
DB::Pluggable for extra functionality and other plugins.
.PP
If you can't or don't want to use DB::Pluggable, or simply want to keep
the debugger's \f(CW\*(C`p()\*(C'\fR function and add an extended version using
Data::Printer (let's call it \f(CW\*(C`px()\*(C'\fR for instance), you can add these
lines to your \f(CW\*(C`.perldb\*(C'\fR file instead:
.PP
.Vb 6
\&    $DB::alias{px} = \*(Aqs/px/DB::px/\*(Aq;
\&    sub px {
\&        my $expr = shift;
\&        require Data::Printer;
\&        print Data::Printer::p($expr);
\&    }
.Ve
.PP
Now, inside the Perl debugger, you can pass as reference to \f(CW\*(C`px\*(C'\fR expressions
to be dumped using Data::Printer.
.SS "Using Data::Printer in a perl shell (\s-1REPL\s0)"
.IX Subsection "Using Data::Printer in a perl shell (REPL)"
Some people really enjoy using a \s-1REPL\s0 shell to quickly try Perl code. One
of the most popular ones out there is Devel::REPL. If you use it, now
you can also see its output with Data::Printer!
.PP
Just install Devel::REPL::Plugin::DataPrinter and add the following
line to your re.pl configuration file (usually \*(L".re.pl/repl.rc\*(R" in your
home dir):
.PP
.Vb 1
\&  load_plugin(\*(AqDataPrinter\*(Aq);
.Ve
.PP
The next time you run \f(CW\*(C`re.pl\*(C'\fR, it should dump all your \s-1REPL\s0 using
Data::Printer!
.SS "Easily rendering Data::Printer's output as \s-1HTML\s0"
.IX Subsection "Easily rendering Data::Printer's output as HTML"
To turn Data::Printer's output into \s-1HTML,\s0 you can do something like:
.PP
.Vb 2
\&  use HTML::FromANSI;
\&  use Data::Printer;
\&
\&  my $html_output = ansi2html( np($object, colored => 1) );
.Ve
.PP
In the example above, the \f(CW$html_output\fR variable contains the
\&\s-1HTML\s0 escaped output of \f(CW\*(C`p($object)\*(C'\fR, so you can print it for
later inspection or render it (if it's a web app).
.SS "Using Data::Printer with Template Toolkit"
.IX Subsection "Using Data::Printer with Template Toolkit"
\&\fI(contributed by Stephen Thirlwall (sdt))\fR
.PP
If you use Template Toolkit and want to dump your variables using Data::Printer,
install the Template::Plugin::DataPrinter module and load it in your template:
.PP
.Vb 1
\&   [% USE DataPrinter %]
.Ve
.PP
The provided methods match those of \f(CW\*(C`Template::Plugin::Dumper\*(C'\fR:
.PP
.Vb 2
\&   ansi\-colored dump of the data structure in "myvar":
\&   [% DataPrinter.dump( myvar ) %]
\&
\&   html\-formatted, colored dump of the same data structure:
\&   [% DataPrinter.dump_html( myvar ) %]
.Ve
.PP
The module allows several customization options, even letting you load it as a
complete drop-in replacement for Template::Plugin::Dumper so you don't even have
to change your previous templates!
.SS "Migrating from Data::Dumper to Data::Printer"
.IX Subsection "Migrating from Data::Dumper to Data::Printer"
If you are porting your code to use Data::Printer instead of
Data::Dumper, you could replace:
.PP
.Vb 1
\&  use Data::Dumper;
.Ve
.PP
with something like:
.PP
.Vb 2
\&  use Data::Printer;
\&  sub Dumper { np @_, colored => 1 }
.Ve
.PP
this sub will accept multiple variables just like Data::Dumper.
.SS "Unified interface for Data::Printer and other debug formatters"
.IX Subsection "Unified interface for Data::Printer and other debug formatters"
\&\fI(contributed by Kevin McGrath (catlgrep))\fR
.PP
If you want a really unified approach to easily flip between debugging
outputs, use Any::Renderer and its plugins,
like Any::Renderer::Data::Printer.
.SS "Printing stack traces with arguments expanded using Data::Printer"
.IX Subsection "Printing stack traces with arguments expanded using Data::Printer"
\&\fI(contributed by Sergey Aleynikov (randir))\fR
.PP
There are times where viewing the current state of a variable is not
enough, and you want/need to see a full stack trace of a function call.
.PP
The Devel::PrettyTrace module uses Data::Printer to provide you just
that. It exports a \f(CW\*(C`bt()\*(C'\fR function that pretty-prints detailed information
on each function in your stack, making it easier to spot any issues!
.SS "Troubleshooting apps in real time without changing a single line of your code"
.IX Subsection "Troubleshooting apps in real time without changing a single line of your code"
\&\fI(contributed by Marcel Grünauer (hanekomu))\fR
.PP
dip is a dynamic instrumentation framework for troubleshooting Perl
programs, similar to DTrace <http://opensolaris.org/os/community/dtrace/>.
In a nutshell, \f(CW\*(C`dip\*(C'\fR lets you create probes for certain conditions
in your application that, once met, will perform a specific action. Since
it uses Aspect-oriented programming, it's very lightweight and you only
pay for what you use.
.PP
\&\f(CW\*(C`dip\*(C'\fR can be very useful since it allows you to debug your software
without changing a single line of your original code. And Data::Printer
comes bundled with it, so you can use the \f(CW\*(C`p()\*(C'\fR function to view your
data structures too!
.PP
.Vb 4
\&   # Print a stack trace every time the name is changed,
\&   # except when reading from the database.
\&   dip \-e \*(Aqbefore { print longmess(np $_\->{args}[1], colored => 1)
\&   if $_\->{args}[1] } call "MyObj::name" & !cflow("MyObj::read")\*(Aq myapp.pl
.Ve
.PP
You can check dip's own documentation for more information and options.
.SS "Sample output for color fine-tuning"
.IX Subsection "Sample output for color fine-tuning"
\&\fI(contributed by Yanick Champoux (yanick))\fR
.PP
The \*(L"examples/try_me.pl\*(R" file included in this distribution has a sample
dump with a complex data structure to let you quickly test color schemes.
.SH "VERSIONING AND UPDATES"
.IX Header "VERSIONING AND UPDATES"
As of 1.0.0 this module complies with \f(CW\*(C`Major.Minor.Revision\*(C'\fR versioning
scheme (SemVer), meaning backwards incompatible changes will trigger a new
major number, new features without any breaking changes trigger a new minor
number, and simple patches trigger a revision number.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Many thanks to everyone who helped design and develop this module with
patches, bug reports, wishlists, comments and tests. They are (alphabetically):
.PP
Adam Rosenstein, Alexandr Ciornii (chorny), Alexander Hartmaier (abraxxa),
Allan Whiteford, Anatoly (Snelius30), Andreas König (andk), Andy Bach,
Anthony DeRobertis, Árpád Szász, Athanasios Douitsis (aduitsis),
Baldur Kristinsson, Benct Philip Jonsson (bpj), brian d foy,
Chad Granum (exodist), Chris Prather (perigrin), Curtis Poe (Ovid),
David D Lowe (Flimm), David E. Condon (hhg7), David Golden (xdg),
David Precious (bigpresh), David Raab, David E. Wheeler (theory),
Damien Krotkine (dams), Denis Howe, dirk, Dotan Dimet, Eden Cardim (edenc),
Elliot Shank (elliotjs), Eugen Konkov (\s-1KES777\s0), Fernando Corrêa (SmokeMachine),
Fitz Elliott, Florian (fschlich), Frew Schmidt (frew), GianniGi,
Graham Knop (haarg), Graham Todd, Gregory J. Oschwald, grr, Håkon Hægland,
Iaroslav O. Kosmina (darviarush), Ivan Bessarabov (bessarabv), J Mash,
James E. Keenan (jkeenan), Jarrod Funnell (Timbus), Jay Allen (jayallen),
Jay Hannah (jhannah), jcop, Jesse Luehrs (doy), Joel Berger (jberger),
John S. Anderson (genehack), Karen Etheridge (ether),
Kartik Thakore (kthakore), Kevin Dawson (bowtie), Kevin McGrath (catlgrep),
Kip Hampton (ubu), Londran, Marcel Grünauer (hanekomu),
Marco Masetti (grubert65), Mark Fowler (Trelane), Martin J. Evans,
Matt S. Trout (mst), Maxim Vuets, Michael Conrad, Mike Doherty (doherty),
Nicolas R (atoomic),  Nigel Metheringham (nigelm), Nuba Princigalli (nuba),
Olaf Alders (oalders), Paul Evans (LeoNerd), Pedro Melo (melo),
Philippe Bruhat (BooK), Przemysław Wesołek (jest), Rebecca Turner (iarna),
Renato Cron (renatoCRON), Ricardo Signes (rjbs), Rob Hoelz (hoelzro),
Salve J. Nilsen (sjn), sawyer, Sebastian Willing (Sewi),
Sébastien Feugère (smonff), Sergey Aleynikov (randir), Slaven Rezić,
Stanislaw Pusep (syp), Stephen Thirlwall (sdt), sugyan, Tai Paul,
Tatsuhiko Miyagawa (miyagawa), Thomas Sibley (tsibley),
Tim Heaney (oylenshpeegul), Toby Inkster (tobyink), Torsten Raudssus (Getty),
Tokuhiro Matsuno (tokuhirom), trapd00r, Tsai Chung-Kuan,
Veesh Goldman (rabbiveesh), vividsnow, Wesley Dal`Col (blabos), y,
Yanick Champoux (yanick).
.PP
If I missed your name, please drop me a line!
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (C) 2011\-2021 Breno G. de Oliveira
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See <http://dev.perl.org/licenses/> for more information.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
\&\s-1BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE SOFTWARE \*(L"AS IS\*(R" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU.
SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
SERVICING, REPAIR, OR CORRECTION.\s0
.PP
\&\s-1IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE TO
YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
SOFTWARE\s0 (\s-1INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE
SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE\s0), \s-1EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\s0
