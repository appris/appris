.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::SeqIO::bsml 3pm"
.TH Bio::SeqIO::bsml 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SeqIO::bsml \- BSML sequence input/output stream
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
It is probably best not to use this object directly, but rather go
through the SeqIO handler system. To read a \s-1BSML\s0 file:
.PP
.Vb 1
\&    $stream = Bio::SeqIO\->new( \-file => $filename, \-format => \*(Aqbsml\*(Aq);
\&
\&    while ( my $bioSeqObj = $stream\->next_seq() ) {
\&        # do something with $bioSeqObj
\&    }
.Ve
.PP
To write a Seq object to the current file handle in \s-1BSML XML\s0 format:
.PP
.Vb 1
\&    $stream\->write_seq( \-seq => $seqObj);
.Ve
.PP
If instead you would like a \s-1XML::DOM\s0 object containing the \s-1BSML,\s0 use:
.PP
.Vb 1
\&    my $newXmlObject = $stream\->to_bsml( \-seq => $seqObj);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object can transform Bio::Seq objects to and from \s-1BSML\s0 (\s-1XML\s0)
flatfiles.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.
Bug reports can be submitted via the web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SS "Things Still to Do"
.IX Subsection "Things Still to Do"
.IP "\(bu" 4
The module now uses the new Collection.pm system. However,
Annotations associated with a Feature object still seem to use the
old system, so parsing with the old methods are included..
.IP "\(bu" 4
Generate Seq objects with no sequence data but an assigned
length. This appears to be an issue with Bio::Seq. It is possible
(and reasonable) to make a \s-1BSML\s0 document with features but no
sequence data.
.IP "\(bu" 4
Support \f(CW\*(C`Seq\-data\-import\*(C'\fR. Do not know how commonly this is used.
.IP "\(bu" 4
Some features are awaiting implementation in later versions of
\&\s-1BSML.\s0 These include:
.RS 4
.IP "\(bu" 4
Nested feature support
.IP "\(bu" 4
Complex feature (ie joins)
.IP "\(bu" 4
Unambiguity in strand (ie \-1,0,1, not just  'complement' )
.IP "\(bu" 4
More friendly dblink structures
.RE
.RS 4
.RE
.IP "\(bu" 4
Location.pm (or RangeI::union?) appears to have a bug when 'expand'
is used.
.IP "\(bu" 4
More intelligent hunting for sequence and feature titles? It is not
terribly clear where the most appropriate field is located, better
grepping (eg looking for a reasonable count for spaces and numbers)
may allow for titles better than \*(L"\s-1AE008041\*(R".\s0
.SH "AUTHOR \- Charles Tilford"
.IX Header "AUTHOR - Charles Tilford"
Bristol-Myers Squibb Bioinformatics
.PP
Email tilfordc@bms.com
.PP
I have developed the \s-1BSML\s0 specific code for this package, but have used
code from other SeqIO packages for much of the nuts-and-bolts. In particular
I have used code from the embl.pm module either directly or as a framework
for many of the subroutines that are common to SeqIO modules.
.SH "METHODS"
.IX Header "METHODS"
.SS "next_seq"
.IX Subsection "next_seq"
.Vb 5
\& Title   : next_seq
\& Usage   : my $bioSeqObj = $stream\->next_seq
\& Function: Retrieves the next sequence from a SeqIO::bsml stream.
\& Returns : A reference to a Bio::Seq::RichSeq object
\& Args    :
.Ve
.SS "to_bsml"
.IX Subsection "to_bsml"
.Vb 7
\& Title   : to_bsml
\& Usage   : my $domDoc = $obj\->to_bsml(@args)
\& Function: Generates an XML structure for one or more Bio::Seq objects.
\&           If $seqref is an array ref, the XML tree generated will include
\&           all the sequences in the array.
\& Returns : A reference to the XML DOM::Document object generated / modified
\& Args    : Argument array in form of \-key => val. Recognized keys:
\&
\&      \-seq A Bio::Seq reference, or an array reference of many of them
\&
\&   \-xmldoc Specifies an existing XML DOM document to add the sequences
\&           to. If included, then only data (no page formatting) will
\&           be added. If not, a new XML::DOM::Document will be made,
\&           and will be populated with both <Sequence> data, as well as
\&           <Page> display elements.
\&
\&   \-nodisp Do not generate <Display> elements, or any children
\&           thereof, even if \-xmldoc is not set.
\&
\& \-skipfeat If set to \*(Aqall\*(Aq, all <Feature>s will be skipped.  If it is
\&           a hash reference, any <Feature> with a class matching a key
\&           in the hash will be skipped \- for example, to skip \*(Aqsource\*(Aq
\&           and \*(Aqscore\*(Aq features, use:
\&
\&               \-skipfeat => { source => \*(AqY\*(Aq, score => \*(AqY\*(Aq }
\&
\& \-skiptags As above: if set to \*(Aqall\*(Aq, no tags are included, and if a
\&           hash reference, those specific tags will be ignored.
\&
\&           Skipping some or all tags and features can result in
\&           noticeable speed improvements.
\&
\&   \-nodata If true, then <Seq\-data> will not be included.  This may be
\&           useful if you just want annotations and do not care about
\&           the raw ACTG information.
\&
\&   \-return Default is \*(Aqxml\*(Aq, which will return a reference to the BSML
\&           XML object. If set to \*(Aqseq\*(Aq will return an array ref of the
\&           <Sequence> objects added (rather than the whole XML object)
\&
\&    \-close Early BSML browsers will crash if an element *could* have
\&           children but does not, and is closed as an empty element
\&           e.g. <Styles/>. If \-close is true, then such tags are given
\&           a comment child to explicitly close them e.g.  <Styles><!\-\-
\&           \-\-></Styles>. This is default true, set to "0" if you do
\&           not want this behavior.
\&
\& Examples : my $domObj = $stream\->to_bsml( \-seq => \e@fourCoolSequenceObjects,
\&                                           \-skipfeat => { source => 1 },
\&                                          );
\&
\&            # Or add sequences to an existing BSML document:
\&            $stream\->to_bsml(\-seq => \e@fourCoolSequenceObjects,
\&                             \-skipfeat => { source => 1 },
\&                             \-xmldoc => $myBsmlDocumentInProgress,  );
.Ve
.SS "write_seq"
.IX Subsection "write_seq"
.Vb 8
\& Title   : write_seq
\& Usage   : $obj\->write_seq(@args)
\& Function: Prints out an XML structure for one or more Bio::Seq objects.
\&           If $seqref is an array ref, the XML tree generated will include
\&           all the sequences in the array. This method is fairly simple,
\&           most of the processing is performed within to_bsml.
\& Returns : A reference to the XML object generated / modified
\& Args    : Argument array. Recognized keys:
\&
\&      \-seq A Bio::Seq reference, or an array reference of many of them
\&
\&           Alternatively, the method may be called simply as...
\&
\&           $obj\->write_seq( $bioseq )
\&
\&           ... if only a single argument is passed, it is assumed that
\&           it is the sequence object (can also be an array ref of
\&           many Seq objects )
\&
\&      \-printmime If true prints "Content\-type: $mimetype\en\en" at top of
\&           document, where $mimetype is the value designated by this
\&           key. For generic XML use text/xml, for BSML use text/x\-bsml
\&
\&      \-return This option will be suppressed, since the nature of this
\&           method is to print out the XML document. If you wish to
\&           retrieve the <Sequence> objects generated, use the to_bsml
\&           method directly.
.Ve
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
The following methods are used for internal processing, and should probably
not be accessed by the user.
.SS "_parse_location"
.IX Subsection "_parse_location"
.Vb 10
\& Title   : _parse_location
\& Usage   : $obj\->_parse_location($xmlDocument, $parentElem, $SeqFeatureObj)
\& Function: Adds <Interval\-loc> and <Site\-loc> children to <$parentElem> based
\&           on locations / sublocations found in $SeqFeatureObj. If
\&           sublocations exist, the original location will be ignored.
\& Returns : An array ref containing the elements added to the parent.
\&           These will have already been added to <$parentElem>
\& Args    : 0 The DOM::Document being modified
\&           1 The DOM::Element parent that you want to add to
\&           2 Reference to the Bio::SeqFeature being analyzed
.Ve
.SS "_parse_bsml_feature"
.IX Subsection "_parse_bsml_feature"
.Vb 6
\& Title   : _parse_bsml_feature
\& Usage   : $obj\->_parse_bsml_feature($xmlFeature )
\& Function: Will examine the <Feature> element provided by $xmlFeature and
\&           return a generic seq feature.
\& Returns : Bio::SeqFeature::Generic
\& Args    : 0 XML::DOM::Element <Feature> being analyzed.
.Ve
.SS "_parse_bsml_location"
.IX Subsection "_parse_bsml_location"
.Vb 6
\& Title   : _parse_bsml_location
\& Usage   : $obj\->_parse_bsml_feature( $intOrSiteLoc, $gsfObject )
\& Function: Will examine the <Interval\-loc> or <Site\-loc> element provided
\& Returns : Bio::SeqFeature::Generic
\& Args    : 0 XML::DOM::Element <Interval/Site\-loc> being analyzed.
\&           1 Optional SeqFeature::Generic to use
.Ve
.SS "_parse_reference"
.IX Subsection "_parse_reference"
.Vb 7
\& Title   : _parse_reference
\& Usage   : $obj\->_parse_reference(@args )
\& Function: Makes a new <Reference> object from a ::Reference, which is
\&           then stored in an array provide by \-refs. It will be
\&           appended to the XML tree later.
\& Returns :
\& Args    : Argument array. Recognized keys:
\&
\&      \-xml The DOM::Document being modified
\&
\&      \-refobj The Annotation::Reference Object
\&
\&      \-refs An array reference to hold the new <Reference> DOM object
\&
\&      \-id Optional. If the XML id for the \*(Aqcalling\*(Aq element is
\&           provided, it will be placed in any <Reference> refs
\&           attribute.
.Ve
.SS "_parse_annotation"
.IX Subsection "_parse_annotation"
.Vb 10
\& Title   : _parse_annotation
\& Usage   : $obj\->_parse_annotation(@args )
\& Function: Will examine any Annotations found in \-obj. Data found in
\&           ::Comment and ::DBLink structures, as well as Annotation
\&           description fields are stored in \-desc for later
\&           generation of <Attribute>s. <Reference> objects are generated
\&           from ::References, and are stored in \-refs \- these will
\&           be appended to the XML tree later.
\& Returns :
\& Args    : Argument array. Recognized keys:
\&
\&      \-xml The DOM::Document being modified
\&
\&      \-obj Reference to the Bio object being analyzed
\&
\&      \-descr An array reference for holding description text items
\&
\&      \-refs An array reference to hold <Reference> DOM objects
\&
\&      \-id Optional. If the XML id for the \*(Aqcalling\*(Aq element is
\&           provided, it will be placed in any <Reference> refs
\&           attribute.
.Ve
.SS "_parse_annotation_old"
.IX Subsection "_parse_annotation_old"
.Vb 7
\&    Title   : _parse_annotation_old
\& Usage   : $obj\->_parse_annotation_old(@args)
\& Function: As above, but for the old Annotation system.
\&           Apparently needed because Features are still using the old\-style
\&           annotations?
\& Returns :
\& Args    : Argument array. Recognized keys:
\&
\&      \-xml The DOM::Document being modified
\&
\&      \-obj Reference to the Bio object being analyzed
\&
\&      \-descr An array reference for holding description text items
\&
\&      \-refs An array reference to hold <Reference> DOM objects
\&
\&      \-id Optional. If the XML id for the \*(Aqcalling\*(Aq element is
\&           provided, it will be placed in any <Reference> refs
\&           attribute.
.Ve
.SS "_add_page"
.IX Subsection "_add_page"
.Vb 6
\& Title   : _add_page
\& Usage   : $obj\->_add_page($xmlDocument, $xmlSequenceObject)
\& Function: Adds a simple <Page> and <View> structure for a <Sequence>
\& Returns : a reference to the newly created <Page>
\& Args    : 0 The DOM::Document being modified
\&           1 Reference to the <Sequence> object
.Ve
.SS "_addel"
.IX Subsection "_addel"
.Vb 9
\& Title   : _addel
\& Usage   : $obj\->_addel($parentElem, \*(AqChildName\*(Aq,
\&                        { anAttr => \*(AqsomeValue\*(Aq, anotherAttr => \*(AqaValue\*(Aq,})
\& Function: Add an element with attribute values to a DOM tree
\& Returns : a reference to the newly added element
\& Args    : 0 The DOM::Element parent that you want to add to
\&           1 The name of the new child element
\&           2 Optional hash reference containing
\&             attribute name => attribute value assignments
.Ve
.SS "_show_dna"
.IX Subsection "_show_dna"
.Vb 5
\& Title   : _show_dna
\& Usage   : $obj\->_show_dna($newval)
\& Function: (cut\-and\-pasted directly from embl.pm)
\& Returns : value of _show_dna
\& Args    : newvalue (optional)
.Ve
.SS "_initialize"
.IX Subsection "_initialize"
.Vb 6
\& Title   : _initialize
\& Usage   : $dom = $obj\->_initialize(@args)
\& Function: Coppied from embl.pm, and augmented with initialization of the
\&           XML DOM tree
\& Returns :
\& Args    : \-file => the XML file to be parsed
.Ve
.SS "_parseparams"
.IX Subsection "_parseparams"
.Vb 9
\& Title   : _parseparams
\& Usage   : my $paramHash = $obj\->_parseparams(@args)
\& Function: Borrowed from Bio::Parse.pm, who borrowed it from CGI.pm
\&           Lincoln Stein \-> Richard Resnick \-> here
\& Returns : A hash reference of the parameter keys (uppercase) pointing to
\&           their values.
\& Args    : An array of key, value pairs. Easiest to pass values as:
\&           \-key1 => value1, \-key2 => value2, etc
\&           Leading "\-" are removed.
.Ve
.SS "_parse_xml"
.IX Subsection "_parse_xml"
.Vb 5
\& Title   : _parse_xml
\& Usage   : $dom = $obj\->_parse_xml($filename)
\& Function: uses XML::DOM to construct a DOM tree from the BSML document
\& Returns : a reference to the parsed DOM tree
\& Args    : 0 Path to the XML file needing to be parsed
.Ve
.SH "TESTING SCRIPT"
.IX Header "TESTING SCRIPT"
The following script may be used to test the conversion process. You
will need a file of the format you wish to test. The script will
convert the file to \s-1BSML,\s0 store it in /tmp/bsmltemp, read that file
into a new SeqIO stream, and write it back as the original
format. Comparison of this second file to the original input file
will allow you to track where data may be lost or corrupted. Note
that you will need to specify \f(CW$readfile\fR and \f(CW$readformat\fR.
.PP
.Vb 6
\& use Bio::SeqIO;
\& # Tests preservation of details during round\-trip conversion:
\& # $readformat \-> BSML \-> $readformat
\& my $tempspot = "/tmp/bsmltemp";  # temp folder to hold generated files
\& my $readfile = "rps4y.embl";     # The name of the file you want to test
\& my $readformat = "embl";         # The format of the file being tested
\&
\& system "mkdir $tempspot" unless (\-d $tempspot);
\& # Make Seq object from the $readfile
\& my $biostream = Bio::SeqIO\->new( \-file => "$readfile" );
\& my $seq = $biostream\->next_seq();
\&
\& # Write BSML from SeqObject
\& my $bsmlout = Bio::SeqIO\->new(\-format => \*(Aqbsml\*(Aq,
\&                               \-file => ">$tempspot/out.bsml");
\& warn "\enBSML written to $tempspot/out.bsml\en";
\& $bsmlout\->write_seq($seq);
\& # Need to kill object for following code to work... Why is this so?
\& $bsmlout = "";
\&
\& # Make Seq object from BSML
\& my $bsmlin = Bio::SeqIO\->new(\-file => "$tempspot/out.bsml",
\&                              \-format => \*(Aqbsml\*(Aq);
\& my $seq2 = $bsmlin\->next_seq();
\&
\& # Write format back from Seq Object
\& my $genout = Bio::SeqIO\->new(\-format => $readformat,
\&                              \-file => ">$tempspot/out.$readformat");
\& $genout\->write_seq($seq2);
\& warn "$readformat  written to $tempspot/out.$readformat\en";
\&
\& # BEING LOST:
\& # Join information (not possible in BSML 2.2)
\& # Sequence type (??)
.Ve
