.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Tools::AnalysisResult 3pm"
.TH Bio::Tools::AnalysisResult 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::AnalysisResult \- Base class for analysis result objects and parsers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # obtain a AnalysisResult derived object somehow
\&
\&    print "Method ", $result\->analysis_method(),
\&          ", version ", $result\->analysis_method_version(),
\&          ", performed on ", $result\->analysis_date(), "\en";
\&
\&    # annotate a sequence utilizing SeqAnalysisParserI methods
\&    while($feat = $result\->next_feature()) {
\&        $seq\->add_SeqFeature($feat);
\&    }
\&    $result\->close();
\&
\&    # query object, e.g. a Bio::SeqI implementing object
\&    $queryseq = $result\->analysis_query();
\&
\&    # Subject of the analysis \-\- may be undefined. Refer to derived module
\&    # to find out what is returned.
\&    $subject = $result\->analysis_subject();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The AnalysisResult module is supposed to be the base class for modules
encapsulating parsers and interpreters for the result of a analysis
that was carried out with a query sequence.
.PP
The notion of an analysis represented by this base class is that of a
unary or binary operator, taking either one query or a query and a
subject and producing a result. The query is e.g. a sequence, and a
subject is either a sequence, too, or a database of sequences.
.PP
This module also implements the Bio::SeqAnalysisParserI interface, and
thus can be used wherever such an object fits.  See
Bio::SeqAnalysisParserI.  Developers will
find a ready-to-use \fB\fBparse()\fB\fR method, but need to implement
\&\fB\fBnext_feature()\fB\fR in an inheriting class. Support for initialization
with input file names and reading from streams is also ready to use.
.PP
Note that this module does not provide support for \fBrunning\fR an
analysis.  Rather, it is positioned in the subsequent parsing step
(concerned with turning raw results into BioPerl objects).
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp\-at\-gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "_initialize_state"
.IX Subsection "_initialize_state"
.Vb 4
\& Title   : _initialize_state
\& Usage   : n/a; usually called by _initialize()
\& Function: This method is for BioPerl B<developers> only, as indicated by the
\&           leading underscore in its name.
\&
\&           Performs initialization or reset of the state of this object. The
\&           difference to _initialize() is that it may be called at any time,
\&           and repeatedly within the lifetime of this object. B<Note>, however,
\&           that this is potentially dangerous in a multi\-threading
\&           environment. In general, calling this method twice is discouraged
\&           for this reason.
\&
\&           This method is supposed to reset the state such that any \*(Aqhistory\*(Aq
\&           is lost. State information that does not change during object
\&           lifetime is not considered as history, e.g. parent, name, etc shall
\&           not be reset. An inheriting object should only be concerned with
\&           state information it introduces itself, and for everything else
\&           call SUPER::_initialize_state(@args).
\&
\&           An example is parsing an input file: a state reset implies
\&           discarding any unread input, and the actual input itself, followed
\&           by setting the new input.
\&
\&           The argument syntax is the same as for L<new()|new> and L<_initialize()|_initialize>,
\&           i.e., named parameters following the \-name=>$value convention.
\&           The following parameters are dealt with by the implementation
\&           provided here:
\&              \-INPUT, \-FH, \-FILE
\&           (tags are case\-insensitive).
\& Example :
\& Returns :
\& Args    :
.Ve
.SS "analysis_query"
.IX Subsection "analysis_query"
.Vb 6
\& Usage     : $query_obj = $result\->analysis_query();
\& Purpose   : Set/Get the name of the query used to generate the result, that
\&             is, the entity on which the analysis was performed. Will mostly
\&             be a sequence object (Bio::PrimarySeq compatible).
\& Argument  :
\& Returns   : The object set before. Mostly a Bio::PrimarySeq compatible object.
.Ve
.SS "analysis_subject"
.IX Subsection "analysis_subject"
.Vb 8
\& Usage     : $result\->analyis_subject();
\& Purpose   : Set/Get the subject of the analysis against which it was
\&             performed. For similarity searches it will probably be a database,
\&             and for sequence feature predictions (exons, promoters, etc) it
\&             may be a collection of models or homologous sequences that were
\&             used, or undefined.
\& Returns   : The object that was set before, or undef.
\& Argument  :
.Ve
.SS "analysis_date"
.IX Subsection "analysis_date"
.Vb 5
\& Usage     : $result\->analysis_date();
\& Purpose   : Set/Get the date on which the analysis was performed.
\& Returns   : String
\& Argument  :
\& Comments  :
.Ve
.SS "analysis_method"
.IX Subsection "analysis_method"
.Vb 6
\& Usage     : $result\->analysis_method();
\& Purpose   : Set/Get the name of the sequence analysis method that was used
\&             to produce this result (BLASTP, FASTA, etc.). May also be the
\&             actual name of a program.
\& Returns   : String
\& Argument  : n/a
.Ve
.SS "analysis_method_version"
.IX Subsection "analysis_method_version"
.Vb 5
\& Usage     : $result\->analysis_method_version();
\& Purpose   : Set/Get the version string of the analysis program.
\&           : (e.g., 1.4.9MP, 2.0a19MP\-WashU).
\& Returns   : String
\& Argument  : n/a
.Ve
