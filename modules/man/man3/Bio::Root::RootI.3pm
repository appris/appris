.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Root::RootI 3pm"
.TH Bio::Root::RootI 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Root::RootI \- base interface for all BioPerl classes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # any bioperl or bioperl compliant object is a RootI
\&  # compliant object
\&
\&  $obj\->throw("This is an exception");
\&
\&  eval {
\&      $obj\->throw("This is catching an exception");
\&  };
\&
\&  if( $@ ) {
\&      print "Caught exception";
\&  } else {
\&      print "no exception";
\&  }
\&
\&  # Using throw_not_implemented() within a RootI\-based interface module:
\&
\&  package Foo;
\&  use base qw(Bio::Root::RootI);
\&
\&  sub foo {
\&      my $self = shift;
\&      $self\->throw_not_implemented;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is just a set of methods which do not assume \fBanything\fR about the object
they are on. The methods provide the ability to throw exceptions with nice
stack traces.
.PP
This is what should be inherited by all Bioperl compliant interfaces, even
if they are exotic XS/CORBA/Other perl systems.
.SS "Using \fBthrow_not_implemented()\fP"
.IX Subsection "Using throw_not_implemented()"
The method \fBthrow_not_implemented()\fR should be
called by all methods within interface modules that extend RootI so
that if an implementation fails to override them, an exception will be
thrown.
.PP
For example, say there is an interface module called \f(CW\*(C`FooI\*(C'\fR that
provides a method called \f(CW\*(C`foo()\*(C'\fR. Since this method is considered
abstract within FooI and should be implemented by any module claiming to
implement \f(CW\*(C`FooI\*(C'\fR, the \f(CW\*(C`FooI::foo()\*(C'\fR method should consist of the
following:
.PP
.Vb 4
\&    sub foo {
\&        my $self = shift;
\&        $self\->throw_not_implemented;
\&    }
.Ve
.PP
So, if an implementer of \f(CW\*(C`FooI\*(C'\fR forgets to implement \f(CW\*(C`foo()\*(C'\fR
and a user of the implementation calls \f(CW\*(C`foo()\*(C'\fR, a
Bio::Exception::NotImplemented exception will result.
.PP
Unfortunately, failure to implement a method can only be determined at
run time (i.e., you can't verify that an implementation is complete by
running \f(CW\*(C`perl \-wc\*(C'\fR on it). So it should be standard practice for a test
of an implementation to check each method and verify that it doesn't
throw a Bio::Exception::NotImplemented.
.SH "AUTHOR Steve Chervitz"
.IX Header "AUTHOR Steve Chervitz"
Ewan Birney, Lincoln Stein, Steve Chervitz, Sendu Bala, Jason Stajich
.SS "new"
.IX Subsection "new"
.SS "throw"
.IX Subsection "throw"
.Vb 6
\& Title   : throw
\& Usage   : $obj\->throw("throwing exception message")
\& Function: Throws an exception, which, if not caught with an eval brace
\&           will provide a nice stack trace to STDERR with the message
\& Returns : nothing
\& Args    : A string giving a descriptive error message
.Ve
.SS "warn"
.IX Subsection "warn"
.Vb 10
\& Title   : warn
\& Usage   : $object\->warn("Warning message");
\& Function: Places a warning. What happens now is down to the
\&           verbosity of the object  (value of $obj\->verbose)
\&            verbosity 0 or not set => small warning
\&            verbosity \-1 => no warning
\&            verbosity 1 => warning with stack trace
\&            verbosity 2 => converts warnings into throw
\& Returns : n/a
\& Args    : string (the warning message)
.Ve
.SS "deprecated"
.IX Subsection "deprecated"
.Vb 11
\& Title   : deprecated
\& Usage   : $obj\->deprecated("Method X is deprecated");
\&           $obj\->deprecated("Method X is deprecated", 1.007);
\&           $obj\->deprecated(\-message => "Method X is deprecated");
\&           $obj\->deprecated(\-message => "Method X is deprecated",
\&                            \-version => 1.007);
\& Function: Prints a message about deprecation unless verbose is < 0
\&           (which means be quiet)
\& Returns : none
\& Args    : Message string to print to STDERR
\&           Version of BioPerl where use of the method results in an exception
\&
\& Notes   : This is deprecated.  Use Carp::carp to warn about a
\&           deprecated method.  Just remove the method when it comes to
\&           error.  If you really want to throw an error insyead of
\&           removing, use Carp::croak.
\&
\&           The irony of deprecating deprecated() is not lost on us.
\&           We hope you also find it more funny that frustrating.
.Ve
.SS "stack_trace_dump"
.IX Subsection "stack_trace_dump"
.Vb 6
\& Title   : stack_trace_dump
\& Usage   :
\& Function:
\& Example :
\& Returns :
\& Args    :
.Ve
.SS "stack_trace"
.IX Subsection "stack_trace"
.Vb 6
\& Title   : stack_trace
\& Usage   : @stack_array_ref= $self\->stack_trace
\& Function: gives an array to a reference of arrays with stack trace info
\&           each coming from the caller(stack_number) call
\& Returns : array containing a reference of arrays
\& Args    : none
.Ve
.SS "_rearrange"
.IX Subsection "_rearrange"
.Vb 10
\& Usage     : $object\->_rearrange( array_ref, list_of_arguments)
\& Purpose   : Rearranges named parameters to requested order.
\& Example   : $self\->_rearrange([qw(SEQUENCE ID DESC)],@param);
\&           : Where @param = (\-sequence => $s,
\&           :                 \-desc     => $d,
\&           :                 \-id       => $i);
\& Returns   : @params \- an array of parameters in the requested order.
\&           : The above example would return ($s, $i, $d).
\&           : Unspecified parameters will return undef. For example, if
\&           :        @param = (\-sequence => $s);
\&           : the above _rearrange call would return ($s, undef, undef)
\& Argument  : $order : a reference to an array which describes the desired
\&           :          order of the named parameters.
\&           : @param : an array of parameters, either as a list (in
\&           :          which case the function simply returns the list),
\&           :          or as an associative array with hyphenated tags
\&           :          (in which case the function sorts the values
\&           :          according to @{$order} and returns that new array.)
\&           :          The tags can be upper, lower, or mixed case
\&           :          but they must start with a hyphen (at least the
\&           :          first one should be hyphenated.)
\& Source    : This function was taken from CGI.pm, written by Dr. Lincoln
\&           : Stein, and adapted for use in Bio::Seq by Richard Resnick and
\&           : then adapted for use in Bio::Root::Object.pm by Steve Chervitz,
\&           : then migrated into Bio::Root::RootI.pm by Ewan Birney.
\& Comments  :
\&           : Uppercase tags are the norm,
\&           : (SAC)
\&           : This method may not be appropriate for method calls that are
\&           : within in an inner loop if efficiency is a concern.
\&           :
\&           : Parameters can be specified using any of these formats:
\&           :  @param = (\-name=>\*(Aqme\*(Aq, \-color=>\*(Aqblue\*(Aq);
\&           :  @param = (\-NAME=>\*(Aqme\*(Aq, \-COLOR=>\*(Aqblue\*(Aq);
\&           :  @param = (\-Name=>\*(Aqme\*(Aq, \-Color=>\*(Aqblue\*(Aq);
\&           :  @param = (\*(Aqme\*(Aq, \*(Aqblue\*(Aq);
\&           : A leading hyphenated argument is used by this function to
\&           : indicate that named parameters are being used.
\&           : Therefore, the (\*(Aqme\*(Aq, \*(Aqblue\*(Aq) list will be returned as\-is.
\&           :
\&           : Note that Perl will confuse unquoted, hyphenated tags as
\&           : function calls if there is a function of the same name
\&           : in the current namespace:
\&           :    \-name => \*(Aqfoo\*(Aq is interpreted as \-&name => \*(Aqfoo\*(Aq
\&           :
\&           : For ultimate safety, put single quotes around the tag:
\&           : (\*(Aq\-name\*(Aq=>\*(Aqme\*(Aq, \*(Aq\-color\*(Aq =>\*(Aqblue\*(Aq);
\&           : This can be a bit cumbersome and I find not as readable
\&           : as using all uppercase, which is also fairly safe:
\&           : (\-NAME=>\*(Aqme\*(Aq, \-COLOR =>\*(Aqblue\*(Aq);
\&           :
\&           : Personal note (SAC): I have found all uppercase tags to
\&           : be more manageable: it involves less single\-quoting,
\&           : the key names stand out better, and there are no method naming
\&           : conflicts.
\&           : The drawbacks are that it\*(Aqs not as easy to type as lowercase,
\&           : and lots of uppercase can be hard to read.
\&           :
\&           : Regardless of the style, it greatly helps to line
\&           : the parameters up vertically for long/complex lists.
\&           :
\&           : Note that if @param is a single string that happens to start with
\&           : a dash, it will be treated as a hash key and probably fail to
\&           : match anything in the array_ref, so not be returned as normally
\&           : happens when @param is a simple list and not an associative array.
.Ve
.SS "_set_from_args"
.IX Subsection "_set_from_args"
.Vb 10
\& Usage     : $object\->_set_from_args(\e%args, \-methods => \e@methods)
\& Purpose   : Takes a hash of user\-supplied args whose keys match method names,
\&           : and calls the method supplying it the corresponding value.
\& Example   : $self\->_set_from_args(\e%args, \-methods => [qw(sequence id desc)]);
\&           : Where %args = (\-sequence    => $s,
\&           :                \-description => $d,
\&           :                \-ID          => $i);
\&           :
\&           : the above _set_from_args calls the following methods:
\&           : $self\->sequence($s);
\&           : $self\->id($i);
\&           : ( $self\->description($i) is not called because \*(Aqdescription\*(Aq wasn\*(Aqt
\&           :   one of the given methods )
\& Argument  : \e%args | \e@args : a hash ref or associative array ref of arguments
\&           :                   where keys are any\-case strings corresponding to
\&           :                   method names but optionally prefixed with
\&           :                   hyphens, and values are the values the method
\&           :                   should be supplied. If keys contain internal
\&           :                   hyphens (eg. to separate multi\-word args) they
\&           :                   are converted to underscores, since method names
\&           :                   cannot contain dashes.
\&           : \-methods => []  : (optional) only call methods with names in this
\&           :                   array ref. Can instead supply a hash ref where
\&           :                   keys are method names (of real existing methods
\&           :                   unless \-create is in effect) and values are array
\&           :                   refs of synonyms to allow access to the method
\&           :                   using synonyms. If there is only one synonym it
\&           :                   can be supplied as a string instead of a single\-
\&           :                   element array ref
\&           : \-force => bool  : (optional, default 0) call methods that don\*(Aqt
\&           :                   seem to exist, ie. let AUTOLOAD handle them
\&           : \-create => bool : (optional, default 0) when a method doesn\*(Aqt
\&           :                   exist, create it as a simple getter/setter
\&           :                   (combined with \-methods it would create all the
\&           :                   supplied methods that didn\*(Aqt exist, even if not
\&           :                   mentioned in the supplied %args)
\&           : \-code => \*(Aq\*(Aq | {}: (optional) when creating methods use the supplied
\&           :                   code (a string which will be evaulated as a sub).
\&           :                   The default code is a simple get/setter.
\&           :                   Alternatively you can supply a hash ref where
\&           :                   the keys are method names and the values are
\&           :                   code strings. The variable \*(Aq$method\*(Aq will be
\&           :                   available at evaluation time, so can be used in
\&           :                   your code strings. Beware that the strict pragma
\&           :                   will be in effect.
\&           : \-case_sensitive => bool : require case sensitivity on the part of
\&           :                           user (ie. a() and A() are two different
\&           :                           methods and the user must be careful
\&           :                           which they use).
\& Comments  :
\&           : The \e%args argument will usually be the args received during new()
\&           : from the user. The user is allowed to get the case wrong, include
\&           : 0 or more than one hyphens as a prefix, and to include hyphens as
\&           : multi\-word arg separators: \*(Aq\-\-an\-arg\*(Aq => 1, \-an_arg => 1 and
\&           : An_Arg => 1 are all equivalent, calling an_arg(1). However, in
\&           : documentation users should only be told to use the standard form
\&           : \-an_arg to avoid confusion. A possible exception to this is a
\&           : wrapper module where \*(Aq\-\-an\-arg\*(Aq is what the user is used to
\&           : supplying to the program being wrapped.
\&           :
\&           : Another issue with wrapper modules is that there may be an
\&           : argument that has meaning both to Bioperl and to the program, eg.
\&           : \-verbose. The recommended way of dealing with this is to leave
\&           : \-verbose to set the Bioperl verbosity whilst requesting users use
\&           : an invented \-program_verbose (or similar) to set the program
\&           : verbosity. This can be resolved back with
\&           : Bio::Tools::Run::WrapperBase\*(Aqs _setparams() method and code along
\&           : the lines of:
\&           : my %methods = map { $_ => $_ } @LIST_OF_ALL_ALLOWED_PROGRAM_ARGS
\&           : delete $methods{\*(Aqverbose\*(Aq};
\&           : $methods{\*(Aqprogram_verbose\*(Aq} = \*(Aqverbose\*(Aq;
\&           : my $param_string = $self\->_setparams(\-methods => \e%methods);
\&           : system("$exe $param_string");
.Ve
.SS "_rearrange_old"
.IX Subsection "_rearrange_old"
.SS "_register_for_cleanup"
.IX Subsection "_register_for_cleanup"
.Vb 7
\& Title   : _register_for_cleanup
\& Usage   : \-\- internal \-\-
\& Function: Register a method to be called at DESTROY time. This is useful
\&           and sometimes essential in the case of multiple inheritance for
\&           classes coming second in the sequence of inheritance.
\& Returns :
\& Args    : a code reference
.Ve
.PP
The code reference will be invoked with the object as the first
argument, as per a method.  You may register an unlimited number of
cleanup methods.
.SS "_unregister_for_cleanup"
.IX Subsection "_unregister_for_cleanup"
.Vb 7
\& Title   : _unregister_for_cleanup
\& Usage   : \-\- internal \-\-
\& Function: Remove a method that has previously been registered to be called
\&           at DESTROY time.  If called with a method to be called at DESTROY time.
\&           Has no effect if the code reference has not previously been registered.
\& Returns : nothing
\& Args    : a code reference
.Ve
.SS "_cleanup_methods"
.IX Subsection "_cleanup_methods"
.Vb 5
\& Title   : _cleanup_methods
\& Usage   : \-\- internal \-\-
\& Function: Return current list of registered cleanup methods.
\& Returns : list of coderefs
\& Args    : none
.Ve
.SS "throw_not_implemented"
.IX Subsection "throw_not_implemented"
.Vb 10
\& Purpose : Throws a Bio::Root::NotImplemented exception.
\&           Intended for use in the method definitions of
\&           abstract interface modules where methods are defined
\&           but are intended to be overridden by subclasses.
\& Usage   : $object\->throw_not_implemented();
\& Example : sub method_foo {
\&             $self = shift;
\&             $self\->throw_not_implemented();
\&           }
\& Returns : n/a
\& Args    : n/a
\& Throws  : A Bio::Root::NotImplemented exception.
\&           The message of the exception contains
\&             \- the name of the method
\&             \- the name of the interface
\&             \- the name of the implementing class
\&
\&           If this object has a throw() method, $self\->throw will be used.
\&           If the object doesn\*(Aqt have a throw() method,
\&           Carp::confess() will be used.
.Ve
.SS "warn_not_implemented"
.IX Subsection "warn_not_implemented"
.Vb 10
\& Purpose : Generates a warning that a method has not been implemented.
\&           Intended for use in the method definitions of
\&           abstract interface modules where methods are defined
\&           but are intended to be overridden by subclasses.
\&           Generally, throw_not_implemented() should be used,
\&           but warn_not_implemented() may be used if the method isn\*(Aqt
\&           considered essential and convenient no\-op behavior can be
\&           provided within the interface.
\& Usage   : $object\->warn_not_implemented( method\-name\-string );
\& Example : $self\->warn_not_implemented( "get_foobar" );
\& Returns : Calls $self\->warn on this object, if available.
\&           If the object doesn\*(Aqt have a warn() method,
\&           Carp::carp() will be used.
\& Args    : n/a
.Ve
.SS "_not_implemented_msg"
.IX Subsection "_not_implemented_msg"
Unify 'not implemented' message. \-Juguang
