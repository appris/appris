.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SVG 3pm"
.TH SVG 3pm "2013-03-30" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SVG \- Perl extension for generating Scalable Vector Graphics (SVG) documents
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    #!/usr/bin/perl \-w
\&    use strict;
\&    use SVG;
\&
\&    # create an SVG object
\&    my $svg= SVG\->new(width=>200,height=>200);
\&
\&    # use explicit element constructor to generate a group element
\&    my $y=$svg\->group(
\&        id    => \*(Aqgroup_y\*(Aq,
\&        style => { stroke=>\*(Aqred\*(Aq, fill=>\*(Aqgreen\*(Aq }
\&    );
\&
\&    # add a circle to the group
\&    $y\->circle(cx=>100, cy=>100, r=>50, id=>\*(Aqcircle_in_group_y\*(Aq);
\&
\&    # or, use the generic \*(Aqtag\*(Aq method to generate a group element by name
\&    my $z=$svg\->tag(\*(Aqg\*(Aq,
\&                    id    => \*(Aqgroup_z\*(Aq,
\&                    style => {
\&                        stroke => \*(Aqrgb(100,200,50)\*(Aq,
\&                        fill   => \*(Aqrgb(10,100,150)\*(Aq
\&                    }
\&                );
\&
\&    # create and add a circle using the generic \*(Aqtag\*(Aq method
\&    $z\->tag(\*(Aqcircle\*(Aq, cx=>50, cy=>50, r=>100, id=>\*(Aqcircle_in_group_z\*(Aq);
\&
\&    # create an anchor on a rectangle within a group within the group z
\&    my $k = $z\->anchor(
\&        id      => \*(Aqanchor_k\*(Aq,
\&        \-href   => \*(Aqhttp://test.hackmare.com/\*(Aq,
\&        target => \*(Aqnew_window_0\*(Aq
\&    )\->rectangle(
\&        x     => 20, y      => 50,
\&        width => 20, height => 30,
\&        rx    => 10, ry     => 5,
\&        id    => \*(Aqrect_k_in_anchor_k_in_group_z\*(Aq
\&    );
\&
\&    # now render the SVG object, implicitly use svg namespace
\&    print $svg\->xmlify;
\&
\&    # or render a child node of the SVG object without rendering the entire object
\&    print $k\->xmlify; #renders the anchor $k above containing a rectangle, but does not
\&                      #render any of the ancestor nodes of $k
\&
\&
\&    # or, explicitly use svg namespace and generate a document with its own DTD
\&    print $svg\->xmlify(\-namespace=>\*(Aqsvg\*(Aq);
\&
\&    # or, explicitly use svg namespace and generate an inline docunent
\&    print $svg\->xmlify(
\&        \-namespace => "svg",
\&        \-pubid => "\-//W3C//DTD SVG 1.0//EN",
\&        \-inline   => 1
\&    );
.Ve
.PP
See the other modules in this distribution:
\&\s-1SVG::DOM\s0,
\&\s-1SVG::XML\s0,
SVG::Element,
SVG::Parser,
SVG::Extension
.SH "VERSION"
.IX Header "VERSION"
Version 2.59
.SH "EXAMPLES"
.IX Header "EXAMPLES"
examples/circle.pl generates the following image:
.PP
.Vb 9
\&  <?xml version="1.0" encoding="UTF\-8" standalone="yes"?>
\&  <!DOCTYPE svg PUBLIC "\-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC\-SVG\-20010904/DTD/svg10.dtd">
\&  <svg height="200" width="200" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
\&  <title >I am a title</title>
\&  <g id="group_y" style="fill: green; stroke: red">
\&  <circle cx="100" cy="100" id="circle_in_group_y" r="50" />
\&  <!\-\- This is a comment \-\->
\&  </g>
\&  </svg>
.Ve
.PP
That you can either embed directly into \s-1HTML\s0 or can include it using:
.PP
.Vb 1
\&   <object data="file.svg" type="image/svg+xml"></object>
.Ve
.PP
(The image was converted to png using Image::LibRSVG. See the svg2png.pl script in the examples directory.)
.PP
See also the \fBexamples\fR directory in this distribution which contain several fully documented examples.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1SVG\s0 is a 100% Perl module which generates a nested data structure containing the
\&\s-1DOM\s0 representation of an \s-1SVG\s0 (Scalable Vector Graphics) image. Using \s-1SVG\s0, you
can generate \s-1SVG\s0 objects, embed other \s-1SVG\s0 instances into it, access the \s-1DOM\s0
object, create and access javascript, and generate \s-1SMIL\s0 animation content.
.SS "General Steps to generating an \s-1SVG\s0 document"
.IX Subsection "General Steps to generating an SVG document"
Generating \s-1SVG\s0 is a simple three step process:
.ie n .SS "1 The first step is to construct a new \s-1SVG\s0 object with ""new""."
.el .SS "1 The first step is to construct a new \s-1SVG\s0 object with ``new''."
.IX Subsection "1 The first step is to construct a new SVG object with new."
.ie n .SS "2 The second step is to call element constructors to create \s-1SVG\s0 elements. Examples of element constructors are ""circle"" and ""path""."
.el .SS "2 The second step is to call element constructors to create \s-1SVG\s0 elements. Examples of element constructors are ``circle'' and ``path''."
.IX Subsection "2 The second step is to call element constructors to create SVG elements. Examples of element constructors are circle and path."
.ie n .SS "3 The third and last step is to render the \s-1SVG\s0 object into \s-1XML\s0 using the ""xmlify"" method."
.el .SS "3 The third and last step is to render the \s-1SVG\s0 object into \s-1XML\s0 using the ``xmlify'' method."
.IX Subsection "3 The third and last step is to render the SVG object into XML using the xmlify method."
The \*(L"xmlify\*(R" method takes a number of optional arguments that control how \s-1SVG\s0
renders the object into \s-1XML\s0, and in particular determine whether a standalone
\&\s-1SVG\s0 document or an inline \s-1SVG\s0 document fragment is generated:
.SS "\-standalone"
.IX Subsection "-standalone"
A complete \s-1SVG\s0 document with its own associated \s-1DTD\s0. A namespace for the \s-1SVG\s0
elements may be optionally specified.
.SS "\-inline"
.IX Subsection "-inline"
An inline \s-1SVG\s0 document fragment with no \s-1DTD\s0 that be embedded within other \s-1XML\s0
content. As with standalone documents, an alternate namespace may be specified.
.PP
No \s-1XML\s0 content is generated until the third step is reached. Up until this
point, all constructed element definitions reside in a DOM-like data structure
from which they can be accessed and modified.
.SS "\s-1EXPORTS\s0"
.IX Subsection "EXPORTS"
None. However, \s-1SVG\s0 permits both options and additional element methods to be
specified in the import list. These options and elements are then available
for all \s-1SVG\s0 instances that are created with the \*(L"new\*(R" constructor. For example,
to change the indent string to two spaces per level:
.PP
.Vb 1
\&    use SVG (\-indent => "  ");
.Ve
.PP
With the exception of \-auto, all options may also be specified to the \*(L"new\*(R"
constructor. The currently supported options and their default value are:
.PP
.Vb 4
\&    # processing options
\&    \-auto       => 0,       # permit arbitrary autoloading of all unrecognised elements
\&    \-printerror => 1,       # print error messages to STDERR
\&    \-raiseerror => 1,       # die on errors (implies \-printerror)
\&
\&    # rendering options
\&    \-indent     => "\et",    # what to indent with
\&    \-elsep      => "\en",    # element line (vertical) separator
\&                            #     (note that not all agents ignor trailing blanks)
\&    \-nocredits  => 0,       # enable/disable credit note comment
\&    \-namespace  => \*(Aq\*(Aq,      # The root element\*(Aqs (and it\*(Aqs children\*(Aqs) namespace prefix
\&
\&    # XML and Doctype declarations
\&    \-inline     => 0,       # inline or stand alone
\&    \-docroot    => \*(Aqsvg\*(Aq,   # The document\*(Aqs root element
\&    \-version    => \*(Aq1.0\*(Aq,
\&    \-extension  => \*(Aq\*(Aq,
\&    \-encoding   => \*(AqUTF\-8\*(Aq,
\&    \-xml_svg    => \*(Aqhttp://www.w3.org/2000/svg\*(Aq,   # the svg xmlns attribute
\&    \-xml_xlink  => \*(Aqhttp://www.w3.org/1999/xlink\*(Aq, # the svg tag xmlns:xlink attribute
\&    \-standalone => \*(Aqyes\*(Aq,
\&    \-pubid      => "\-//W3C//DTD SVG 1.0//EN",      # formerly \-identifier
\&    \-sysid      => \*(Aqhttp://www.w3.org/TR/2001/REC\-SVG\-20010904/DTD/svg10.dtd\*(Aq, # the system id
.Ve
.PP
\&\s-1SVG\s0 also allows additional element generation methods to be specified in the
import list. For example to generate 'star' and 'planet' element methods:
.PP
.Vb 1
\&    use SVG qw(star planet);
.Ve
.PP
or:
.PP
.Vb 1
\&    use SVG ("star","planet");
.Ve
.PP
This will add 'star' to the list of elements supported by \s-1SVG\s0.pm (but not of
course other \s-1SVG\s0 parsers...). Alternatively the '\-auto' option will allow
any unknown method call to generate an element of the same name:
.PP
.Vb 1
\&    use SVG (\-auto => 1, "star", "planet");
.Ve
.PP
Any elements specified explicitly (as 'star' and 'planet' are here) are
predeclared; other elements are defined as and when they are seen by Perl. Note
that enabling '\-auto' effectively disables compile-time syntax checking for
valid method names.
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    use SVG (
\&        \-auto       => 0,
\&        \-indent     => "  ",
\&        \-raiseerror  => 0,
\&        \-printerror => 1,
\&        "star", "planet", "moon"
\&    );
.Ve
.SS "Default \s-1SVG\s0 tag"
.IX Subsection "Default SVG tag"
The Default \s-1SVG\s0 tag will generate the following \s-1XML:\s0
.PP
.Vb 2
\&  $svg = SVG\->new;
\&  print $svg\->xmlify;
.Ve
.PP
Resulting \s-1XML\s0 snippet:
.PP
.Vb 8
\&  <?xml version="1.0" encoding="UTF\-8" standalone="yes"?>
\&  <!DOCTYPE svg PUBLIC "\-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC\-SVG\-20010904/DTD/svg10.dtd">
\&  <svg height="100%" width="100%" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
\&        <!\-\-
\&          Generated using the Perl SVG Module V2.50
\&        by Ronan Oger
\&          Info: http://www.roitsystems.com/
\&   \-\->
.Ve
.SH "METHODS"
.IX Header "METHODS"
\&\s-1SVG\s0 provides both explicit and generic element constructor methods. Explicit
generators are generally (with a few exceptions) named for the element they
generate. If a tag method is required for a tag containing hyphens, the method
name replaces the hyphen with an underscore. ie: to generate tag <column\-heading id=\*(L"new\*(R">
you would use method \f(CW$svg\fR\->column_heading(id=>'new').
.PP
All element constructors take a hash of element attributes and options;
element attributes such as 'id' or 'border' are passed by name, while options for the
method (such as the type of an element that supports multiple alternate forms)
are passed preceded by a hyphen, e.g '\-type'. Both types may be freely
intermixed; see the \*(L"fe\*(R" method and code examples througout the documentation
for more examples.
.SS "new (constructor)"
.IX Subsection "new (constructor)"
\&\f(CW$svg\fR = \s-1SVG\-\s0>new(%attributes)
.PP
Creates a new \s-1SVG\s0 object. Attributes of the document \s-1SVG\s0 element be passed as
an optional list of key value pairs. Additionally, \s-1SVG\s0 options (prefixed with
a hyphen) may be set on a per object basis:
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $svg1 = SVG\->new;
\&
\&    my $svg2 = SVG\->new(id => \*(Aqdocument_element\*(Aq);
\&
\&    my $svg3 = SVG\->new(s
\&        \-printerror => 1,
\&        \-raiseerror => 0,
\&        \-indent     => \*(Aq  \*(Aq,
\&        \-docroot => \*(Aqsvg\*(Aq, #default document root element (SVG specification assumes svg). Defaults to \*(Aqsvg\*(Aq if undefined
\&        \-sysid      => \*(Aqabc\*(Aq, #optional system identifyer
\&        \-pubid      => "\-//W3C//DTD SVG 1.0//EN", #public identifyer default value is "\-//W3C//DTD SVG 1.0//EN" if undefined
\&        \-namespace => \*(Aqmysvg\*(Aq,
\&        \-inline   => 1
\&        id          => \*(Aqdocument_element\*(Aq,
\&        width       => 300,
\&        height      => 200,
\&    );
.Ve
.PP
Default \s-1SVG\s0 options may also be set in the import list. See \*(L"\s-1EXPORTS\s0\*(R" above
for more on the available options.
.PP
Furthermore, the following options:
.PP
.Vb 8
\&    \-version
\&    \-encoding
\&    \-standalone
\&    \-namespace Defines the document or element level namespace. The order of assignment priority is element,document .
\&    \-inline
\&    \-identifier
\&    \-nostub
\&    \-dtd (standalone)
.Ve
.PP
may also be set in xmlify, overriding any corresponding values set in the \s-1SVG\-\s0>new declaration
.SS "xmlify (alias: to_xml render serialise serialize)"
.IX Subsection "xmlify (alias: to_xml render serialise serialize)"
\&\f(CW$string\fR = \f(CW$svg\fR\->xmlify(%attributes);
.PP
Returns xml representation of svg document.
.PP
\&\fB\s-1XML\s0 Declaration\fR
.PP
.Vb 8
\&    Name               Default Value
\&    \-version           \*(Aq1.0\*(Aq
\&    \-encoding          \*(AqUTF\-8\*(Aq
\&    \-standalone        \*(Aqyes\*(Aq
\&    \-namespace         \*(Aqsvg\*(Aq                \- namespace for elements
\&    \-inline            \*(Aq0\*(Aq \- If \*(Aq1\*(Aq, then this is an inline document.
\&    \-pubid             \*(Aq\-//W3C//DTD SVG 1.0//EN\*(Aq;
\&    \-dtd (standalone)  \*(Aqhttp://www.w3.org/TR/2001/REC\-SVG\-20010904/DTD/svg10.dtd\*(Aq
.Ve
.SS "tag (alias: element)"
.IX Subsection "tag (alias: element)"
\&\f(CW$tag\fR = \f(CW$svg\fR\->tag($name, \f(CW%attributes\fR)
.PP
Generic element generator. Creates the element named \f(CW$name\fR with the attributes
specified in \f(CW%attributes\fR. This method is the basis of most of the explicit
element generators.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $tag = $svg\->tag(\*(Aqg\*(Aq, transform=>\*(Aqrotate(\-45)\*(Aq);
.Ve
.SS "anchor"
.IX Subsection "anchor"
\&\f(CW$tag\fR = \f(CW$svg\fR\->anchor(%attributes)
.PP
Generate an anchor element. Anchors are put around objects to make them
\&'live' (i.e. clickable). It therefore requires a drawn object or group element
as a child.
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    # generate an anchor
\&    $tag = $svg\->anchor(
\&        \-href=>\*(Aqhttp://here.com/some/simpler/svg.svg\*(Aq
\&    );
\&    # add a circle to the anchor. The circle can be clicked on.
\&    $tag\->circle(cx=>10,cy=>10,r=>1);
\&
\&    # more complex anchor with both URL and target
\&    $tag = $svg\->anchor(
\&              \-href   => \*(Aqhttp://somewhere.org/some/other/page.html\*(Aq,
\&              target => \*(Aqnew_window\*(Aq
\&    );
.Ve
.SS "circle"
.IX Subsection "circle"
\&\f(CW$tag\fR = \f(CW$svg\fR\->circle(%attributes)
.PP
Draw a circle at (cx,cy) with radius r.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $tag = $svg\->circle(cx=>4, cy=>2, r=>1);
.Ve
.SS "ellipse"
.IX Subsection "ellipse"
\&\f(CW$tag\fR = \f(CW$svg\fR\->ellipse(%attributes)
.PP
Draw an ellipse at (cx,cy) with radii rx,ry.
.PP
\&\fBExample:\fR
.PP
.Vb 12
\&    my $tag = $svg\->ellipse(
\&        cx=>10, cy=>10,
\&        rx=>5, ry=>7,
\&        id=>\*(Aqellipse\*(Aq,
\&        style=>{
\&            \*(Aqstroke\*(Aq=>\*(Aqred\*(Aq,
\&            \*(Aqfill\*(Aq=>\*(Aqgreen\*(Aq,
\&            \*(Aqstroke\-width\*(Aq=>\*(Aq4\*(Aq,
\&            \*(Aqstroke\-opacity\*(Aq=>\*(Aq0.5\*(Aq,
\&            \*(Aqfill\-opacity\*(Aq=>\*(Aq0.2\*(Aq
\&        }
\&    );
.Ve
.SS "rectangle (alias: rect)"
.IX Subsection "rectangle (alias: rect)"
\&\f(CW$tag\fR = \f(CW$svg\fR\->rectangle(%attributes)
.PP
Draw a rectangle at (x,y) with width 'width' and height 'height' and side radii
\&'rx' and 'ry'.
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    $tag = $svg\->rectangle(
\&        x=>10, y=>20,
\&        width=>4, height=>5,
\&        rx=>5.2, ry=>2.4,
\&        id=>\*(Aqrect_1\*(Aq
\&    );
.Ve
.SS "image"
.IX Subsection "image"
.Vb 1
\& $tag = $svg\->image(%attributes)
.Ve
.PP
Draw an image at (x,y) with width 'width' and height 'height' linked to image
resource '\-href'. See also \*(L"use\*(R".
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    $tag = $svg\->image(
\&        x=>100, y=>100,
\&        width=>300, height=>200,
\&        \*(Aq\-href\*(Aq=>"image.png", #may also embed SVG, e.g. "image.svg"
\&        id=>\*(Aqimage_1\*(Aq
\&    );
.Ve
.PP
\&\fBOutput:\fR
.PP
.Vb 1
\&    <image xlink:href="image.png" x="100" y="100" width="300" height="200"/>
.Ve
.SS "use"
.IX Subsection "use"
\&\f(CW$tag\fR = \f(CW$svg\fR\->use(%attributes)
.PP
Retrieve the content from an entity within an \s-1SVG\s0 document and apply it at
(x,y) with width 'width' and height 'height' linked to image resource '\-href'.
.PP
\&\fBExample:\fR
.PP
.Vb 6
\&    $tag = $svg\->use(
\&        x=>100, y=>100,
\&        width=>300, height=>200,
\&        \*(Aq\-href\*(Aq=>"pic.svg#image_1",
\&        id=>\*(Aqimage_1\*(Aq
\&    );
.Ve
.PP
\&\fBOutput:\fR
.PP
.Vb 1
\&    <use xlink:href="pic.svg#image_1" x="100" y="100" width="300" height="200"/>
.Ve
.PP
According to the \s-1SVG\s0 specification, the 'use' element in \s-1SVG\s0 can point to a
single element within an external \s-1SVG\s0 file.
.SS "polygon"
.IX Subsection "polygon"
\&\f(CW$tag\fR = \f(CW$svg\fR\->polygon(%attributes)
.PP
Draw an n\-sided polygon with vertices at points defined by a string of the form
\&'x1,y1,x2,y2,x3,y3,... xy,yn'. The \*(L"get_path\*(R" method is provided as a
convenience to generate a suitable string from coordinate data.
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    # a five\-sided polygon
\&    my $xv = [0,2,4,5,1];
\&    my $yv = [0,0,2,7,5];
\&
\&    $points = $a\->get_path(
\&        x=>$xv, y=>$yv,
\&        \-type=>\*(Aqpolygon\*(Aq
\&    );
\&
\&    $c = $a\->polygon(
\&        %$points,
\&        id=>\*(Aqpgon1\*(Aq,
\&        style=>\e%polygon_style
\&    );
.Ve
.PP
\&\s-1SEE\s0 \s-1ALSO:\s0
.PP
\&\*(L"polyline\*(R", \*(L"path\*(R", \*(L"get_path\*(R".
.SS "polyline"
.IX Subsection "polyline"
\&\f(CW$tag\fR = \f(CW$svg\fR\->polyline(%attributes)
.PP
Draw an n\-point polyline with points defined by a string of the form
\&'x1,y1,x2,y2,x3,y3,... xy,yn'. The \*(L"get_path\*(R" method is provided as a
convenience to generate a suitable string from coordinate data.
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    # a 10\-pointsaw\-tooth pattern
\&    my $xv = [0,1,2,3,4,5,6,7,8,9];
\&    my $yv = [0,1,0,1,0,1,0,1,0,1];
\&
\&    $points = $a\->get_path(
\&        x=>$xv, y=>$yv,
\&        \-type=>\*(Aqpolyline\*(Aq,
\&        \-closed=>\*(Aqtrue\*(Aq #specify that the polyline is closed.
\&    );
\&
\&    my $tag = $a\->polyline (
\&        %$points,
\&        id=>\*(Aqpline_1\*(Aq,
\&        style=>{
\&            \*(Aqfill\-opacity\*(Aq => 0,
\&            \*(Aqstroke\*(Aq => \*(Aqrgb(250,123,23)\*(Aq
\&        }
\&    );
.Ve
.SS "line"
.IX Subsection "line"
\&\f(CW$tag\fR = \f(CW$svg\fR\->line(%attributes)
.PP
Draw a straight line between two points (x1,y1) and (x2,y2).
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    my $tag = $svg\->line(
\&        id=>\*(Aql1\*(Aq,
\&        x1=>0, y1=>10,
\&        x2=>10, y2=>0
\&    );
.Ve
.PP
To draw multiple connected lines, use \*(L"polyline\*(R".
.SS "text"
.IX Subsection "text"
\&\f(CW$text\fR = \f(CW$svg\fR\->text(%attributes)\->\fIcdata()\fR;
.PP
\&\f(CW$text_path\fR = \f(CW$svg\fR\->text(\-type=>'path');
\&\f(CW$text_span\fR = \f(CW$text_path\fR\->text(\-type=>'span')\->cdata('A');
\&\f(CW$text_span\fR = \f(CW$text_path\fR\->text(\-type=>'span')\->cdata('B');
\&\f(CW$text_span\fR = \f(CW$text_path\fR\->text(\-type=>'span')\->cdata('C');
.PP
define the container for a text string to be drawn in the image.
.PP
\&\fBInput:\fR
    \-type     = path type (path | polyline | polygon)
    \-type     = text element type  (path | span | normal [default])
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $text1 = $svg\->text(
\&        id=>\*(Aql1\*(Aq, x=>10, y=>10
\&    )\->cdata(\*(Aqhello, world\*(Aq);
\&
\&    my $text2 = $svg\->text(
\&        id=>\*(Aql1\*(Aq, x=>10, y=>10, \-cdata=>\*(Aqhello, world\*(Aq);
\&
\&    my $text = $svg\->text(
\&        id=>\*(Aqtp\*(Aq, x=>10, y=>10 \-type=>path)
\&        \->text(id=>\*(Aqts\*(Aq \-type=>\*(Aqspan\*(Aq)
\&        \->cdata(\*(Aqhello, world\*(Aq);
.Ve
.PP
\&\s-1SEE\s0 \s-1ALSO:\s0
.PP
.Vb 1
\&    L<"desc">, L<"cdata">.
.Ve
.SS "title"
.IX Subsection "title"
\&\f(CW$tag\fR = \f(CW$svg\fR\->title(%attributes)
.PP
Generate the title of the image.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $tag = $svg\->title(id=>\*(Aqdocument\-title\*(Aq)\->cdata(\*(AqThis is the title\*(Aq);
.Ve
.SS "desc"
.IX Subsection "desc"
\&\f(CW$tag\fR = \f(CW$svg\fR\->desc(%attributes)
.PP
Generate the description of the image.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $tag = $svg\->desc(id=>\*(Aqdocument\-desc\*(Aq)\->cdata(\*(AqThis is a description\*(Aq);
.Ve
.SS "comment"
.IX Subsection "comment"
\&\f(CW$tag\fR = \f(CW$svg\fR\->comment(@comments)
.PP
Generate the description of the image.
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $tag = $svg\->comment(\*(Aqcomment 1\*(Aq,\*(Aqcomment 2\*(Aq,\*(Aqcomment 3\*(Aq);
.Ve
.SS "pi (Processing Instruction)"
.IX Subsection "pi (Processing Instruction)"
\&\f(CW$tag\fR = \f(CW$svg\fR\->pi(@pi)
.PP
Generate a set of processing instructions
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $tag = $svg\->pi(\*(Aqinstruction one\*(Aq,\*(Aqinstruction two\*(Aq,\*(Aqinstruction three\*(Aq);
\&
\&    returns:
\&      <lt>?instruction one?<gt>
\&      <lt>?instruction two?<gt>
\&      <lt>?instruction three?<gt>
.Ve
.SS "script"
.IX Subsection "script"
\&\f(CW$tag\fR = \f(CW$svg\fR\->script(%attributes)
.PP
Generate a script container for dynamic (client-side) scripting using
ECMAscript, Javascript or other compatible scripting language.
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    my $tag = $svg\->script(\-type=>"text/ecmascript");
\&    #or my $tag = $svg\->script();
\&    #note that type ecmascript is not Mozilla compliant
\&
\&    # populate the script tag with cdata
\&    # be careful to manage the javascript line ends.
\&    # qq|text| or qqA\*^XtextA\*^X where text is the script
\&    # works well for this.
\&    #make sure to use the CAPITAL CDATA to poulate the script.
\&    $tag\->CDATA(qq|function d(){
\&        //simple display function
\&        for(cnt = 0; cnt < d.length; cnt++)
\&            document.write(d[cnt]);//end for loop
\&        document.write("<BR>");//write a line break
\&      }|
\&    );
.Ve
.SS "path"
.IX Subsection "path"
\&\f(CW$tag\fR = \f(CW$svg\fR\->path(%attributes)
.PP
Draw a path element. The path vertices may be imputed as a parameter or
calculated usingthe \*(L"get_path\*(R" method.
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    # a 10\-pointsaw\-tooth pattern drawn with a path definition
\&    my $xv = [0,1,2,3,4,5,6,7,8,9];
\&    my $yv = [0,1,0,1,0,1,0,1,0,1];
\&
\&    $points = $a\->get_path(
\&        x => $xv,
\&        y => $yv,
\&        \-type   => \*(Aqpath\*(Aq,
\&        \-closed => \*(Aqtrue\*(Aq  #specify that the polyline is closed
\&    );
\&
\&    $tag = $svg\->path(
\&        %$points,
\&        id    => \*(Aqpline_1\*(Aq,
\&        style => {
\&            \*(Aqfill\-opacity\*(Aq => 0,
\&            \*(Aqfill\*(Aq   => \*(Aqgreen\*(Aq,
\&            \*(Aqstroke\*(Aq => \*(Aqrgb(250,123,23)\*(Aq
\&        }
\&    );
.Ve
.PP
\&\s-1SEE\s0 \s-1ALSO:\s0
.PP
\&\*(L"get_path\*(R".
.SS "get_path"
.IX Subsection "get_path"
\&\f(CW$path\fR = \f(CW$svg\fR\->get_path(%attributes)
.PP
Returns the text string of points correctly formatted to be incorporated into
the multi-point \s-1SVG\s0 drawing object definitions (path, polyline, polygon)
.PP
\&\fBInput:\fR attributes including:
.PP
.Vb 3
\&    \-type     = path type (path | polyline | polygon)
\&    x         = reference to array of x coordinates
\&    y         = reference to array of y coordinates
.Ve
.PP
\&\fBOutput:\fR a hash reference consisting of the following key-value pair:
.PP
.Vb 4
\&    points    = the appropriate points\-definition string
\&    \-type     = path|polygon|polyline
\&    \-relative = 1 (define relative position rather than absolute position)
\&    \-closed   = 1 (close the curve \- path and polygon only)
.Ve
.PP
\&\fBExample:\fR
.PP
.Vb 3
\&    #generate an open path definition for a path.
\&    my ($points,$p);
\&    $points = $svg\->get_path(x=&gt\e@x,y=&gt\e@y,\-relative=&gt1,\-type=&gt\*(Aqpath\*(Aq);
\&
\&    #add the path to the SVG document
\&    my $p = $svg\->path(%$path, style=>\e%style_definition);
\&
\&    #generate an closed path definition for a a polyline.
\&    $points = $svg\->get_path(
\&        x=>\e@x,
\&        y=>\e@y,
\&        \-relative=>1,
\&        \-type=>\*(Aqpolyline\*(Aq,
\&        \-closed=>1
\&    ); # generate a closed path definition for a polyline
\&
\&    # add the polyline to the SVG document
\&    $p = $svg\->polyline(%$points, id=>\*(Aqpline1\*(Aq);
.Ve
.PP
\&\fBAliases:\fR get_path set_path
.SS "animate"
.IX Subsection "animate"
\&\f(CW$tag\fR = \f(CW$svg\fR\->animate(%attributes)
.PP
Generate an \s-1SMIL\s0 animation tag. This is allowed within any nonempty tag. Refer\e
to the W3C for detailed information on the subtleties of the animate \s-1SMIL\s0
commands.
.PP
\&\fBInputs:\fR \-method = Transform | Motion | Color
.PP
.Vb 3
\&  my $an_ellipse = $svg\->ellipse(
\&      cx=>30,cy=>150,rx=>10,ry=>10,id=>\*(Aqan_ellipse\*(Aq,
\&      stroke=>\*(Aqrgb(130,220,70)\*(Aq,fill=>\*(Aqrgb(30,20,50)\*(Aq);
\&
\&  $an_ellipse\-> animate(
\&      attributeName=>"cx",values=>"20; 200; 20",dur=>"10s", repeatDur=>\*(Aqindefinite\*(Aq);
\&
\&  $an_ellipse\-> animate(
\&      attributeName=>"rx",values=>"10;30;20;100;50",
\&      dur=>"10s", repeatDur=>\*(Aqindefinite\*(Aq);
\&
\&  $an_ellipse\-> animate(
\&      attributeName=>"ry",values=>"30;50;10;20;70;150",
\&      dur=>"15s", repeatDur=>\*(Aqindefinite\*(Aq);
\&
\&  $an_ellipse\-> animate(
\&      attributeName=>"rx",values=>"30;75;10;100;20;20;150",
\&      dur=>"20s", repeatDur=>\*(Aqindefinite\*(Aq);
\&
\&  $an_ellipse\-> animate(
\&      attributeName=>"fill",values=>"red;green;blue;cyan;yellow",
\&      dur=>"5s", repeatDur=>\*(Aqindefinite\*(Aq);
\&
\&  $an_ellipse\-> animate(
\&      attributeName=>"fill\-opacity",values=>"0;1;0.5;0.75;1",
\&      dur=>"20s",repeatDur=>\*(Aqindefinite\*(Aq);
\&
\&  $an_ellipse\-> animate(
\&      attributeName=>"stroke\-width",values=>"1;3;2;10;5",
\&      dur=>"20s",repeatDur=>\*(Aqindefinite\*(Aq);
.Ve
.SS "group"
.IX Subsection "group"
\&\f(CW$tag\fR = \f(CW$svg\fR\->group(%attributes)
.PP
Define a group of objects with common properties. groups can have style,
animation, filters, transformations, and mouse actions assigned to them.
.PP
\&\fBExample:\fR
.PP
.Vb 9
\&    $tag = $svg\->group(
\&        id        => \*(Aqxvs000248\*(Aq,
\&        style     => {
\&            \*(Aqfont\*(Aq      => [ qw( Arial Helvetica sans ) ],
\&            \*(Aqfont\-size\*(Aq => 10,
\&            \*(Aqfill\*(Aq      => \*(Aqred\*(Aq,
\&        },
\&        transform => \*(Aqrotate(\-45)\*(Aq
\&    );
.Ve
.SS "defs"
.IX Subsection "defs"
\&\f(CW$tag\fR = \f(CW$svg\fR\->defs(%attributes)
.PP
define a definition segment. A Defs requires children when defined using \s-1SVG\s0.pm
\&\fBExample:\fR
.PP
.Vb 1
\&    $tag = $svg\->defs(id  =>  \*(Aqdef_con_one\*(Aq,);
.Ve
.SS "style"
.IX Subsection "style"
\&\f(CW$svg\fR\->tag('style', \f(CW%styledef\fR);
.PP
Sets/Adds style-definition for the following objects being created.
.PP
Style definitions apply to an object and all its children for all properties for
which the value of the property is not redefined by the child.
.SS "mouseaction"
.IX Subsection "mouseaction"
\&\f(CW$svg\fR\->mouseaction(%attributes)
.PP
Sets/Adds mouse action definitions for tag
.SS "attrib"
.IX Subsection "attrib"
\&\f(CW$svg\fR\->attrib($name, \f(CW$value\fR)
.PP
Sets/Adds mouse action definitions.
.PP
\&\f(CW$svg\fR\->attrib \f(CW$name\fR, \f(CW$value\fR
.PP
\&\f(CW$svg\fR\->attrib \f(CW$name\fR, \e@value
.PP
\&\f(CW$svg\fR\->attrib \f(CW$name\fR, \e%value
.PP
Sets/Replaces attributes for a tag.
.SS "cdata"
.IX Subsection "cdata"
\&\f(CW$svg\fR\->cdata($text)
.PP
Sets cdata to \f(CW$text\fR. \s-1SVG\s0.pm allows you to set cdata for any tag. If the tag is
meant to be an empty tag, \s-1SVG\s0.pm will not complain, but the rendering agent will
fail. In the \s-1SVG\s0 \s-1DTD\s0, cdata is generally only meant for adding text or script
content.
.PP
\&\fBExample:\fR
.PP
.Vb 5
\&    $svg\->text(
\&        style => {
\&            \*(Aqfont\*(Aq      => \*(AqArial\*(Aq,
\&            \*(Aqfont\-size\*(Aq => 20
\&        })\->cdata(\*(AqSVG.pm is a perl module on CPAN!\*(Aq);
\&
\&    my $text = $svg\->text(style=>{\*(Aqfont\*(Aq=>\*(AqArial\*(Aq,\*(Aqfont\-size\*(Aq=>20});
\&    $text\->cdata(\*(AqSVG.pm is a perl module on CPAN!\*(Aq);
.Ve
.PP
\&\fBResult:\fR
.PP
.Vb 1
\&    E<lt>text style="font: Arial; font\-size: 20" E<gt>SVG.pm is a perl module on CPAN!E<lt>/text E<gt>
.Ve
.PP
\&\s-1SEE\s0 \s-1ALSO:\s0
.PP
.Vb 1
\&  L<"CDATA"> L<"desc">, L<"title">, L<"text">, L<"script">.
.Ve
.SS "cdata_noxmlesc"
.IX Subsection "cdata_noxmlesc"
.Vb 2
\& $script = $svg\->script();
\& $script\->cdata_noxmlesc($text);
.Ve
.PP
Generates cdata content for text and similar tags which do not get xml-escaped.
In othe words, does not parse the content and inserts the exact string into the cdata location.
.SS "\s-1CDATA\s0"
.IX Subsection "CDATA"
.Vb 2
\& $script = $svg\->script();
\& $script\->CDATA($text);
.Ve
.PP
Generates a <![CDATA[ ... ]]> tag with the contents of \f(CW$text\fR rendered exactly as supplied. \s-1SVG\s0.pm allows you to set cdata for any tag. If the tag is
meant to be an empty tag, \s-1SVG\s0.pm will not complain, but the rendering agent will
fail. In the \s-1SVG\s0 \s-1DTD\s0, cdata is generally only meant for adding text or script
content.
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&      my $text = qqA\*^X
\&        var SVGDoc;
\&        var groups = new Array();
\&        var last_group;
\&
\&        /*****
\&        *
\&        *   init
\&        *
\&        *   Find this SVG\*(Aqs document element
\&        *   Define members of each group by id
\&        *
\&        *****/
\&        function init(e) {
\&            SVGDoc = e.getTarget().getOwnerDocument();
\&            append_group(1, 4, 6); // group 0
\&            append_group(5, 4, 3); // group 1
\&            append_group(2, 3);    // group 2
\&        }A\*^X;
\&        $svg\->script()\->CDATA($text);
.Ve
.PP
\&\fBResult:\fR
.PP
.Vb 5
\&    E<lt>script E<gt>
\&      <gt>![CDATA[
\&        var SVGDoc;
\&        var groups = new Array();
\&        var last_group;
\&
\&        /*****
\&        *
\&        *   init
\&        *
\&        *   Find this SVG\*(Aqs document element
\&        *   Define members of each group by id
\&        *
\&        *****/
\&        function init(e) {
\&            SVGDoc = e.getTarget().getOwnerDocument();
\&            append_group(1, 4, 6); // group 0
\&            append_group(5, 4, 3); // group 1
\&            append_group(2, 3);    // group 2
\&        }
\&        ]]E<gt>
.Ve
.PP
\&\s-1SEE\s0 \s-1ALSO:\s0
.PP
.Vb 1
\&  L<"cdata">, L<"script">.
.Ve
.SS "xmlescp and xmlescape"
.IX Subsection "xmlescp and xmlescape"
\&\f(CW$string\fR = \f(CW$svg\fR\->xmlescp($string)
\&\f(CW$string\fR = \f(CW$svg\fR\->xmlesc($string)
\&\f(CW$string\fR = \f(CW$svg\fR\->xmlescape($string)
.PP
\&\s-1SVG\s0 module does not xml-escape characters that are incompatible with the \s-1XML\s0 specification. \fBxmlescp\fR and \fBxmlescape\fR provides this functionality. It is a helper function which generates an XML-escaped string for reserved characters such as ampersand, open and close brackets, etcetera.
.PP
The behaviour of xmlesc is to apply the following transformation to the input string \f(CW$s:\fR
.PP
.Vb 7
\&    $s=~s/&(?!#(x\ew\ew|\ed+?);)/&amp;/g;
\&    $s=~s/>/&gt;/g;
\&    $s=~s/</&lt;/g;
\&    $s=~s/\e"/&quot;/g;
\&    $s=~s/\e\*(Aq/&apos;/g;
\&    $s=~s/([\ex00\-\ex08\ex0b\ex1f])/\*(Aq\*(Aq/eg;
\&    $s=~s/([\e200\-\e377])/\*(Aq&#\*(Aq.ord($1).\*(Aq;\*(Aq/ge;
.Ve
.SS "filter"
.IX Subsection "filter"
\&\f(CW$tag\fR = \f(CW$svg\fR\->filter(%attributes)
.PP
Generate a filter. Filter elements contain \*(L"fe\*(R" filter sub-elements.
.PP
\&\fBExample:\fR
.PP
.Vb 8
\&    my $filter = $svg\->filter(
\&        filterUnits=>"objectBoundingBox",
\&        x=>"\-10%",
\&        y=>"\-10%",
\&        width=>"150%",
\&        height=>"150%",
\&        filterUnits=>\*(AqobjectBoundingBox\*(Aq
\&    );
\&
\&    $filter\->fe();
.Ve
.PP
\&\s-1SEE\s0 \s-1ALSO:\s0
.PP
\&\*(L"fe\*(R".
.SS "fe"
.IX Subsection "fe"
\&\f(CW$tag\fR = \f(CW$svg\fR\->fe(\-type=>'type', \f(CW%attributes\fR)
.PP
Generate a filter sub-element. Must be a child of a \*(L"filter\*(R" element.
.PP
\&\fBExample:\fR
.PP
.Vb 10
\&    my $fe = $svg\->fe(
\&        \-type     => \*(AqDiffuseLighting\*(Aq  # required \- element name omiting \*(Aqfe\*(Aq
\&        id        => \*(Aqfilter_1\*(Aq,
\&        style     => {
\&            \*(Aqfont\*(Aq      => [ qw(Arial Helvetica sans) ],
\&            \*(Aqfont\-size\*(Aq => 10,
\&            \*(Aqfill\*(Aq      => \*(Aqred\*(Aq,
\&        },
\&        transform => \*(Aqrotate(\-45)\*(Aq
\&    );
.Ve
.PP
Note that the following filter elements are currently supported:
.SS "* feBlend"
.IX Subsection "* feBlend"
.SS "* feColorMatrix"
.IX Subsection "* feColorMatrix"
.SS "* feComponentTransfer"
.IX Subsection "* feComponentTransfer"
.SS "* feComposite"
.IX Subsection "* feComposite"
.SS "* feConvolveMatrix"
.IX Subsection "* feConvolveMatrix"
.SS "* feDiffuseLighting"
.IX Subsection "* feDiffuseLighting"
.SS "* feDisplacementMap"
.IX Subsection "* feDisplacementMap"
.SS "* feDistantLight"
.IX Subsection "* feDistantLight"
.SS "* feFlood"
.IX Subsection "* feFlood"
.SS "* feFuncA"
.IX Subsection "* feFuncA"
.SS "* feFuncB"
.IX Subsection "* feFuncB"
.SS "* feFuncG"
.IX Subsection "* feFuncG"
.SS "* feFuncR"
.IX Subsection "* feFuncR"
.SS "* feGaussianBlur"
.IX Subsection "* feGaussianBlur"
.SS "* feImage"
.IX Subsection "* feImage"
.SS "* feMerge"
.IX Subsection "* feMerge"
.SS "* feMergeNode"
.IX Subsection "* feMergeNode"
.SS "* feMorphology"
.IX Subsection "* feMorphology"
.SS "* feOffset"
.IX Subsection "* feOffset"
.SS "* fePointLight"
.IX Subsection "* fePointLight"
.SS "* feSpecularLighting"
.IX Subsection "* feSpecularLighting"
.SS "* feSpotLight"
.IX Subsection "* feSpotLight"
.SS "* feTile"
.IX Subsection "* feTile"
.SS "* feTurbulence"
.IX Subsection "* feTurbulence"
\&\s-1SEE\s0 \s-1ALSO:\s0
.PP
\&\*(L"filter\*(R".
.SS "pattern"
.IX Subsection "pattern"
\&\f(CW$tag\fR = \f(CW$svg\fR\->pattern(%attributes)
.PP
Define a pattern for later reference by url.
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $pattern = $svg\->pattern(
\&        id     => "Argyle_1",
\&        width  => "50",
\&        height => "50",
\&        patternUnits        => "userSpaceOnUse",
\&        patternContentUnits => "userSpaceOnUse"
\&    );
.Ve
.SS "set"
.IX Subsection "set"
\&\f(CW$tag\fR = \f(CW$svg\fR\->set(%attributes)
.PP
Set a definition for an \s-1SVG\s0 object in one section, to be referenced in other
sections as needed.
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&    my $set = $svg\->set(
\&        id     => "Argyle_1",
\&        width  => "50",
\&        height => "50",
\&        patternUnits        => "userSpaceOnUse",
\&        patternContentUnits => "userSpaceOnUse"
\&    );
.Ve
.SS "stop"
.IX Subsection "stop"
\&\f(CW$tag\fR = \f(CW$svg\fR\->stop(%attributes)
.PP
Define a stop boundary for \*(L"gradient\*(R"
.PP
\&\fBExample:\fR
.PP
.Vb 7
\&   my $pattern = $svg\->stop(
\&       id     => "Argyle_1",
\&       width  => "50",
\&       height => "50",
\&       patternUnits        => "userSpaceOnUse",
\&       patternContentUnits => "userSpaceOnUse"
\&   );
.Ve
.PP
\&\f(CW$tag\fR = \f(CW$svg\fR\->gradient(%attributes)
.PP
Define a color gradient. Can be of type \fBlinear\fR or \fBradial\fR
.PP
\&\fBExample:\fR
.PP
.Vb 4
\&    my $gradient = $svg\->gradient(
\&        \-type => "linear",
\&        id    => "gradient_1"
\&    );
.Ve
.SH "GENERIC ELEMENT METHODS"
.IX Header "GENERIC ELEMENT METHODS"
The following elements are generically supported by \s-1SVG:\s0
.SS "* altGlyph"
.IX Subsection "* altGlyph"
.SS "* altGlyphDef"
.IX Subsection "* altGlyphDef"
.SS "* altGlyphItem"
.IX Subsection "* altGlyphItem"
.SS "* clipPath"
.IX Subsection "* clipPath"
.SS "* color-profile"
.IX Subsection "* color-profile"
.SS "* cursor"
.IX Subsection "* cursor"
.SS "* definition-src"
.IX Subsection "* definition-src"
.SS "* font-face-format"
.IX Subsection "* font-face-format"
.SS "* font-face-name"
.IX Subsection "* font-face-name"
.SS "* font-face-src"
.IX Subsection "* font-face-src"
.SS "* font-face-url"
.IX Subsection "* font-face-url"
.SS "* foreignObject"
.IX Subsection "* foreignObject"
.SS "* glyph"
.IX Subsection "* glyph"
.SS "* glyphRef"
.IX Subsection "* glyphRef"
.SS "* hkern"
.IX Subsection "* hkern"
.SS "* marker"
.IX Subsection "* marker"
.SS "* mask"
.IX Subsection "* mask"
.SS "* metadata"
.IX Subsection "* metadata"
.SS "* missing-glyph"
.IX Subsection "* missing-glyph"
.SS "* mpath"
.IX Subsection "* mpath"
.SS "* switch"
.IX Subsection "* switch"
.SS "* symbol"
.IX Subsection "* symbol"
.SS "* tref"
.IX Subsection "* tref"
.SS "* view"
.IX Subsection "* view"
.SS "* vkern"
.IX Subsection "* vkern"
See e.g. \*(L"pattern\*(R" for an example of the use of these methods.
.SH "METHODS IMPORTED BY SVG::DOM"
.IX Header "METHODS IMPORTED BY SVG::DOM"
The following \s-1SVG::DOM\s0 elements are accessible through \s-1SVG:\s0
.SS "* getChildren"
.IX Subsection "* getChildren"
.SS "* getFirstChild"
.IX Subsection "* getFirstChild"
.SS "* getNextChild"
.IX Subsection "* getNextChild"
.SS "* getLastChild"
.IX Subsection "* getLastChild"
.SS "* getParent"
.IX Subsection "* getParent"
.SS "* getParentElement"
.IX Subsection "* getParentElement"
.SS "* getSiblings"
.IX Subsection "* getSiblings"
.SS "* getElementByID"
.IX Subsection "* getElementByID"
.SS "* getElementID"
.IX Subsection "* getElementID"
.SS "* getElements"
.IX Subsection "* getElements"
.SS "* getElementName"
.IX Subsection "* getElementName"
.SS "* getType"
.IX Subsection "* getType"
.SS "* getAttributes"
.IX Subsection "* getAttributes"
.SS "* getAttribute"
.IX Subsection "* getAttribute"
.SS "* setAttributes"
.IX Subsection "* setAttributes"
.SS "* setAttribute"
.IX Subsection "* setAttribute"
.SS "* insertBefore"
.IX Subsection "* insertBefore"
.SS "* insertAfter"
.IX Subsection "* insertAfter"
.SS "* insertSiblingBefore"
.IX Subsection "* insertSiblingBefore"
.SS "* insertSiblingAfter"
.IX Subsection "* insertSiblingAfter"
.SS "* replaceChild"
.IX Subsection "* replaceChild"
.SS "* removeChild"
.IX Subsection "* removeChild"
.SS "* cloneNode"
.IX Subsection "* cloneNode"
.SH "Methods"
.IX Header "Methods"
\&\s-1SVG\s0 provides both explicit and generic element constructor methods. Explicit
generators are generally (with a few exceptions) named for the element they
generate. If a tag method is required for a tag containing hyphens, the method
name replaces the hyphen with an underscore. ie: to generate tag <column\-heading id=\*(L"new\*(R">
you would use method \f(CW$svg\fR\->column_heading(id=>'new').
.PP
All element constructors take a hash of element attributes and options;
element attributes such as 'id' or 'border' are passed by name, while options for the
method (such as the type of an element that supports multiple alternate forms)
are passed preceded by a hyphen, e.g '\-type'. Both types may be freely
intermixed; see the \*(L"fe\*(R" method and code examples througout the documentation
for more examples.
.SS "new (constructor)"
.IX Subsection "new (constructor)"
\&\f(CW$svg\fR = \s-1SVG\-\s0>new(%attributes)
.PP
Creates a new \s-1SVG\s0 object. Attributes of the document \s-1SVG\s0 element be passed as
an optional list of key value pairs. Additionally, \s-1SVG\s0 options (prefixed with
a hyphen) may be set on a per object basis:
.PP
\&\fBExample:\fR
.PP
.Vb 1
\&    my $svg1 = SVG\->new;
\&
\&    my $svg2 = SVG\->new(id => \*(Aqdocument_element\*(Aq);
\&
\&    my $svg3 = SVG\->new(
\&        \-printerror => 1,
\&        \-raiseerror => 0,
\&        \-indent     => \*(Aq  \*(Aq,
\&        \-elsep      => "\en",  # element line (vertical) separator
\&        \-docroot    => \*(Aqsvg\*(Aq, # default document root element (SVG specification assumes svg). Defaults to \*(Aqsvg\*(Aq if undefined
\&        \-xml_xlink  => \*(Aqhttp://www.w3.org/1999/xlink\*(Aq, # required by Mozilla\*(Aqs embedded SVG engine
\&        \-sysid      => \*(Aqabc\*(Aq, # optional system identifier
\&        \-pubid      => "\-//W3C//DTD SVG 1.0//EN", # public identifier default value is "\-//W3C//DTD SVG 1.0//EN" if undefined
\&        \-namespace  => \*(Aqmysvg\*(Aq,
\&        \-inline     => 1
\&        id          => \*(Aqdocument_element\*(Aq,
\&        width       => 300,
\&        height      => 200,
\&    );
.Ve
.PP
Default \s-1SVG\s0 options may also be set in the import list. See \*(L"\s-1EXPORTS\s0\*(R" above
for more on the available options.
.PP
Furthermore, the following options:
.PP
.Vb 7
\&    \-version
\&    \-encoding
\&    \-standalone
\&    \-namespace
\&    \-inline
\&    \-pubid (formerly \-identifier)
\&    \-sysid (standalone)
.Ve
.PP
may also be set in xmlify, overriding any corresponding values set in the \s-1SVG\-\s0>new declaration
.SS "xmlify  (alias: to_xml render serialize serialise )"
.IX Subsection "xmlify  (alias: to_xml render serialize serialise )"
\&\f(CW$string\fR = \f(CW$svg\fR\->xmlify(%attributes);
.PP
Returns xml representation of svg document.
.PP
\&\fB\s-1XML\s0 Declaration\fR
.PP
.Vb 11
\&    Name               Default Value
\&    \-version           \*(Aq1.0\*(Aq
\&    \-encoding          \*(AqUTF\-8\*(Aq
\&    \-standalone        \*(Aqyes\*(Aq
\&    \-namespace         \*(Aqsvg\*(Aq \- namespace prefix for elements.
\&                               Can also be used in any element method to over\-ride
\&                               the current namespace prefix. Make sure to have
\&                               declared the prefix before using it.
\&    \-inline            \*(Aq0\*(Aq \- If \*(Aq1\*(Aq, then this is an inline document.
\&    \-pubid             \*(Aq\-//W3C//DTD SVG 1.0//EN\*(Aq;
\&    \-sysid             \*(Aqhttp://www.w3.org/TR/2001/REC\-SVG\-20010904/DTD/svg10.dtd\*(Aq
.Ve
.SS "perlify ()"
.IX Subsection "perlify ()"
return the perl code which generates the \s-1SVG\s0 document as it currently exists.
.SS "toperl ()"
.IX Subsection "toperl ()"
Alias for method \fIperlify()\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
Ronan Oger, \s-1RO\s0 \s-1IT\s0 Systemms GmbH, cpan@roitsystems.com
.SH "MAINTAINER"
.IX Header "MAINTAINER"
Gabor Szabo <http://szabgab.com/>
.SH "CREDITS"
.IX Header "CREDITS"
I would like to thank the following people for contributing to this module with
patches, testing, suggestions, and other nice tidbits:
.PP
Peter Wainwright, Excellent ideas, beta-testing, writing SVG::Parser and much of \s-1SVG::DOM\s0.
Fredo, http://www.penguin.at0.net/~fredo/ \- provided example code and initial feedback for early \s-1SVG\s0.pm versions and the idea of a simplified svg generator.
Adam Schneider,
Brial PilprA\*~X,
Ian Hickson
Steve Lihn,
Allen Day
Martin Owens \- \s-1SVG::DOM\s0 improvements in version 3.34
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2001\- Ronan Oger
.PP
The modules in the \s-1SVG\s0 distribution are distributed under the same license
as Perl itself. It is provided free of warranty and may be re-used freely.
.SH "ARTICLES"
.IX Header "ARTICLES"
\&\s-1SVG\s0 using Perl <http://szabgab.com/svg-using-perl.html>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\s-1SVG::DOM\s0,
\&\s-1SVG::XML\s0,
SVG::Element,
SVG::Parser,
SVG::Extension
.PP
Serverside \s-1SVG\s0 Portal \- Perl focused \s-1SVG\s0 site with discussion board and examples:
<http://www.perlsvg.com/>
For Commercial Perl/SVG development, refer to the following sites:
\&\s-1ROASP\s0.com: Serverside \s-1SVG\s0 server <http://www.roitsystems.com/>,
\&\s-1ROIT\s0 Systems: Commercial \s-1SVG\s0 perl solutions <http://www.roitsystems.com/>,
\&\s-1SVG\s0 at the W3C <http://www.w3c.org/Graphics/SVG/>
.SH "EXPERIMENTAL POD"
.IX Header "EXPERIMENTAL POD"
