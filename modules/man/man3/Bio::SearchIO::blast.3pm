.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::SearchIO::blast 3pm"
.TH Bio::SearchIO::blast 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::SearchIO::blast \- Event generator for event based parsing of
blast reports
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   # Do not use this object directly \- it is used as part of the
\&   # Bio::SearchIO system.
\&
\&    use Bio::SearchIO;
\&    my $searchio = Bio::SearchIO\->new(\-format => \*(Aqblast\*(Aq,
\&                                     \-file   => \*(Aqt/data/ecolitst.bls\*(Aq);
\&    while( my $result = $searchio\->next_result ) {
\&        while( my $hit = $result\->next_hit ) {
\&            while( my $hsp = $hit\->next_hsp ) {
\&                # ...
\&            }
\&        }
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object encapsulated the necessary methods for generating events
suitable for building Bio::Search objects from a \s-1BLAST\s0 report file.
Read the Bio::SearchIO for more information about how to use this.
.PP
This driver can parse:
.IP "\(bu" 4
\&\s-1NCBI\s0 produced plain text \s-1BLAST\s0 reports from blastall, this also
includes \s-1PSIBLAST, PSITBLASTN, RPSBLAST,\s0 and bl2seq reports.  \s-1NCBI XML
BLAST\s0 output is parsed with the blastxml SearchIO driver
.IP "\(bu" 4
WU-BLAST all reports
.IP "\(bu" 4
Jim Kent's BLAST-like output from his programs (\s-1BLASTZ, BLAT\s0)
.IP "\(bu" 4
BLAST-like output from Paracel \s-1BTK\s0 output
.SS "bl2seq parsing"
.IX Subsection "bl2seq parsing"
Since I cannot differentiate between \s-1BLASTX\s0 and \s-1TBLASTN\s0 since bl2seq
doesn't report the algorithm used \- I assume it is \s-1BLASTX\s0 by default \-
you can supply the program type with \-report_type in the SearchIO
constructor i.e.
.PP
.Vb 3
\&  my $parser = Bio::SearchIO\->new(\-format => \*(Aqblast\*(Aq,
\&                                 \-file => \*(Aqbl2seq.tblastn.report\*(Aq,
\&                                 \-report_type => \*(Aqtblastn\*(Aq);
.Ve
.PP
This only really affects where the frame and strand information are
put \- they will always be on the \f(CW$hsp\fR\->query instead of on the
\&\f(CW$hsp\fR\->hit part of the feature pair for blastx and tblastn bl2seq
produced reports.  Hope that's clear...
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and
reponsive experts will be able look at the problem and quickly
address it. Please include a thorough description of the problem
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Jason Stajich"
.IX Header "AUTHOR - Jason Stajich"
Email Jason Stajich jason\-at\-bioperl.org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Steve Chervitz sac\-at\-bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : my $obj = Bio::SearchIO::blast\->new(%args);
\& Function: Builds a new Bio::SearchIO::blast object
\& Returns : Bio::SearchIO::blast
\& Args    : Key\-value pairs:
\&           \-fh/\-file => filehandle/filename to BLAST file
\&           \-format   => \*(Aqblast\*(Aq
\&           \-report_type => \*(Aqblastx\*(Aq, \*(Aqtblastn\*(Aq, etc \-\- only for bl2seq
\&                           reports when you want to distinguish between
\&                           tblastn and blastx reports (this only controls
\&                           where the frame information is put \- on the query
\&                           or subject object.
\&           \-inclusion_threshold => e\-value threshold for inclusion in the
\&                                   PSI\-BLAST score matrix model (blastpgp)
\&           \-signif      => float or scientific notation number to be used
\&                           as a P\- or Expect value cutoff
\&           \-score       => integer or scientific notation number to be used
\&                           as a blast score value cutoff
\&           \-bits        => integer or scientific notation number to be used
\&                           as a bit score value cutoff
\&           \-hit_filter  => reference to a function to be used for
\&                           filtering hits based on arbitrary criteria.
\&                           All hits of each BLAST report must satisfy
\&                           this criteria to be retained.
\&                           If a hit fails this test, it is ignored.
\&                           This function should take a
\&                           Bio::Search::Hit::BlastHit.pm object as its first
\&                           argument and return true
\&                           if the hit should be retained.
\&                           Sample filter function:
\&                              \-hit_filter => sub { $hit = shift;
\&                                                   $hit\->gaps == 0; },
\&                           (Note: \-filt_func is synonymous with \-hit_filter)
\&           \-overlap     => integer. The amount of overlap to permit between
\&                           adjacent HSPs when tiling HSPs. A reasonable value is 2.
\&                           Default = $Bio::SearchIO::blast::MAX_HSP_OVERLAP.
\&
\&            The following criteria are not yet supported:
\&            (these are probably best applied within this module rather than in the
\&             event handler since they would permit the parser to take some shortcuts.)
\&
\&           \-check_all_hits => boolean. Check all hits for significance against
\&                              significance criteria.  Default = false.
\&                              If false, stops processing hits after the first
\&                              non\-significant hit or the first hit that fails
\&                              the hit_filter call. This speeds parsing,
\&                              taking advantage of the fact that the hits
\&                              are processed in the order they appear in the report.
\&           \-min_query_len => integer to be used as a minimum for query sequence length.
\&                             Reports with query sequences below this length will
\&                             not be processed. Default = no minimum length.
\&           \-best        => boolean. Only process the best hit of each report;
\&                           default = false.
.Ve
.SS "next_result"
.IX Subsection "next_result"
.Vb 5
\& Title   : next_result
\& Usage   : my $hit = $searchio\->next_result;
\& Function: Returns the next Result from a search
\& Returns : Bio::Search::Result::ResultI object
\& Args    : none
.Ve
.SS "_will_handle"
.IX Subsection "_will_handle"
.Vb 8
\& Title   : _will_handle
\& Usage   : Private method. For internal use only.
\&              if( $self\->_will_handle($type) ) { ... }
\& Function: Provides an optimized way to check whether or not an element of a
\&           given type is to be handled.
\& Returns : Reference to EventHandler object if the element type is to be handled.
\&           undef if the element type is not to be handled.
\& Args    : string containing type of element.
.Ve
.PP
Optimizations:
.IP "1." 2
Using the cached pointer to the EventHandler to minimize repeated
lookups.
.IP "2." 2
Caching the will_handle status for each type that is encountered so
that it only need be checked by calling
handler\->will_handle($type) once.
.PP
This does not lead to a major savings by itself (only 5\-10%).  In
combination with other optimizations, or for large parse jobs, the
savings good be significant.
.PP
To test against the unoptimized version, remove the parentheses from
around the third term in the ternary \*(L" ? : \*(R" operator and add two
calls to \f(CW$self\fR\->\fB_eventHandler()\fR.
.SS "start_element"
.IX Subsection "start_element"
.Vb 5
\& Title   : start_element
\& Usage   : $eventgenerator\->start_element
\& Function: Handles a start element event
\& Returns : none
\& Args    : hashref with at least 2 keys \*(AqData\*(Aq and \*(AqName\*(Aq
.Ve
.SS "end_element"
.IX Subsection "end_element"
.Vb 5
\& Title   : end_element
\& Usage   : $eventgenerator\->end_element
\& Function: Handles an end element event
\& Returns : hashref with an element\*(Aqs worth of data
\& Args    : hashref with at least 2 keys \*(AqData\*(Aq and \*(AqName\*(Aq
.Ve
.SS "element"
.IX Subsection "element"
.Vb 5
\& Title   : element
\& Usage   : $eventhandler\->element({\*(AqName\*(Aq => $name, \*(AqData\*(Aq => $str});
\& Function: Convenience method that calls start_element, characters, end_element
\& Returns : none
\& Args    : Hash ref with the keys \*(AqName\*(Aq and \*(AqData\*(Aq
.Ve
.SS "characters"
.IX Subsection "characters"
.Vb 5
\& Title   : characters
\& Usage   : $eventgenerator\->characters($str)
\& Function: Send a character events
\& Returns : none
\& Args    : string
.Ve
.SS "within_element"
.IX Subsection "within_element"
.Vb 7
\& Title   : within_element
\& Usage   : if( $eventgenerator\->within_element($element) ) {}
\& Function: Test if we are within a particular element
\&           This is different than \*(Aqin\*(Aq because within can be tested
\&           for a whole block.
\& Returns : boolean
\& Args    : string element name
.Ve
.PP
See Also: in_element
.SS "in_element"
.IX Subsection "in_element"
.Vb 7
\& Title   : in_element
\& Usage   : if( $eventgenerator\->in_element($element) ) {}
\& Function: Test if we are in a particular element
\&           This is different than \*(Aqwithin_element\*(Aq because within
\&           can be tested for a whole block.
\& Returns : boolean
\& Args    : string element name
.Ve
.PP
See Also: within_element
.SS "start_document"
.IX Subsection "start_document"
.Vb 5
\& Title   : start_document
\& Usage   : $eventgenerator\->start_document
\& Function: Handle a start document event
\& Returns : none
\& Args    : none
.Ve
.SS "end_document"
.IX Subsection "end_document"
.Vb 5
\& Title   : end_document
\& Usage   : $eventgenerator\->end_document
\& Function: Handles an end document event
\& Returns : Bio::Search::Result::ResultI object
\& Args    : none
.Ve
.SS "inclusion_threshold"
.IX Subsection "inclusion_threshold"
.Vb 9
\& Title   : inclusion_threshold
\& Usage   : my $incl_thresh = $isreb\->inclusion_threshold;
\&         : $isreb\->inclusion_threshold(1e\-5);
\& Function: Get/Set the e\-value threshold for inclusion in the PSI\-BLAST
\&           score matrix model (blastpgp) that was used for generating the reports
\&           being parsed.
\& Returns : number (real)
\&           Default value: $Bio::SearchIO::IteratedSearchResultEventBuilder::DEFAULT_INCLUSION_THRESHOLD
\& Args    : number (real)  (e.g., 0.0001 or 1e\-4 )
.Ve
.SS "max_significance"
.IX Subsection "max_significance"
.Vb 9
\& Usage     : $obj\->max_significance();
\& Purpose   : Set/Get the P or Expect value used as significance screening cutoff.
\&             This is the value of the \-signif parameter supplied to new().
\&             Hits with P or E\-value above this are skipped.
\& Returns   : Scientific notation number with this format: 1.0e\-05.
\& Argument  : Scientific notation number or float (when setting)
\& Comments  : Screening of significant hits uses the data provided on the
\&           : description line. For NCBI BLAST1 and WU\-BLAST, this data
\&           : is P\-value. for NCBI BLAST2 it is an Expect value.
.Ve
.SS "signif"
.IX Subsection "signif"
Synonym for \fBmax_significance()\fR
.SS "min_score"
.IX Subsection "min_score"
.Vb 8
\& Usage     : $obj\->min_score();
\& Purpose   : Set/Get the Blast score used as screening cutoff.
\&             This is the value of the \-score parameter supplied to new().
\&             Hits with scores below this are skipped.
\& Returns   : Integer or scientific notation number.
\& Argument  : Integer or scientific notation number (when setting)
\& Comments  : Screening of significant hits uses the data provided on the
\&           : description line.
.Ve
.SS "min_query_length"
.IX Subsection "min_query_length"
.Vb 6
\& Usage     : $obj\->min_query_length();
\& Purpose   : Gets the query sequence length used as screening criteria.
\&             This is the value of the \-min_query_len parameter supplied to new().
\&             Hits with sequence length below this are skipped.
\& Returns   : Integer
\& Argument  : n/a
.Ve
.SS "best_hit_only"
.IX Subsection "best_hit_only"
.Vb 6
\& Title     : best_hit_only
\& Usage     : print "only getting best hit.\en" if $obj\->best_hit_only;
\& Purpose   : Set/Get the indicator for whether or not to process only
\&           : the best BlastHit.
\& Returns   : Boolean (1 | 0)
\& Argument  : Boolean (1 | 0) (when setting)
.Ve
.SS "check_all_hits"
.IX Subsection "check_all_hits"
.Vb 8
\& Title     : check_all_hits
\& Usage     : print "checking all hits.\en" if $obj\->check_all_hits;
\& Purpose   : Set/Get the indicator for whether or not to process all hits.
\&           : If false, the parser will stop processing hits after the
\&           : the first non\-significance hit or the first hit that fails
\&           : any hit filter.
\& Returns   : Boolean (1 | 0)
\& Argument  : Boolean (1 | 0) (when setting)
.Ve
