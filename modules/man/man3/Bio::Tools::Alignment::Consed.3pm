.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Alignment::Consed 3pm"
.TH Bio::Tools::Alignment::Consed 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Tools::Alignment::Consed \- A module to work with objects from consed .ace files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&  # a report for sequencing stuff
\&  my $o_consed = Bio::Tools::Alignment::Consed\->new( 
\&      \-acefile => "/path/to/an/acefile.ace.1",
\&      \-verbose => 1);
\&  my $foo = $o_consed\->set_reverse_designator("r");
\&  my $bar = $o_consed\->set_forward_designator("f");
\&
\&  # get the contig numbers
\&  my @keys = $o_consed\->get_contigs();
\&
\&  # construct the doublets
\&  my $setter_doublets = $o_consed\->choose_doublets();
\&
\&  # get the doublets
\&  my @doublets = $o_consed\->get_doublets();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Tools::Alignment::Consed provides methods and objects to deal
with the output from the Consed software suite. Specifically,
takes an \f(CW\*(C`.ace\*(C'\fR file and provides objects for the results.
.PP
A word about doublets: This module was written to accommodate a large
\&\s-1EST\s0 sequencing operation. In this case, \s-1EST\s0's were sequenced from the
3' and from the 5' end of the \s-1EST.\s0 The objective was to find a
consensus sequence for these two reads.  Thus, a contig of two is what
we wanted, and this contig should consist of the forward and reverse
reads of a getn clone. For example, for a forward designator of \*(L"F\*(R"
and a reverse designator of \*(L"R\*(R", if the two reads chad1F and chad1R
were in a single contig (for example Contig 5) it will be determined
that the consensus sequence for Contig 5 will be the sequence for
clone chad1.
.PP
Doublets are good!
.PP
This module parses \f(CW\*(C`.ace\*(C'\fR and related files. A detailed list of methods
can be found at the end of this document.
.PP
I wrote a detailed rationale for design that may explain the reasons
why some things were done the way they were done. That document is
beyond the scope of this pod and can probably be found in the
directory from which this module was 'made' or at
<http://www.dieselwurks.com/bioinformatics/consedpm_documentation.pdf>.
.PP
Note that the \s-1POD\s0 in that document might be old but the original
rationale still stands.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Chad Matsalla"
.IX Header "AUTHOR - Chad Matsalla"
Email chad\-at\-dieselwurks.com
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "\fBnew()\fP"
.IX Subsection "new()"
.Vb 7
\& Title   : new(\-acefile => $path_to_some_acefile, \-verbose => "1")
\& Usage   : $o_consed = Bio::Tools::Alignment::Consed\->
\&              new(\-acefile => $path_to_some_acefile, \-verbose => "1");
\& Function: Construct the Bio::Tools::Alignment::Consed object. Sets
\&           verbosity for the following procedures, if necessary:
\&           1. Construct a new Bio::Tools::Alignment::Trim object, to
\&           handle quality trimming 2. Read in the acefile and parse it
\&
\& Returns : A reference to a Bio::Tools::Alignment::Consed object.
\& Args    : A hash. (\-acefile) is the filename of an acefile. If a full path
\&           is not specified "./" is prepended to the filename and used from
\&           instantiation until destruction. If you want 
\&           Bio::Tools::Alignment::Consed to be noisy during parsing of
\&           the acefile, specify some value for (\-verbose).
.Ve
.SS "\fBset_verbose()\fP"
.IX Subsection "set_verbose()"
.Vb 11
\& Title   : set_verbose()
\& Usage   : $o_consed\->set_verbose(1);
\& Function: Set the verbosity level for debugging messages. On instantiation
\&           of the Bio::Tools::Alignment::Consed object the verbosity level
\&           is set to 0 (quiet).
\& Returns : 1 or 0.
\& Args    : The verbosity levels are:
\&              0 \- quiet
\&              1 \- noisy
\&              2 \- noisier
\&              3 \- annoyingly noisy
.Ve
.PP
This method for setting verbosity has largely been superseded by a
sub-by-sub way, where for every sub you can provide a (\-verbose)
switch. I am doing converting this bit-by-bit so do not be surprised
if some subs do not honour this.
.SS "\fBget_filename()\fP"
.IX Subsection "get_filename()"
.Vb 6
\& Title   : get_filename()
\& Usage   : $o_consed\->get_filename();
\& Function: Returns the name of the acefile being used by the
\&           Bio::Tools::Alignment::Consed object.
\& Returns : A scalar containing the name of a file.
\& Args    : None.
.Ve
.SS "\fBcount_sequences_with_grep()\fP"
.IX Subsection "count_sequences_with_grep()"
.Vb 10
\& Title   : count_sequences_with_grep()
\& Usage   : $o_consed\->count_sequences_with_grep();
\& Function: Use /bin/grep to scan through the files in the ace project dir
\&           and count sequences in those files. I used this method in the
\&           development of this module to verify that I was getting all of the
\&           sequences. It works, but it is (I think) unix\-like platform
\&           dependent.
\& Returns : A scalar containing the number of sequences in the ace project
\&           directory.
\& Args    : None.
.Ve
.PP
If you are on a non-UNIX platform, you really do not have to use
this. It is more of a debugging routine designed to address very
specific problems.
.PP
This method was reimplemented to be platform independent with a pure
perl implementation.  The above note can be ignored.
.SS "\fBget_path()\fP"
.IX Subsection "get_path()"
.Vb 5
\& Title   : get_path()
\& Usage   : $o_consed\->get_path();
\& Function: Returns the path to the acefile this object is working with.
\& Returns : Scalar. The path to the working acefile.
\& Args    : None.
.Ve
.SS "\fBget_contigs()\fP"
.IX Subsection "get_contigs()"
.Vb 6
\& Title   : get_contigs()
\& Usage   : $o_consed\->get_contigs();
\& Function: Return the keys to the Bio::Tools::Alignment::Consed object.
\& Returns : An array containing the keynames in the
\&           Bio::Tools::Alignment::Consed object.
\& Args    : None.
.Ve
.PP
This would normally be used to get the keynames for some sort of
iterator. These keys are worthless in general day-to-day use because
in the Consed acefile they are simply Contig1, Contig2, ...
.SS "get_class($contig_keyname)"
.IX Subsection "get_class($contig_keyname)"
.Vb 6
\& Title   : get_class($contig_keyname)
\& Usage   : $o_consed\->get_class($contig_keyname);
\& Function: Return the class name for this contig
\& Returns : A scalar representing the class of this contig.
\& Args    : None.
\& Notes   :
.Ve
.SS "get_quality_array($contig_keyname)"
.IX Subsection "get_quality_array($contig_keyname)"
.Vb 8
\& Title   : get_quality_array($contig_keyname)
\& Usage   : $o_consed\->get_quality_array($contig_keyname);
\& Function: Returns the quality for the consensus sequence for the given
\&           contig as an array. See get_quality_scalar to get this as a scalar.
\& Returns : An array containing the quality for the consensus sequence with
\&           the given keyname.
\& Args    : The keyname of a contig. Note: This is a keyname. The key would
\&           normally come from get_contigs.
.Ve
.PP
Returns an array, not a reference. Is this a bug? \fIthinking\fR No.
Well, maybe.  Why was this developed like this? I was using FreezeThaw
for object persistence, and when it froze out these arrays it took a
long time to thaw it. Much better as a scalar.
.PP
See \fBget_quality_scalar()\fR
.SS "get_quality_scalar($contig_keyname)"
.IX Subsection "get_quality_scalar($contig_keyname)"
.Vb 8
\& Title   : get_quality_scalar($contig_keyname)
\& Usage   : $o_consed\->get_quality_scalar($contig_keyname);
\& Function: Returns the quality for the consensus sequence for the given
\&           contig as a scalar. See get_quality_array to get this as an array.
\& Returns : An scalar containing the quality for the consensus sequence with
\&           the given keyname.
\& Args    : The keyname of a contig. Note this is a _keyname_. The key would
\&           normally come from get_contigs.
.Ve
.PP
Why was this developed like this? I was using FreezeThaw for object
persistence, and when it froze out these arrays it took a coon's age
to thaw it. Much better as a scalar.
.PP
See \fBget_quality_array()\fR
.SS "\fBfreeze_hash()\fP"
.IX Subsection "freeze_hash()"
.Vb 2
\& Title   : freeze_hash()
\& Usage   : $o_consed\->freeze_hash();
\&
\& Function: Use Ilya\*(Aqs FreezeThaw module to create a persistent data
\&           object for this Bio::Tools::Alignment::Consed data
\&           structure. In the case of AAFC, we use
\&           Bio::Tools::Alignment::Consed to pre\-process bunches of
\&           sequences, freeze the structures, and send in a harvesting
\&           robot later to do database stuff.
\& Returns : 0 or 1;
\& Args    : None.
.Ve
.PP
This procedure was removed so Consed.pm won't require FreezeThaw.
.SS "get_members($contig_keyname)"
.IX Subsection "get_members($contig_keyname)"
.Vb 6
\& Title   : get_members($contig_keyname)
\& Usage   : $o_consed\->get_members($contig_keyname);
\& Function: Return the _names_ of the reads in this contig.
\& Returns : An array containing the names of the reads in this contig.
\& Args    : The keyname of a contig. Note this is a keyname. The keyname
\&           would normally come from get_contigs.
.Ve
.PP
See \fBget_contigs()\fR
.SS "get_members_by_name($some_arbitrary_name)"
.IX Subsection "get_members_by_name($some_arbitrary_name)"
.Vb 8
\& Title   : get_members_by_name($some_arbitrary_name)
\& Usage   : $o_consed\->get_members_by_name($some_arbitrary_name);
\& Function: Return the names of the reads in a contig. This is the name given
\&           to $contig{key} based on what is in the contig. This is different
\&           from the keys retrieved through get_contigs().
\& Returns : An array containing the names of the reads in the contig with this
\&           name.
\& Args    : The name of a contig. Not a key, but a name.
.Ve
.PP
Highly inefficient. use some other method if possible.
See \fBget_contigs()\fR
.SS "get_contig_number_by_name($some_arbitrary_name)"
.IX Subsection "get_contig_number_by_name($some_arbitrary_name)"
.Vb 8
\& Title   : get_contig_number_by_name($some_arbitrary_name)
\& Usage   : $o_consed\->get_contig_number_by_name($some_arbitrary_name);
\& Function: Return the names of the reads in a contig. This is the name given
\&           to $contig{key} based on what is in the contig. This is different
\&           from the keys retrieved through get_contigs().
\& Returns : An array containing the names of the reads in the contig with this
\&           name.
\& Args    : The name of a contig. Not a key, but a name.
.Ve
.PP
See \fBget_contigs()\fR
.SS "get_sequence($contig_keyname)"
.IX Subsection "get_sequence($contig_keyname)"
.Vb 6
\& Title   : get_sequence($contig_keyname)
\& Usage   : $o_consed\->get_sequence($contig_keyname); 
\& Function: Returns the consensus sequence for a given contig.
\& Returns : A scalar containing a sequence.
\& Args    : The keyname of a contig. Note this is a key. The key would
\&           normally come from get_contigs.
.Ve
.PP
See \fBget_contigs()\fR
.SS "set_final_sequence($some_sequence)"
.IX Subsection "set_final_sequence($some_sequence)"
.Vb 6
\& Title   : set_final_sequence($name,$some_sequence)
\& Usage   : $o_consed\->set_final_sequence($name,$some_sequence);
\& Function: Provides a manual way to set the sequence for a given key in the
\&           contig hash. Rarely used.
\& Returns : 0 or 1;
\& Args    : The name (not the keyname) of a contig and an arbitrary string.
.Ve
.PP
A method with a questionable and somewhat mysterious origin. May raise
the dead or something like that.
.SS "\fB_read_file()\fP"
.IX Subsection "_read_file()"
.Vb 6
\& Title   : _read_file();
\& Usage   : _read_file();
\& Function: An internal subroutine used to read in an acefile and parse it
\&           into a Bio::Tools::Alignment::Consed object.
\& Returns : 0 or 1.
\& Args    : Nothing.
.Ve
.PP
This routine creates and saves the filhandle for reading the files in
{fh}
.SS "set_reverse_designator($some_string)"
.IX Subsection "set_reverse_designator($some_string)"
.Vb 8
\& Title   : set_reverse_designator($some_string)
\& Usage   : $o_consed\->set_reverse_designator($some_string);
\& Function: Set the designator for the reverse read of contigs in this
\&           Bio::Tools::Alignment::Consed object. Used to determine if
\&           contigs containing two reads can be named.
\& Returns : The value of $o_consed\->{reverse_designator} so you can check
\&           to see that it was set properly.
\& Args    : An arbitrary string.
.Ve
.PP
May be useful only to me. \fIshrug\fR
.SS "set_forward_designator($some_string)"
.IX Subsection "set_forward_designator($some_string)"
.Vb 8
\& Title   : set_forward_designator($some_string)
\& Usage   : $o_consed\->set_forward_designator($some_string);
\& Function: Set the designator for the forward read of contigs in this
\&           Bio::Tools::Alignment::Consed object. Used to determine if
\&           contigs containing two reads can be named.
\& Returns : The value of $o_consed\->{forward_designator} so you can check
\&           to see that it was set properly.
\& Args    : An arbitrary string.
.Ve
.PP
May be useful only to me. \fIshrug\fR
.ie n .SS "set_designator_ignore_case(""yes"")"
.el .SS "set_designator_ignore_case(``yes'')"
.IX Subsection "set_designator_ignore_case(yes)"
.Vb 5
\& Title   : set_designator_ignore_case("yes")
\& Usage   : $o_consed\->set_designator_ignore_case("yes");
\& Function: Deprecated.
\& Returns : Deprecated.
\& Args    : Deprecated.
.Ve
.PP
Deprecated. Really. Trust me.
.SS "\fBset_trim_points_singlets_and_singletons()\fP"
.IX Subsection "set_trim_points_singlets_and_singletons()"
.Vb 11
\& Title   : set_trim_points_singlets_and_singletons()
\& Usage   : $o_consed\->set_trim_points_singlets_and_singletons();
\& Function: Set the trim points for singlets and singletons based on
\&           quality.  Uses the Bio::Tools::Alignment::Trim object. Use
\&           at your own risk because the Bio::Tools::Alignment::Trim
\&           object was designed specifically for me and is mysterious
\&           in its ways. Every time somebody other then me uses it a
\&           swarm of locusts decends on a small Central American
\&           village so do not say you weren\*(Aqt warned.
\& Returns : Nothing.
\& Args    : None.
.Ve
.PP
Working on exceptions and warnings here.
.PP
See Bio::Tools::Alignment::Trim for more information
.SS "\fBset_trim_points_doublets()\fP"
.IX Subsection "set_trim_points_doublets()"
.Vb 11
\& Title   : set_trim_points_doublets()
\& Usage   : $o_consed\->set_trim_points_doublets();
\& Function: Set the trim points for doublets based on quality. Uses the
\&           Bio::Tools::Alignment::Trim object. Use at your own risk because
\&           the Bio::Tools::Alignment::Trim object was designed specifically
\&           for me and is mysterious in its ways. Every time somebody other
\&           then me uses it you risk a biblical plague being loosed on your
\&           city.
\& Returns : Nothing.
\& Args    : None.
\& Notes   : Working on exceptions here.
.Ve
.PP
See Bio::Tools::Alignment::Trim for more information
.SS "get_trimmed_sequence_by_name($name)"
.IX Subsection "get_trimmed_sequence_by_name($name)"
.Vb 6
\& Title   : get_trimmed_sequence_by_name($name)
\& Usage   : $o_consed\->get_trimmed_sequence_by_name($name);
\& Function: Returns the trimmed_sequence of a contig with {name} eq $name.
\& Returns : A scalar\- the trimmed sequence.
\& Args    : The {name} of a contig.
\& Notes   :
.Ve
.ie n .SS "set_dash_present_in_sequence_name(""yes"")"
.el .SS "set_dash_present_in_sequence_name(``yes'')"
.IX Subsection "set_dash_present_in_sequence_name(yes)"
.Vb 6
\& Title   : set_dash_present_in_sequence_name("yes")
\& Usage   : $o_consed\->set_dash_present_in_sequence_name("yes");
\& Function: Deprecated. Part of an uncompleted thought. ("Oooh! Shiny!")
\& Returns : Nothing.
\& Args    : "yes" to set {dash_present_in_sequence_name} to 1
\& Notes   :
.Ve
.SS "\fBset_doublets()\fP"
.IX Subsection "set_doublets()"
.Vb 6
\& Title   : set_doublets()
\& Usage   : $o_consed\->set_doublets();
\& Function: Find pairs that have similar names and mark them as doublets
\&           and set the {name}.
\& Returns : 0 or 1.
\& Args    : None.
.Ve
.PP
A complicated subroutine that iterates over the
Bio::Tools::Alignment::Consed looking for contigs of 2. If the forward
and reverse designator are removed from each of the reads in
{'member_array'} and the remaining reads are the same, {name} is set
to that name and the contig's class is set as \*(L"doublet\*(R".  If any of
those cases fail the contig is marked as a \*(L"pair\*(R".
.SS "set_singlets"
.IX Subsection "set_singlets"
.Vb 7
\& Title   : set_singlets
\& Usage   : $o_consed\->set_singlets();
\& Function: Read in a singlets file and place them into the
\&           Bio::Tools::Alignment::Consed object.
\& Returns : Nothing.
\& Args    : A scalar to turn on verbose parsing of the singlets file.
\& Notes   :
.Ve
.SS "\fBget_singlets()\fP"
.IX Subsection "get_singlets()"
.Vb 7
\& Title   : get_singlets()
\& Usage   : $o_consed\->get_singlets();
\& Function: Return the keynames of the singlets.
\& Returns : An array containing the keynames of all 
\&           Bio::Tools::Alignment::Consed sequences in the class "singlet".
\& Args    : None.
\& Notes   :
.Ve
.SS "set_quality_by_name($name,$quality)"
.IX Subsection "set_quality_by_name($name,$quality)"
.Vb 7
\& Title   : set_quality_by_name($name,$quality)
\& Usage   : $o_consed\->set_quality_by_name($name,$quality);
\& Function: Deprecated. Make the contig with {name} have {\*(Aqquality\*(Aq} $quality.
\&           Probably used for testing.
\& Returns : Nothing.
\& Args    : The name of a contig and a scalar for its quality.
\& Notes   : Deprecated.
.Ve
.SS "\fBset_singlet_quality()\fP"
.IX Subsection "set_singlet_quality()"
.Vb 9
\& Title   : set_singlet_quality()
\& Usage   : $o_consed\->set_singlet_quality();
\& Function: For each singlet, go to the appropriate file in phd_dir and read
\&           in the phred quality for that read and place it into {\*(Aqquality\*(Aq}
\& Returns : 0 or 1.
\& Args    : None.
\& Notes   : This is the next subroutine that will receive substantial revision
\&           in the next little while. It really should eval the creation of
\&           Bio::Tools::Alignment::Phred objects and go from there.
.Ve
.SS "\fBset_contig_quality()\fP"
.IX Subsection "set_contig_quality()"
.Vb 6
\& Title   : set_contig_quality()
\& Usage   : $o_consed\->set_contig_quality();
\& Function: Deprecated.
\& Returns : Deprecated.
\& Args    : Deprecated.
\& Notes   : Deprecated. Really. Trust me.
.Ve
.SS "\fBget_multiplets()\fP"
.IX Subsection "get_multiplets()"
.Vb 7
\& Title   : get_multiplets()
\& Usage   : $o_consed\->get_multiplets();
\& Function: Return the keynames of the multiplets.
\& Returns : Returns an array containing the keynames of all 
\&           Bio::Tools::Alignment::Consed sequences in the class "multiplet".
\& Args    : None.
\& Notes   :
.Ve
.SS "\fBget_all_members()\fP"
.IX Subsection "get_all_members()"
.Vb 8
\&  Title   : get_all_members()
\&  Usage   : @all_members = $o_consed\->get_all_members();
\&  Function: Return a list of all of the read names in the 
\&            Bio::Tools::Alignment::Consed object.
\&  Returns : An array containing all of the elements in all of the
\&            {\*(Aqmember_array\*(Aq}s.
\&  Args    : None.
\&  Notes   :
.Ve
.SS "sum_lets($total_only)"
.IX Subsection "sum_lets($total_only)"
.Vb 10
\& Title   : sum_lets($total_only)
\& Usage   : $statistics = $o_consed\->sum_lets($total_only);
\& Function: Provide numbers for how many sequences were accounted for in the
\&           Bio::Tools::Alignment::Consed object.
\& Returns : If a scalar is present, returns the total number of
\&           sequences accounted for in all classes. If no scalar passed
\&           then returns a string that looks like this:
\&           Singt/singn/doub/pair/mult/total : 2,0,1(2),0(0),0(0),4
\&           This example means the following: There were 1 singlets.
\&           There were 0 singletons.  There were 1 doublets for a total
\&           of 2 sequences in this class.  There were 0 pairs for a
\&           total of 0 sequences in this class.  There were 0
\&           multiplets for a total of 0 sequences in this class.  There
\&           were a total of 4 sequences accounted for in the
\&           Bio::Tools::Alignment::Consed object.   
\& Args : A scalar is optional to change the way the numbers are returned.  
\& Notes:
.Ve
.SS "\fBwrite_stats()\fP"
.IX Subsection "write_stats()"
.Vb 6
\& Title   : write_stats()
\& Usage   : $o_consed\->write_stats();
\& Function: Write a file called "statistics" containing numbers similar to
\&           those provided in sum_lets().
\& Returns : Nothing. Write a file in $o_consed\->{path} containing something
\&           like this:
\&
\&           0,0,50(100),0(0),0(0),100
\&
\&           Where the numbers provided are in the format described in the
\&           documentation for sum_lets().
\& Args    : None.
\& Notes   : This might break platform independence, I do not know.
.Ve
.PP
See \fBsum_lets()\fR
.SS "\fBget_singletons()\fP"
.IX Subsection "get_singletons()"
.Vb 7
\& Title   : get_singletons()
\& Usage   : @singletons = $o_consed\->get_singletons();
\& Function: Return the keynames of the singletons.
\& Returns : Returns an array containing the keynames of all
\&           Bio::Tools::Alignment::Consed sequences in the class "singleton".
\& Args    : None.
\& Notes   :
.Ve
.SS "\fBget_pairs()\fP"
.IX Subsection "get_pairs()"
.Vb 7
\& Title   : get_pairs()
\& Usage   : @pairs = $o_consed\->get_pairs();
\& Function: Return the keynames of the pairs.
\& Returns : Returns an array containing the keynames of all
\&           Bio::Tools::Alignment::Consed sequences in the class "pair".
\& Args    : None.
\& Notes   :
.Ve
.SS "get_name($contig_keyname)"
.IX Subsection "get_name($contig_keyname)"
.Vb 6
\& Title   : get_name($contig_keyname)
\& Usage   : $name = $o_consed\->get_name($contig_keyname);
\& Function: Return the {name} for $contig_keyname.
\& Returns : A string. ({name})
\& Args    : A contig keyname.
\& Notes   :
.Ve
.SS "_get_contig_name(\e@array_containing_reads)"
.IX Subsection "_get_contig_name(@array_containing_reads)"
.Vb 7
\& Title   : _get_contig_name(\e@array_containing_reads)
\& Usage   : $o_consed\->_get_contig_name(\e@array_containing_reads);
\& Function: The logic for the set_doublets subroutine.
\& Returns : The name for this contig.
\& Args    : A reference to an array containing read names.
\& Notes   : Depends on reverse_designator. Be sure this is set the way you
\&           intend.
.Ve
.SS "\fBget_doublets()\fP"
.IX Subsection "get_doublets()"
.Vb 7
\& Title   : get_doublets()
\& Usage   : @doublets = $o_consed\->get_doublets();
\& Function: Return the keynames of the doublets.
\& Returns : Returns an array containing the keynames of all
\&           Bio::Tools::Alignment::Consed sequences in the class "doublet".
\& Args    : None.
\& Notes   :
.Ve
.SS "\fBdump_hash()\fP"
.IX Subsection "dump_hash()"
.Vb 7
\& Title   : dump_hash()
\& Usage   : $o_consed\->dump_hash();
\& Function: Use dumpvar.pl to dump out the Bio::Tools::Alignment::Consed
\&           object to STDOUT.
\& Returns : Nothing.
\& Args    : None.
\& Notes   : I used this a lot in debugging.
.Ve
.SS "\fBdump_hash_compact()\fP"
.IX Subsection "dump_hash_compact()"
.Vb 7
\& Title   : dump_hash_compact()
\& Usage   : $o_consed\->dump_hash_compact();
\& Function: Dump out the Bio::Tools::Alignment::Consed object in a compact way.
\& Returns : Nothing.
\& Args    : Nothing.
\& Notes   : Cleaner then dumpValue(), dumpHash(). I used this a lot in
\&           debugging.
.Ve
.SS "\fBget_phreds()\fP"
.IX Subsection "get_phreds()"
.Vb 7
\& Title   : get_phreds()
\& Usage   : @phreds = $o_consed\->get_phreds();
\& Function: For each doublet in the Bio::Tools::Alignment::Consed hash, go
\&           and get the phreds for the top and bottom reads. Place them into
\&           {top_phreds} and {bottom_phreds}.
\& Returns : Nothing.
\& Args    : Nothing.
.Ve
.PP
Requires \fBparse_phd()\fR and \fBreverse_and_complement()\fR. I realize that it
would be much more elegant to pull qualities as required but there
were certain \*(L"features\*(R" in the acefile that required a bit more
detailed work be done to get the qualities for certain parts of the
consensus sequence. In order to make _sure_ that this was done
properly I wrote things to do all steps and then I used \fBdump_hash()\fR
and checked each one to ensure expected behavior. I have never changed
this, so there you are.
.SS "parse_phd($read_name)"
.IX Subsection "parse_phd($read_name)"
.Vb 10
\& Title   : parse_phd($read_name)
\& Usage   : $o_consed\->parse_phd($read_name);
\& Function: Suck in the contents of a .phd file.
\& Returns : A reference to an array containing the quality values for the read.
\& Args    : The name of a read.
\& Notes   : This is a significantly weak subroutine because it was always
\&           intended that these functions, along with the functions provided by
\&           get_phreds() be put into the Bio::SeqIO:phd module. This is done
\&           now but the Bio::Tools::Alignment::Consed module has not be
\&           rewritten to reflect this change.
.Ve
.PP
See Bio::SeqIO::phd for more information.
.SS "reverse_and_complement(\e@source)"
.IX Subsection "reverse_and_complement(@source)"
.Vb 6
\& Title   : reverse_and_complement(\e@source)
\& Usage   : $reference_to_array = $o_consed\->reverse_and_complement(\e@source);
\& Function: A stub for the recursive routine reverse_recurse().
\& Returns : A reference to a reversed and complemented array of phred data.
\& Args    : A reference to an array of phred data.
\& Notes   :
.Ve
.SS "reverse_recurse($r_source,$r_destination)"
.IX Subsection "reverse_recurse($r_source,$r_destination)"
.Vb 7
\& Title   : reverse_recurse(\e@source,\e@destination)
\& Usage   : $o_consed\->reverse_recurse(\e@source,\e@destination);
\& Function: A recursive routine to reverse and complement an array of
\&           phred data.
\& Returns : A reference to an array containing reversed phred data.
\& Args    : A reference to a source array and a reverence to a destination
\&           array.
.Ve
.PP
Recursion is kewl, but this sub should likely be _reverse_recurse.
.SS "\fBshow_missing_sequence()\fP"
.IX Subsection "show_missing_sequence()"
.Vb 7
\& Title   : show_missing_sequence();
\& Usage   : $o_consed\->show_missing_sequence();
\& Function: Used by set_trim_points_doublets() to fill in quality values where
\&           consed (phrap?) set them to 0 at the beginning and/or end of the
\&           consensus sequences.
\& Returns : Nothing.
\& Args    : None.
.Ve
.PP
Acts on doublets only. Really very somewhat quite ugly. A disgusting
kludge. \fIinsert pride here\fR It was written stepwise with no real plan
because it was not really evident why consed (phrap?)  was doing this.
