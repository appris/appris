.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::AnnotationCollectionI 3pm"
.TH Bio::AnnotationCollectionI 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::AnnotationCollectionI \- Interface for annotation collections
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   # get an AnnotationCollectionI somehow, eg
\&
\&   $ac = $seq\->annotation();
\&
\&   foreach $key ( $ac\->get_all_annotation_keys() ) {
\&       @values = $ac\->get_Annotations($key);
\&       foreach $value ( @values ) {
\&          # value is an Bio::AnnotationI, and defines a "as_text" method
\&          print "Annotation ",$key," stringified value ",$value\->as_text,"\en";
\&
\&          # also defined hash_tree method, which allows data orientated
\&          # access into this object
\&          $hash = $value\->hash_tree();
\&       }
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Annotation Collections are a way of storing a series of \*(L"interesting
facts\*(R" about something. We call an \*(L"interesting fact\*(R" in Bioperl an
Annotation (this differs from a Sequence Feature, which is called
a Sequence Feature and may or may not have an Annotation Collection).
.PP
A benefit of this approach is that all sorts of simple, interesting
observations can be collected, the possibility is endless.
.PP
The Bioperl approach is that the \*(L"interesting facts\*(R" are represented by
Bio::AnnotationI objects. The interface Bio::AnnotationI guarantees
two methods
.PP
.Vb 1
\&   $obj\->as_text(); # string formatted to display to users
.Ve
.PP
and
.PP
.Vb 1
\&   $obj\->hash_tree(); # hash with defined rules for data\-orientated discovery
.Ve
.PP
The hash_tree method is designed to play well with \s-1XML\s0 output and
other \*(L"nested-tag-of-data-values\*(R", think BoulderIO and/or Ace stuff. For more
information see Bio::AnnotationI.
.PP
Annotations are stored in AnnotationCollections, each Annotation under a
different \*(L"tag\*(R". The tags allow simple discovery of the available annotations,
and in some cases (like the tag \*(L"gene_name\*(R") indicate how to interpret the
data underneath the tag. The tag is only one tag deep and each tag can have an
array of values.
.PP
In addition, AnnotationCollections are guaranteed to maintain consistent
types of objects under each tag \- at least that each object complies to one
interface. The \*(L"standard\*(R" AnnotationCollection insists the following rules
are set up:
.PP
.Vb 8
\&  Tag            Object
\&  \-\-\-            \-\-\-\-\-\-
\&  comment        Bio::Annotation::Comment
\&  dblink         Bio::Annotation::DBLink
\&  description    Bio::Annotation::SimpleValue
\&  gene_name      Bio::Annotation::SimpleValue
\&  ontology_term  Bio::Annotation::OntologyTerm
\&  reference      Bio::Annotation::Reference
.Ve
.PP
These tags are the implict tags that the SeqIO system needs to round-trip
GenBank/EMBL/Swissprot.
.PP
However, you as a user and us collectively as a community can grow the
\&\*(L"standard\*(R" tag mapping over time and specifically for a particular
area.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 1
\&  bioperl\-l@bioperl.org
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Email birney@ebi.ac.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal methods
are usually preceded with a _
.SH "ACCESSOR METHODS"
.IX Header "ACCESSOR METHODS"
Use these for Bio::AnnotationI object access.
.SS "\fBget_all_annotation_keys()\fP"
.IX Subsection "get_all_annotation_keys()"
.Vb 4
\& Usage   : $ac\->get_all_annotation_keys()
\& Function: gives back a list of annotation keys, which are simple text strings
\& Returns : list of strings
\& Args    : none
.Ve
.SS "\fBget_Annotations()\fP"
.IX Subsection "get_Annotations()"
.Vb 4
\& Usage   : my @annotations = $collection\->get_Annotations(\*(Aqkey\*(Aq)
\& Function: Retrieves all the Bio::AnnotationI objects for a specific key
\& Returns : list of Bio::AnnotationI \- empty if no objects stored for a key
\& Args    : string which is key for annotations
.Ve
.SS "\fBadd_Annotation()\fP"
.IX Subsection "add_Annotation()"
.Vb 5
\& Usage   : $self\->add_Annotation(\*(Aqreference\*(Aq,$object);
\&           $self\->add_Annotation($object,\*(AqBio::MyInterface::DiseaseI\*(Aq);
\&           $self\->add_Annotation($object);
\&           $self\->add_Annotation(\*(Aqdisease\*(Aq,$object,\*(AqBio::MyInterface::DiseaseI\*(Aq);
\& Function: Adds an annotation for a specific key.
\&
\&           If the key is omitted, the object to be added must provide a value
\&           via its tagname().
\&
\&           If the archetype is provided, this and future objects added under
\&           that tag have to comply with the archetype and will be rejected
\&           otherwise.
\&
\& Returns : none
\& Args    : annotation key (\*(Aqdisease\*(Aq, \*(Aqdblink\*(Aq, ...)
\&           object to store (must be Bio::AnnotationI compliant)
\&           [optional] object archetype to map future storage of object
\&           of these types to
.Ve
.SS "\fBremove_Annotations()\fP"
.IX Subsection "remove_Annotations()"
.Vb 7
\& Usage   :
\& Function: Remove the annotations for the specified key from this collection.
\& Returns : an list of Bio::AnnotationI compliant objects which were stored
\&           under the given key(s)
\& Args    : the key(s) (tag name(s), one or more strings) for which to
\&           remove annotations (optional; if none given, flushes all
\&           annotations)
.Ve
.SS "\fBget_num_of_annotations()\fP"
.IX Subsection "get_num_of_annotations()"
.Vb 4
\& Usage   : my $count = $collection\->get_num_of_annotations()
\& Function: Returns the count of all annotations stored in this collection
\& Returns : integer
\& Args    : none
.Ve
