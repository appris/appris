.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Search::Hit::GenericHit 3pm"
.TH Bio::Search::Hit::GenericHit 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Search::Hit::GenericHit \- A generic implementation of the Bio::Search::Hit::HitI interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Bio::Search::Hit::GenericHit;
\&    my $hit = Bio::Search::Hit::GenericHit\->new(\-algorithm => \*(Aqblastp\*(Aq);
\&
\&    # typically one gets HitI objects from a SearchIO stream via a ResultI
\&    use Bio::SearchIO;
\&    my $parser = Bio::SearchIO\->new(\-format => \*(Aqblast\*(Aq, \-file => \*(Aqresult.bls\*(Aq);
\&
\&    my $result = $parser\->next_result;
\&    my $hit    = $result\->next_hit;
.Ve
.PP
# \s-1TODO:\s0 Describe how to configure a SearchIO stream so that it generates
#       GenericHit objects.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object handles the hit data from a Database Sequence Search such
as \s-1FASTA\s0 or \s-1BLAST.\s0
.PP
Unless you're writing a parser, you won't ever need to create a
GenericHit or any other HitI-implementing object. If you use
the SearchIO system, HitI objects are created automatically from
a SearchIO stream which returns Bio::Search::Hit::HitI objects.
.PP
For documentation on what you can do with GenericHit (and other HitI
objects), please see the \s-1API\s0 documentation in
Bio::Search::Hit::HitI.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Jason Stajich and Steve Chervitz"
.IX Header "AUTHOR - Jason Stajich and Steve Chervitz"
Email jason-at-bioperl-dot-org
Email sac-at-bioperl-dot-org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Sendu Bala, bix@sendu.me.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : my $obj = Bio::Search::Hit::GenericHit\->new();
\& Function: Builds a new Bio::Search::Hit::GenericHit object 
\& Returns : Bio::Search::Hit::GenericHit
\& Args    : \-name         => Name of Hit (required)
\&           \-description  => Description (optional)
\&           \-accession    => Accession number (optional)
\&           \-ncbi_gi      => NCBI GI UID (optional)
\&           \-length       => Length of the Hit (optional)
\&           \-score        => Raw Score for the Hit (optional)
\&           \-bits         => Bit Score for the Hit (optional)
\&           \-significance => Significance value for the Hit (optional)
\&           \-algorithm    => Algorithm used (BLASTP, FASTX, etc...)
\&           \-hsps         => Array ref of HSPs for this Hit. 
\&           \-found_again  => boolean, true if hit appears in a 
\&                            "previously found" section of a PSI\-Blast report.
\&           \-hsp_factory  => Bio::Factory::ObjectFactoryI able to create HSPI
\&                            objects.
.Ve
.SS "add_hsp"
.IX Subsection "add_hsp"
.Vb 6
\& Title   : add_hsp
\& Usage   : $hit\->add_hsp($hsp)
\& Function: Add a HSP to the collection of HSPs for a Hit
\& Returns : number of HSPs in the Hit
\& Args    : Bio::Search::HSP::HSPI object, OR hash ref containing data suitable
\&           for creating a HSPI object (&hsp_factory must be set to get it back)
.Ve
.SS "hsp_factory"
.IX Subsection "hsp_factory"
.Vb 5
\& Title   : hsp_factory
\& Usage   : $hit\->hsp_factory($hsp_factory)
\& Function: Get/set the factory used to build HSPI objects if necessary.
\& Returns : Bio::Factory::ObjectFactoryI
\& Args    : Bio::Factory::ObjectFactoryI
.Ve
.SS "Bio::Search::Hit::HitI methods"
.IX Subsection "Bio::Search::Hit::HitI methods"
Implementation of Bio::Search::Hit::HitI methods
.SS "name"
.IX Subsection "name"
.Vb 5
\& Title   : name
\& Usage   : $hit_name = $hit\->name();
\& Function: returns the name of the Hit sequence
\& Returns : a scalar string
\& Args    : [optional] scalar string to set the name
.Ve
.SS "accession"
.IX Subsection "accession"
.Vb 5
\& Title   : accession
\& Usage   : $acc = $hit\->accession();
\& Function: Retrieve the accession (if available) for the hit
\& Returns : a scalar string (empty string if not set)
\& Args    : none
.Ve
.SS "description"
.IX Subsection "description"
.Vb 5
\& Title   : description
\& Usage   : $desc = $hit\->description();
\& Function: Retrieve the description for the hit
\& Returns : a scalar string
\& Args    : [optional] scalar string to set the description
.Ve
.SS "length"
.IX Subsection "length"
.Vb 5
\& Title   : length
\& Usage   : my $len = $hit\->length
\& Function: Returns the length of the hit 
\& Returns : integer
\& Args    : [optional] integer to set the length
.Ve
.SS "algorithm"
.IX Subsection "algorithm"
.Vb 9
\& Title   : algorithm
\& Usage   : $alg = $hit\->algorithm();
\& Function: Gets the algorithm specification that was used to obtain the hit
\&           For BLAST, the algorithm denotes what type of sequence was aligned 
\&           against what (BLASTN: dna\-dna, BLASTP prt\-prt, BLASTX translated 
\&           dna\-prt, TBLASTN prt\-translated dna, TBLASTX translated 
\&           dna\-translated dna).
\& Returns : a scalar string 
\& Args    : [optional] scalar string to set the algorithm
.Ve
.SS "raw_score"
.IX Subsection "raw_score"
.Vb 7
\& Title   : raw_score
\& Usage   : $score = $hit\->raw_score();
\& Function: Gets the "raw score" generated by the algorithm.  What
\&           this score is exactly will vary from algorithm to algorithm,
\&           returning undef if unavailable.
\& Returns : a scalar value
\& Args    : [optional] scalar value to set the raw score
.Ve
.SS "score"
.IX Subsection "score"
Equivalent to \fBraw_score()\fR
.SS "significance"
.IX Subsection "significance"
.Vb 8
\& Title   : significance
\& Usage   : $significance = $hit\->significance();
\& Function: Used to obtain the E or P value of a hit, i.e. the probability that
\&           this particular hit was obtained purely by random chance.  If
\&           information is not available (nor calculatable from other
\&           information sources), return undef.
\& Returns : a scalar value or undef if unavailable
\& Args    : [optional] scalar value to set the significance
.Ve
.SS "bits"
.IX Subsection "bits"
.Vb 6
\& Usage     : $hit_object\->bits();
\& Purpose   : Gets the bit score of the best HSP for the current hit.
\& Example   : $bits = $hit_object\->bits();
\& Returns   : Integer or undef if bit score is not set
\& Argument  : n/a
\& Comments  : For BLAST1, the non\-bit score is listed in the summary line.
.Ve
.PP
See Also   : \fBscore()\fR
.SS "next_hsp"
.IX Subsection "next_hsp"
.Vb 6
\& Title    : next_hsp
\& Usage    : while( $hsp = $obj\->next_hsp()) { ... }
\& Function : Returns the next available High Scoring Pair
\& Example  : 
\& Returns  : Bio::Search::HSP::HSPI object or null if finished
\& Args     : none
.Ve
.SS "hsps"
.IX Subsection "hsps"
.Vb 10
\& Usage     : $hit_object\->hsps();
\& Purpose   : Get a list containing all HSP objects.
\&           : Get the numbers of HSPs for the current hit.
\& Example   : @hsps = $hit_object\->hsps();
\&           : $num  = $hit_object\->hsps();  # alternatively, use num_hsps()
\& Returns   : Array context : list of Bio::Search::HSP::BlastHSP.pm objects.
\&           : Scalar context: integer (number of HSPs).
\&           :                 (Equivalent to num_hsps()).
\& Argument  : n/a. Relies on wantarray
\& Throws    : Exception if the HSPs have not been collected.
.Ve
.PP
See Also   : \fBhsp()\fR, \fBnum_hsps()\fR
.SS "num_hsps"
.IX Subsection "num_hsps"
.Vb 5
\& Usage     : $hit_object\->num_hsps();
\& Purpose   : Get the number of HSPs for the present hit.
\& Example   : $nhsps = $hit_object\->num_hsps();
\& Returns   : Integer or \*(Aq\-\*(Aq if HSPs have not been callected
\& Argument  : n/a
.Ve
.PP
See Also   : \fBhsps()\fR
.SS "rewind"
.IX Subsection "rewind"
.Vb 6
\& Title   : rewind
\& Usage   : $hit\->rewind;
\& Function: Allow one to reset the HSP iterator to the beginning
\&           Since this is an in\-memory implementation
\& Returns : none
\& Args    : none
.Ve
.SS "ambiguous_aln"
.IX Subsection "ambiguous_aln"
.Vb 10
\& Usage     : $ambig_code = $hit_object\->ambiguous_aln();
\& Purpose   : Sets/Gets ambiguity code data member.
\& Example   : (see usage)
\& Returns   : String = \*(Aqq\*(Aq, \*(Aqs\*(Aq, \*(Aqqs\*(Aq, \*(Aq\-\*(Aq
\&           :   \*(Aqq\*(Aq  = query sequence contains overlapping sub\-sequences 
\&           :          while sbjct does not.
\&           :   \*(Aqs\*(Aq  = sbjct sequence contains overlapping sub\-sequences 
\&           :          while query does not.
\&           :   \*(Aqqs\*(Aq = query and sbjct sequence contains overlapping sub\-sequences
\&           :          relative to each other.
\&           :   \*(Aq\-\*(Aq  = query and sbjct sequence do not contains multiple domains 
\&           :          relative to each other OR both contain the same distribution
\&           :          of similar domains.
\& Argument  : n/a
\& Throws    : n/a
\& Comment   : Note: "sbjct" is synonymous with "hit"
.Ve
.SS "overlap"
.IX Subsection "overlap"
See documentation in \fBBio::Search::Hit::HitI::overlap()\fR
.SS "n"
.IX Subsection "n"
.Vb 10
\& Usage     : $hit_object\->n();
\& Purpose   : Gets the N number for the current hit.
\&           : This is the number of HSPs in the set which was ascribed
\&           : the lowest P\-value (listed on the description line).
\&           : This number is not the same as the total number of HSPs.
\&           : To get the total number of HSPs, use num_hsps().
\& Example   : $n = $hit_object\->n();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : Exception if HSPs have not been set (BLAST2 reports).
\& Comments  : Note that the N parameter is not reported in gapped BLAST2.
\&           : Calling n() on such reports will result in a call to num_hsps().
\&           : The num_hsps() method will count the actual number of
\&           : HSPs in the alignment listing, which may exceed N in
\&           : some cases.
.Ve
.PP
See Also   : \fBnum_hsps()\fR
.SS "p"
.IX Subsection "p"
.Vb 10
\& Usage     : $hit_object\->p( [format] );
\& Purpose   : Get the P\-value for the best HSP of the given BLAST hit.
\&           : (Note that P\-values are not provided with NCBI Blast2 reports).
\& Example   : $p =  $sbjct\->p;
\&           : $p =  $sbjct\->p(\*(Aqexp\*(Aq);  # get exponent only.
\&           : ($num, $exp) =  $sbjct\->p(\*(Aqparts\*(Aq);  # split sci notation into parts
\& Returns   : Float or scientific notation number (the raw P\-value, DEFAULT).
\&           : Integer if format == \*(Aqexp\*(Aq (the magnitude of the base 10 exponent).
\&           : 2\-element list (float, int) if format == \*(Aqparts\*(Aq and P\-value
\&           :                is in scientific notation (See Comments).
\& Argument  : format: string of \*(Aqraw\*(Aq | \*(Aqexp\*(Aq | \*(Aqparts\*(Aq
\&           :    \*(Aqraw\*(Aq returns value given in report. Default. (1.2e\-34)
\&           :    \*(Aqexp\*(Aq returns exponent value only (34)
\&           :    \*(Aqparts\*(Aq returns the decimal and exponent as a 
\&           :            2\-element list (1.2, \-34) (See Comments).
\& Throws    : Warns if no P\-value is defined. Uses expect instead.
\& Comments  : Using the \*(Aqparts\*(Aq argument is not recommended since it will not
\&           : work as expected if the P\-value is not in scientific notation.
\&           : That is, floats are not converted into sci notation before
\&           : splitting into parts.
.Ve
.PP
See Also   : \fBexpect()\fR, \fBsignificance()\fR, \fBBio::Search::SearchUtils::get_exponent()\fR
.SS "hsp"
.IX Subsection "hsp"
.Vb 12
\& Usage     : $hit_object\->hsp( [string] );
\& Purpose   : Get a single HSPI object for the present HitI object.
\& Example   : $hspObj  = $hit_object\->hsp;  # same as \*(Aqbest\*(Aq
\&           : $hspObj  = $hit_object\->hsp(\*(Aqbest\*(Aq);
\&           : $hspObj  = $hit_object\->hsp(\*(Aqworst\*(Aq);
\& Returns   : Object reference for a Bio::Search::HSP::BlastHSP.pm object.
\& Argument  : String (or no argument).
\&           :   No argument (default) = highest scoring HSP (same as \*(Aqbest\*(Aq).
\&           :   \*(Aqbest\*(Aq or \*(Aqfirst\*(Aq = highest scoring HSP.
\&           :   \*(Aqworst\*(Aq or \*(Aqlast\*(Aq = lowest scoring HSP.
\& Throws    : Exception if the HSPs have not been collected.
\&           : Exception if an unrecognized argument is used.
.Ve
.PP
See Also   : \fBhsps()\fR, num_hsps()
.SS "logical_length"
.IX Subsection "logical_length"
.Vb 10
\& Usage     : $hit_object\->logical_length( [seq_type] );
\&           : (mostly intended for internal use).
\& Purpose   : Get the logical length of the hit sequence.
\&           : This is necessary since the number of identical/conserved residues 
\&           : can be in terms of peptide sequence space, yet the query and/or hit
\&           : sequence are in nucleotide space.
\& Example   : $len    = $hit_object\->logical_length();
\& Returns   : Integer 
\& Argument  : seq_type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  :
\&           : In the case of BLAST flavors:
\&           : For TBLASTN reports, the length of the aligned portion of the 
\&           : nucleotide hit sequence is divided by 3; for BLASTX reports, 
\&           : the length of the aligned portion of the nucleotide query 
\&           : sequence is divided by 3. For TBLASTX reports, the length of 
\&           : both hit and query sequence are converted.
\&           :
\&           : This is important for functions like frac_aligned_query()
\&           : which need to operate in amino acid coordinate space when dealing
\&           : with [T]BLAST[NX] type reports.
.Ve
.PP
See Also   : \fBlength()\fR, \fBfrac_aligned_query()\fR, \fBfrac_aligned_hit()\fR
.SS "length_aln"
.IX Subsection "length_aln"
.Vb 10
\& Usage     : $hit_object\->length_aln( [seq_type] );
\& Purpose   : Get the total length of the aligned region for query or sbjct seq.
\&           : This number will include all HSPs
\& Example   : $len    = $hit_object\->length_aln(); # default = query
\&           : $lenAln = $hit_object\->length_aln(\*(Aqquery\*(Aq);
\& Returns   : Integer 
\& Argument  : seq_Type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (Default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : Exception if the argument is not recognized.
\& Comments  : This method will report the logical length of the alignment,
\&           : meaning that for TBLAST[NX] reports, the length is reported
\&           : using amino acid coordinate space (i.e., nucleotides / 3).
\&           : 
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
\&           : If you don\*(Aqt want the tiled data, iterate through each HSP
\&           : calling length() on each (use hsps() to get all HSPs).
.Ve
.PP
See Also   : \fBlength()\fR, \fBfrac_aligned_query()\fR, \fBfrac_aligned_hit()\fR, \fBgaps()\fR, \fBBio::Search::SearchUtils::tile_hsps()\fR, \fBBio::Search::HSP::BlastHSP::length()\fR
.SS "gaps"
.IX Subsection "gaps"
.Vb 10
\& Usage     : $hit_object\->gaps( [seq_type] );
\& Purpose   : Get the number of gaps in the aligned query, hit, or both sequences.
\&           : Data is summed across all HSPs.
\& Example   : $qgaps = $hit_object\->gaps(\*(Aqquery\*(Aq);
\&           : $hgaps = $hit_object\->gaps(\*(Aqhit\*(Aq);
\&           : $tgaps = $hit_object\->gaps();    # default = total (query + hit)
\& Returns   : scalar context: integer
\&           : array context without args: two\-element list of integers  
\&           :    (queryGaps, hitGaps)
\&           : Array context can be forced by providing an argument of \*(Aqlist\*(Aq or \*(Aqarray\*(Aq.
\&           :
\&           : CAUTION: Calling this method within printf or sprintf is arrray context.
\&           : So this function may not give you what you expect. For example:
\&           :          printf "Total gaps: %d", $hit\->gaps();
\&           : Actually returns a two\-element array, so what gets printed 
\&           : is the number of gaps in the query, not the total
\&           :
\& Argument  : seq_type: \*(Aqquery\*(Aq | \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq | \*(Aqtotal\*(Aq | \*(Aqlist\*(Aq  (default = \*(Aqtotal\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through each HSP object.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
\&           : Not relying on wantarray since that will fail in situations 
\&           : such as printf "%d", $hit\->gaps() in which you might expect to 
\&           : be printing the total gaps, but evaluates to array context.
.Ve
.PP
See Also   : \fBlength_aln()\fR
.SS "matches"
.IX Subsection "matches"
See documentation in \fBBio::Search::Hit::HitI::matches()\fR
.SS "start"
.IX Subsection "start"
.Vb 10
\& Usage     : $sbjct\->start( [seq_type] );
\& Purpose   : Gets the start coordinate for the query, sbjct, or both sequences
\&           : in the BlastHit object. If there is more than one HSP, the lowest start
\&           : value of all HSPs is returned.
\& Example   : $qbeg = $sbjct\->start(\*(Aqquery\*(Aq);
\&           : $sbeg = $sbjct\->start(\*(Aqhit\*(Aq);
\&           : ($qbeg, $sbeg) = $sbjct\->start();
\& Returns   : scalar context: integer 
\&           : array context without args: list of two integers (queryStart, sbjctStart)
\&           : Array context can be "induced" by providing an argument of \*(Aqlist\*(Aq or \*(Aqarray\*(Aq.
\& Argument  : In scalar context: seq_type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
.Ve
.PP
See Also   : \fBend()\fR, \fBrange()\fR, \fBstrand()\fR, 
             Bio::Search::HSP::BlastHSP::start
.SS "end"
.IX Subsection "end"
.Vb 10
\& Usage     : $sbjct\->end( [seq_type] );
\& Purpose   : Gets the end coordinate for the query, sbjct, or both sequences
\&           : in the BlastHit object. If there is more than one HSP, 
\&             the largest end
\&           : value of all HSPs is returned.
\& Example   : $qend = $sbjct\->end(\*(Aqquery\*(Aq);
\&           : $send = $sbjct\->end(\*(Aqhit\*(Aq);
\&           : ($qend, $send) = $sbjct\->end();
\& Returns   : scalar context: integer
\&           : array context without args: list of two integers 
\&           : (queryEnd, sbjctEnd)
\&           : Array context can be "induced" by providing an argument 
\&           : of \*(Aqlist\*(Aq or \*(Aqarray\*(Aq.
\& Argument  : In scalar context: seq_type = \*(Aqquery\*(Aq or \*(Aqsbjct\*(Aq
\&           :  (case insensitive). If not supplied, \*(Aqquery\*(Aq is used.
\& Throws    : n/a
.Ve
.PP
See Also   : \fBstart()\fR, \fBrange()\fR, \fBstrand()\fR
.SS "range"
.IX Subsection "range"
.Vb 9
\& Usage     : $sbjct\->range( [seq_type] );
\& Purpose   : Gets the (start, end) coordinates for the query or sbjct sequence
\&           : in the HSP alignment.
\& Example   : ($qbeg, $qend) = $sbjct\->range(\*(Aqquery\*(Aq);
\&           : ($sbeg, $send) = $sbjct\->range(\*(Aqhit\*(Aq);
\& Returns   : Two\-element array of integers 
\& Argument  : seq_type = string, \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq  (default = \*(Aqquery\*(Aq)
\&             (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
.Ve
.PP
See Also   : \fBstart()\fR, \fBend()\fR
.SS "frac_identical"
.IX Subsection "frac_identical"
.Vb 10
\& Usage     : $hit_object\->frac_identical( [seq_type] );
\& Purpose   : Get the overall fraction of identical positions across all HSPs.
\&           : The number refers to only the aligned regions and does not
\&           : account for unaligned regions in between the HSPs, if any.
\& Example   : $frac_iden = $hit_object\->frac_identical(\*(Aqquery\*(Aq);
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : seq_type: \*(Aqquery\*(Aq | \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq | \*(Aqtotal\*(Aq
\&           : default = \*(Aqquery\*(Aq (but see comments below).
\&           : (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  :
\&           : To compute the fraction identical, the logical length of the 
\&           : aligned portion of the sequence is used, meaning that
\&           : in the case of BLAST flavors, for TBLASTN reports, the length of 
\&           : the aligned portion of the 
\&           : nucleotide hit sequence is divided by 3; for BLASTX reports, 
\&           : the length of the aligned portion of the nucleotide query 
\&           : sequence is divided by 3. For TBLASTX reports, the length of 
\&           : both hit and query sequence are converted.
\&           : This is necessary since the number of identical residues is
\&           : in terms of peptide sequence space.
\&           :
\&           : Different versions of Blast report different values for the total
\&           : length of the alignment. This is the number reported in the
\&           : denominators in the stats section:
\&           : "Identical = 34/120 Positives = 67/120".
\&           : NCBI BLAST uses the total length of the alignment (with gaps)
\&           : WU\-BLAST uses the length of the query sequence (without gaps).
\&           :
\&           : Therefore, when called with an argument of \*(Aqtotal\*(Aq,
\&           : this method will report different values depending on the
\&           : version of BLAST used. Total does NOT take into account HSP
\&           : tiling, so it should not be used.
\&           :
\&           : To get the fraction identical among only the aligned residues,
\&           : ignoring the gaps, call this method without an argument or 
\&           : with an argument of \*(Aqquery\*(Aq or \*(Aqhit\*(Aq.
\&           :
\&           : If you need data for each HSP, use hsps() and then iterate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically.
.Ve
.PP
See Also   : \fBfrac_conserved()\fR, \fBfrac_aligned_query()\fR, \fBmatches()\fR, \fBBio::Search::SearchUtils::tile_hsps()\fR
.SS "frac_conserved"
.IX Subsection "frac_conserved"
.Vb 10
\& Usage     : $hit_object\->frac_conserved( [seq_type] );
\& Purpose   : Get the overall fraction of conserved positions across all HSPs.
\&           : The number refers to only the aligned regions and does not
\&           : account for unaligned regions in between the HSPs, if any.
\& Example   : $frac_cons = $hit_object\->frac_conserved(\*(Aqhit\*(Aq);
\& Returns   : Float (2\-decimal precision, e.g., 0.75).
\& Argument  : seq_type: \*(Aqquery\*(Aq | \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq | \*(Aqtotal\*(Aq
\&           : default = \*(Aqquery\*(Aq (but see comments below).
\&           : (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\& Throws    : n/a
\& Comments  :
\&           : To compute the fraction conserved, the logical length of the 
\&           : aligned portion of the sequence is used, meaning that
\&           : in the case of BLAST flavors, for TBLASTN reports, the length of 
\&           : the aligned portion of the 
\&           : nucleotide hit sequence is divided by 3; for BLASTX reports, 
\&           : the length of the aligned portion of the nucleotide query 
\&           : sequence is divided by 3. For TBLASTX reports, the length of 
\&           : both hit and query sequence are converted.
\&           : This is necessary since the number of conserved residues is
\&           : in terms of peptide sequence space.
\&           :
\&           : Different versions of Blast report different values for the total
\&           : length of the alignment. This is the number reported in the
\&           : denominators in the stats section:
\&           : "Positives = 34/120 Positives = 67/120".
\&           : NCBI BLAST uses the total length of the alignment (with gaps)
\&           : WU\-BLAST uses the length of the query sequence (without gaps).
\&           :
\&           : Therefore, when called with an argument of \*(Aqtotal\*(Aq,
\&           : this method will report different values depending on the
\&           : version of BLAST used. Total does NOT take into account HSP
\&           : tiling, so it should not be used.
\&           :
\&           : To get the fraction conserved among only the aligned residues,
\&           : ignoring the gaps, call this method without an argument or 
\&           : with an argument of \*(Aqquery\*(Aq or \*(Aqhit\*(Aq.
\&           :
\&           : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically.
.Ve
.PP
See Also   : \fBfrac_identical()\fR, \fBmatches()\fR, \fBBio::Search::SearchUtils::tile_hsps()\fR
.SS "frac_aligned_query"
.IX Subsection "frac_aligned_query"
.Vb 10
\& Usage     : $hit_object\->frac_aligned_query();
\& Purpose   : Get the fraction of the query sequence which has been aligned
\&           : across all HSPs (not including intervals between non\-overlapping
\&           : HSPs).
\& Example   : $frac_alnq = $hit_object\->frac_aligned_query();
\& Returns   : Float (2\-decimal precision, e.g., 0.75),
\&           : or undef if query length is unknown to avoid division by 0.
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically.
.Ve
.PP
See Also   : \fBfrac_aligned_hit()\fR, \fBlogical_length()\fR, \fBlength_aln()\fR,  \fBBio::Search::SearchUtils::tile_hsps()\fR
.SS "frac_aligned_hit"
.IX Subsection "frac_aligned_hit"
.Vb 10
\& Usage     : $hit_object\->frac_aligned_hit();
\& Purpose   : Get the fraction of the hit (sbjct) sequence which has been aligned
\&           : across all HSPs (not including intervals between non\-overlapping
\&           : HSPs).
\& Example   : $frac_alnq = $hit_object\->frac_aligned_hit();
\& Returns   : Float (2\-decimal precision, e.g., 0.75),
\&           : or undef if hit length is unknown to avoid division by 0.
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically.
.Ve
.PP
See Also   : \fBfrac_aligned_query()\fR, \fBmatches()\fR, , \fBlogical_length()\fR, \fBlength_aln()\fR,  \fBBio::Search::SearchUtils::tile_hsps()\fR
.SS "frac_aligned_sbjct"
.IX Subsection "frac_aligned_sbjct"
Same as \fBfrac_aligned_hit()\fR
.SS "num_unaligned_sbjct"
.IX Subsection "num_unaligned_sbjct"
Same as \fBnum_unaligned_hit()\fR
.SS "num_unaligned_hit"
.IX Subsection "num_unaligned_hit"
.Vb 10
\& Usage     : $hit_object\->num_unaligned_hit();
\& Purpose   : Get the number of the unaligned residues in the hit sequence.
\&           : Sums across all all HSPs.
\& Example   : $num_unaln = $hit_object\->num_unaligned_hit();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : See notes regarding logical lengths in the comments for frac_aligned_hit().
\&           : They apply here as well.
\&           : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
.Ve
.PP
See Also   : \fBnum_unaligned_query()\fR,  \fBBio::Search::SearchUtils::tile_hsps()\fR, \fBfrac_aligned_hit()\fR
.SS "num_unaligned_query"
.IX Subsection "num_unaligned_query"
.Vb 10
\& Usage     : $hit_object\->num_unaligned_query();
\& Purpose   : Get the number of the unaligned residues in the query sequence.
\&           : Sums across all all HSPs.
\& Example   : $num_unaln = $hit_object\->num_unaligned_query();
\& Returns   : Integer
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : See notes regarding logical lengths in the comments for frac_aligned_query().
\&           : They apply here as well.
\&           : If you need data for each HSP, use hsps() and then interate
\&           : through the HSP objects.
\&           : This method requires that all HSPs be tiled. If they have not
\&           : already been tiled, they will be tiled first automatically..
.Ve
.PP
See Also   : \fBnum_unaligned_hit()\fR, \fBfrac_aligned_query()\fR,  \fBBio::Search::SearchUtils::tile_hsps()\fR
.SS "seq_inds"
.IX Subsection "seq_inds"
.Vb 10
\& Usage     : $hit\->seq_inds( seq_type, class, collapse );
\& Purpose   : Get a list of residue positions (indices) across all HSPs
\&           : for identical or conserved residues in the query or sbjct sequence.
\& Example   : @s_ind = $hit\->seq_inds(\*(Aqquery\*(Aq, \*(Aqidentical\*(Aq);
\&           : @h_ind = $hit\->seq_inds(\*(Aqhit\*(Aq, \*(Aqconserved\*(Aq);
\&           : @h_ind = $hit\->seq_inds(\*(Aqhit\*(Aq, \*(Aqconserved\*(Aq, 1);
\& Returns   : Array of integers 
\&           : May include ranges if collapse is non\-zero.
\& Argument  : [0] seq_type  = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq  (default = \*(Aqquery\*(Aq)
\&           :                 (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\&           : [1] class     = \*(Aqidentical\*(Aq or \*(Aqconserved\*(Aq (default = \*(Aqidentical\*(Aq)
\&           :              (can be shortened to \*(Aqid\*(Aq or \*(Aqcons\*(Aq)
\&           :              (actually, anything not \*(Aqid\*(Aq will evaluate to \*(Aqconserved\*(Aq).
\&           : [2] collapse  = boolean, if non\-zero, consecutive positions are merged
\&           :             using a range notation, e.g., "1 2 3 4 5 7 9 10 11" 
\&           :             collapses to "1\-5 7 9\-11". This is useful for 
\&           :             consolidating long lists. Default = no collapse.
\& Throws    : n/a.
.Ve
.PP
See Also   : \fBBio::Search::HSP::BlastHSP::seq_inds()\fR
.SS "strand"
.IX Subsection "strand"
See documentation in \fBBio::Search::Hit::HitI::strand()\fR
.SS "frame"
.IX Subsection "frame"
See documentation in \fBBio::Search::Hit::HitI::frame()\fR
.SS "rank"
.IX Subsection "rank"
.Vb 6
\& Title   : rank
\& Usage   : $obj\->rank($newval)
\& Function: Get/Set the rank of this Hit in the Query search list
\&           i.e. this is the Nth hit for a specific query
\& Returns : value of rank
\& Args    : newvalue (optional)
.Ve
.SS "locus"
.IX Subsection "locus"
.Vb 5
\& Title   : locus
\& Usage   : $locus = $hit\->locus();
\& Function: Retrieve the locus (if available) for the hit
\& Returns : a scalar string (empty string if not set)
\& Args    : none
.Ve
.SS "each_accession_number"
.IX Subsection "each_accession_number"
.Vb 7
\& Title   : each_accession_number
\& Usage   : @each_accession_number = $hit\->each_accession_number();
\& Function: Get each accession number listed in the description of the hit.
\&           If there are no alternatives, then only the primary accession will 
\&           be given
\& Returns : list of all accession numbers in the description
\& Args    : none
.Ve
.SS "tiled_hsps"
.IX Subsection "tiled_hsps"
See documentation in \fBBio::Search::SearchUtils::tile_hsps()\fR
.SS "query_length"
.IX Subsection "query_length"
.Vb 5
\& Title   : query_length
\& Usage   : $obj\->query_length($newval)
\& Function: Get/Set the query_length
\& Returns : value of query_length (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SS "ncbi_gi"
.IX Subsection "ncbi_gi"
.Vb 9
\& Title   : ncbi_gi
\& Usage   : $acc = $hit\->ncbi_gi();
\& Function: Retrieve the NCBI Unique ID (aka the GI #),
\&           if available, for the hit
\& Returns : a scalar string (empty string if not set)
\& Args    : none
\& Note    : As of Sept. 2016 NCBI records will no longer have a
\&           GI; this attributue will remain in place for older
\&           records
.Ve
.SS "sort_hits"
.IX Subsection "sort_hits"
.Vb 10
\& Title          : sort_hsps
\& Usage          : $result\->sort_hsps(\e&sort_function)
\& Function       : Sorts the available HSP objects by a user\-supplied function. Defaults to sort
\&                  by descending score.
\& Returns        : n/a
\& Args           : A coderef for the sort function.  See the documentation on the Perl sort()
\&                  function for guidelines on writing sort functions.  
\& Note           : To access the special variables $a and $b used by the Perl sort() function 
\&                  the user function must access Bio::Search::Hit::HitI namespace. 
\&                  For example, use :
\&                  $hit\->sort_hsps( sub{$Bio::Search::Result::HitI::a\->length <=> 
\&                                          $Bio::Search::Result::HitI::b\->length});
\&                   NOT $hit\->sort_hsps($a\->length <=> $b\->length);
.Ve
.SS "iteration"
.IX Subsection "iteration"
.Vb 8
\& Usage     : $hit\->iteration( $iteration_num );
\& Purpose   : Gets the iteration number in which the Hit was found.
\& Example   : $iteration_num = $sbjct\->iteration();
\& Returns   : Integer greater than or equal to 1
\&             Non\-PSI\-BLAST reports may report iteration as 1, but this number
\&             is only meaningful for PSI\-BLAST reports.
\& Argument  : iteration_num (optional, used when setting only)
\& Throws    : none
.Ve
.PP
See Also   : \fBfound_again()\fR
.SS "found_again"
.IX Subsection "found_again"
.Vb 6
\& Title     : found_again
\& Usage     : $hit\->found_again;
\&             $hit\->found_again(1);
\& Purpose   : Gets a boolean indicator whether or not the hit has
\&             been found in a previous iteration.
\&             This is only applicable to PSI\-BLAST reports.
\&
\&              This method indicates if the hit was reported in the 
\&              "Sequences used in model and found again" section of the
\&              PSI\-BLAST report or if it was reported in the
\&              "Sequences not found previously or not previously below threshold"
\&              section of the PSI\-BLAST report. Only for hits in iteration > 1.
\&
\& Example   : if( $hit\->found_again()) { ... };
\& Returns   : Boolean, true (1) if the hit has been found in a 
\&             previous PSI\-BLAST iteration.
\&             Returns false (0 or undef) for hits that have not occurred in a
\&             previous PSI\-BLAST iteration.
\& Argument  : Boolean (1 or 0). Only used for setting.
\& Throws    : none
.Ve
.PP
See Also   : \fBiteration()\fR
