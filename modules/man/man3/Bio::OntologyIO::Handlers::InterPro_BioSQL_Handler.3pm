.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::OntologyIO::Handlers::InterPro_BioSQL_Handler 3pm"
.TH Bio::OntologyIO::Handlers::InterPro_BioSQL_Handler 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::OntologyIO::Handlers::InterPro_BioSQL_Handler \- parse an InterPro XML file and persist the resulting terms to a Biosql database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   # see load_interpro.pl in bioperl\-db/scripts/biosql/
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is for parsing an InterPro \s-1XML\s0 file and persist the
resulting terms to a Biosql database as soon as the term is complete
as signaled by the appropriate xml tag. This parser takes advantage of
\&\s-1SAX,\s0 a stream-based \s-1XML\s0 parser technology, to keep the used memory as
small as possible. The alternative parser for InterPro, module
InterProHandler, builds up the entire ontology in memory, which given
the size of the latest InterPro releases requires a huge amount of
memory.
.PP
This module takes the following non-standard arguments upon
instantiation.
.PP
.Vb 4
\&   \-db           the adaptor factory as returned by a call to
\&                 Bio::DB::BioDB\->new()
\&   \-version      the InterPro version (not available as property!)
\&   \-term_factory the object factory to use for creating terms
.Ve
.PP
Note that there are two alternatives for how to persist the terms and
relationships to the database. The default is using the adaptor
factory passed as \-db or set as a property to create persistent
objects and store them in the database. The alternative is to specify
a term persistence and a relationship persistence handler; if one or
both have been set, the respective handler will be called with each
term and relationship that is to be stored. See properties
persist_term_handler and persist_relationship_handler.
.SH "AUTHOR"
.IX Header "AUTHOR"
Juguang Xiao, juguang@tll.org.sg
.SH "Contributors"
.IX Header "Contributors"
Hilmar Lapp, hlapp at gmx.net
.SS "\s-1APPENDIX\s0"
.IX Subsection "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "term_factory"
.IX Subsection "term_factory"
.Vb 3
\& Title   : term_factory
\& Usage   : $obj\->term_factory($newval)
\& Function: Get/set the ontology term factory to use.
\&
\&           As a user of this module it is not necessary to call this
\&           method as there will be default. In order to change the
\&           default, the easiest way is to instantiate
\&           L<Bio::Ontology::TermFactory> with the proper \-type
\&           argument. Most if not all parsers will actually use this
\&           very implementation, so even easier than the aforementioned
\&           way is to simply call
\&           $ontio\->term_factory\->type("Bio::Ontology::MyTerm").
\&
\& Example :
\& Returns : value of term_factory (a Bio::Factory::ObjectFactoryI object)
\& Args    : on set, new value (a Bio::Factory::ObjectFactoryI object, optional)
.Ve
.SS "db"
.IX Subsection "db"
.Vb 3
\& Title   : db
\& Usage   : $obj\->db($newval)
\& Function: Sets or retrieves the database adaptor factory.
\&
\&           The adaptor factory is a Bio::DB::DBAdaptorI compliant
\&           object and will be used to obtain the persistence adaptors
\&           necessary to serialize terms and relationships to the
\&           database.
\&
\&           Usually, you will obtain such an object from a call to
\&           Bio::DB::BioDB. You *must* set this property before
\&           starting the parse.
\&
\&           Note that this property is immutable once set, except that
\&           you may set it to undef. Therefore, be careful not to set
\&           to undef before setting the desired real value.
\&
\& Example :
\& Returns : value of db (a Bio::DB::DBAdaptorI compliant object)
\& Args    : on set, new value (a Bio::DB::DBAdaptorI compliant object
\&           or undef, optional)
.Ve
.SS "persist_term_handler"
.IX Subsection "persist_term_handler"
.Vb 5
\& Title   : persist_term_handler
\& Usage   : $obj\->persist_term_handler($handler,@args)
\& Function: Sets or retrieves the persistence handler for terms along
\&           with the constant set of arguments to be passed to the
\&           handler.
\&
\&           If set, the first argument will be treated as a closure and
\&           be called for each term to persist to the database. The
\&           term will be passed as a named parameter (\-term), followed
\&           by the other arguments passed to this setter. Note that
\&           this allows one to pass an arbitrary configuration to the
\&           handler.
\&
\&           If not set, terms will be persisted along with their
\&           relationships using the respective persistence adaptor
\&           returned by the adaptor factory (see property db).
\&
\& Example :
\& Returns : an array reference with the values passed on set, or an empty
\&           array if never set
\& Args    : On set, an array of values. The first value is the handler
\&           as a closure; all other values will be passed to the handler
\&           as constant argument.
.Ve
.SS "persist_relationship_handler"
.IX Subsection "persist_relationship_handler"
.Vb 5
\& Title   : persist_relationship_handler
\& Usage   : $obj\->persist_relationship_handler($handler,@args)
\& Function: Sets or retrieves the persistence handler for relationships
\&           along with the constant set of arguments to be passed to
\&           the handler.
\&
\&           If set, the first argument will be treated as a closure and
\&           be called for each relationship to persist to the database. The
\&           relationship will be passed as a named parameter (\-rel), followed
\&           by the other arguments passed to this setter. Note that
\&           this allows one to pass an arbitrary configuration to the
\&           handler.
\&
\&           If not set, relationships will be persisted along with their
\&           relationships using the respective persistence adaptor
\&           returned by the adaptor factory (see property db).
\&
\& Example :
\& Returns : an array reference with the values passed on set, or an empty
\&           array if never set
\& Args    : On set, an array of values. The first value is the handler
\&           as a closure; all other values will be passed to the handler
\&           as constant argument.
.Ve
.SS "_persist_term"
.IX Subsection "_persist_term"
.Vb 7
\& Title   : _persist_term
\& Usage   :
\& Function: Persists a term to the database, using either a previously
\&           set persistence handler, or the adaptor factory directly.
\& Example :
\& Returns :
\& Args    : the ontology term to persist
.Ve
.SS "_persist_relationship"
.IX Subsection "_persist_relationship"
.Vb 5
\& Title   : _persist_relationship
\& Usage   :
\& Function: Persists a relationship to the database, using either a
\&           previously set persistence handler, or the adaptor factory
\&           directly.
\&
\& Example :
\& Returns :
\& Args    : the term relationship to persist
.Ve
.SS "_persist_ontology"
.IX Subsection "_persist_ontology"
.Vb 4
\& Title   : _persist_ontology
\& Usage   :
\& Function: Perists the ontology itself to the database, by either
\&           inserting or updating it.
\&
\&           Note that this will only create or update the ontology as
\&           an entity, not any of its terms, relationships, or
\&           relationship types.
\&
\& Example :
\& Returns : the ontology as a persistent object with primary key
\& Args    : the ontology to persist as a Bio::Ontology::OntologyI
\&           compliant object
.Ve
