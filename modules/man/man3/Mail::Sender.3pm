.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sender 3pm"
.TH Sender 3pm "2014-07-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Mail::Sender \- module for sending mails with attachments through an SMTP server
.PP
Version 0.8.23
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use Mail::Sender;
\& $sender = new Mail::Sender
\&  {smtp => \*(Aqmail.yourdomain.com\*(Aq, from => \*(Aqyour@address.com\*(Aq};
\& $sender\->MailFile({to => \*(Aqsome@address.com\*(Aq,
\&  subject => \*(AqHere is the file\*(Aq,
\&  msg => "I\*(Aqm sending you the list you wanted.",
\&  file => \*(Aqfilename.txt\*(Aq});
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Mail::Sender\*(C'\fR provides an object oriented interface to sending mails.
It doesn't need any outer program. It connects to a mail server
directly from Perl, using Socket.
.PP
Sends mails directly from Perl through a socket connection.
.SH "new Mail::Sender"
.IX Header "new Mail::Sender"
.Vb 2
\& new Mail::Sender ([from [,replyto [,to [,smtp [,subject [,headers [,boundary]]]]]]])
\& new Mail::Sender {[from => \*(Aqsomebody@somewhere.com\*(Aq] , [to => \*(Aqelse@nowhere.com\*(Aq] [, ...]}
.Ve
.PP
Prepares a sender. This doesn't start any connection to the server. You
have to use \f(CW\*(C`$Sender\-\*(C'\fROpen> or \f(CW\*(C`$Sender\-\*(C'\fROpenMultipart> to start
talking to the server.
.PP
The parameters are used in subsequent calls to \f(CW\*(C`$Sender\-\*(C'\fROpen> and
\&\f(CW\*(C`$Sender\-\*(C'\fROpenMultipart>. Each such call changes the saved variables.
You can set \f(CW\*(C`smtp\*(C'\fR, \f(CW\*(C`from\*(C'\fR and other options here and then use the info
in all messages.
.PP
P.S.: The two snippets of code both contain square brackets. They mean a different thing though. In the first case
they denote the optional parameters (square brackets had been used to mean this in various docs for a long time),
in the second case they denote actual anonymous array reference literals ... except for the last pair.
In general the squares that mean \*(L"this part is optional\*(R" will have a comma as the first character in their content,
the literal ones will not.
.SS "Parameters"
.IX Subsection "Parameters"
.IP "from" 4
.IX Item "from"
\&\f(CW\*(C`\*(C'\fR=> the sender's e\-mail address
.IP "fake_from" 4
.IX Item "fake_from"
\&\f(CW\*(C`\*(C'\fR=> the address that will be shown in headers.
.Sp
If not specified we use the value of \f(CW\*(C`from\*(C'\fR.
.IP "replyto" 4
.IX Item "replyto"
\&\f(CW\*(C`\*(C'\fR=> the reply-to address
.IP "to" 4
.IX Item "to"
\&\f(CW\*(C`\*(C'\fR=> the recipient's address(es)
.Sp
This parameter may be either a comma separated list of email addresses
or a reference to a list of addresses.
.IP "fake_to" 4
.IX Item "fake_to"
\&\f(CW\*(C`\*(C'\fR=> the recipient's address that will be shown in headers.
If not specified we use the value of \*(L"to\*(R".
.Sp
If the list of addresses you want to send your message to is long or if you do not want
the recipients to see each other's address set the \f(CW\*(C`fake_to\*(C'\fR parameter to some informative,
yet bogus, address or to the address of your mailing/distribution list.
.IP "cc" 4
.IX Item "cc"
\&\f(CW\*(C`\*(C'\fR=> address(es) to send a copy (\s-1CC:\s0) to
.IP "fake_cc" 4
.IX Item "fake_cc"
\&\f(CW\*(C`\*(C'\fR=> the address that will be shown in headers.
.Sp
If not specified we use the value of \*(L"cc\*(R".
.IP "bcc" 4
.IX Item "bcc"
\&\f(CW\*(C`\*(C'\fR=> address(es) to send a copy (\s-1BCC:\s0 or blind carbon copy).
these addresses will not be visible in the mail!
.IP "smtp" 4
.IX Item "smtp"
\&\f(CW\*(C`\*(C'\fR=> the \s-1IP\s0 or domain address of your \s-1SMTP \s0(mail) server
.Sp
This is the name of your \s-1LOCAL\s0 mail server, do \s-1NOT\s0 try
to contact directly the adressee's mailserver! That would be slow and buggy,
your script should only pass the messages to the nearest mail server and leave
the rest to it. Keep in mind that the recipient's server may be down temporarily.
.IP "port" 4
.IX Item "port"
\&\f(CW\*(C`\*(C'\fR=> the \s-1TCP/IP\s0 port used form the connection. By default getservbyname('smtp', 'tcp')||25.
You should only need to use this option if your mail server waits on a nonstandard port.
.IP "subject" 4
.IX Item "subject"
\&\f(CW\*(C`\*(C'\fR=> the subject of the message
.IP "headers" 4
.IX Item "headers"
\&\f(CW\*(C`\*(C'\fR=> the additional headers
.Sp
You may use this parameter to add custom headers into the message. The parameter may
be either a string containing the headers in the right format or a hash containing the headers
and their values.
.IP "boundary" 4
.IX Item "boundary"
\&\f(CW\*(C`\*(C'\fR=> the message boundary
.Sp
You usually do not have to change this, it might only come in handy if you need
to attach a multipart mail created by Mail::Sender to your message as a single part.
Even in that case any problems are unlikely.
.IP "multipart" 4
.IX Item "multipart"
\&\f(CW\*(C`\*(C'\fR=> the \s-1MIME\s0 subtype for the whole message (Mixed/Related/Alternative)
.Sp
You may need to change this setting if you want to send a \s-1HTML\s0 body with some
inline images, or if you want to post the message in plain text as well as
\&\s-1HTML \s0(alternative). See the examples at the end of the docs.
You may also use the nickname \*(L"subtype\*(R".
.IP "ctype" 4
.IX Item "ctype"
\&\f(CW\*(C`\*(C'\fR=> the content type of a single part message or the body of the multipart one.
.Sp
Please do not confuse these two. The 'multipart' parameter is used to specify
the overall content type of a multipart message (for example a \s-1HTML\s0 document
with inlined images) while ctype is an ordinary content type for a single
part message or the body of a multipart message.
.IP "encoding" 4
.IX Item "encoding"
\&\f(CW\*(C`\*(C'\fR=> encoding of a single part message or the body of a multipart message.
.Sp
If the text of the message contains some extended characters or
very long lines you should use 'encoding => \*(L"Quoted\-printable\*(R"' in the
call to \fIOpen()\fR, \fIOpenMultipart()\fR, \fIMailMsg()\fR or \fIMailFile()\fR.
.Sp
Keep in mind that if you use some encoding you should either use \fISendEnc()\fR
or encode the data yourself !
.IP "charset" 4
.IX Item "charset"
\&\f(CW\*(C`\*(C'\fR=> the charset of the single part message or the body of the multipart one
.IP "client" 4
.IX Item "client"
\&\f(CW\*(C`\*(C'\fR=> the name of the client computer.
.Sp
During the connection you send
the mailserver your computer's name. By default Mail::Sender sends
\&\f(CW\*(C`(gethostbyname \*(Aqlocalhost\*(Aq)[0]\*(C'\fR.
If that is not the address you need, you can specify a different one.
.IP "priority" 4
.IX Item "priority"
\&\f(CW\*(C`\*(C'\fR=> the message priority number
.Sp
1 = highest, 2 = high, 3 = normal, 4 = low, 5 = lowest
.IP "confirm" 4
.IX Item "confirm"
\&\f(CW\*(C`\*(C'\fR=> whether you request reading or delivery confirmations and to what addresses:
.Sp
.Vb 5
\&        "delivery" \- only delivery, to the C<from> address
\&        "reading" \- only reading, to the C<from> address
\&        "delivery, reading" \- both confirmations, to the C<from> address
\&        "delivery: my.other@address.com" \- only delivery, to my.other@address.com
\&        ...
.Ve
.Sp
Keep in mind though that neither of those is guaranteed to work. Some servers/mail clients do not support
this feature and some users/admins may have disabled it. So it's possible that your mail was delivered and read,
but you won't get any confirmation!
.IP "\s-1ESMPT\s0" 4
.IX Item "ESMPT"
.Vb 6
\&        ESMTP => {
\&                NOTIFY => \*(AqSUCCESS,FAILURE,DELAY\*(Aq,
\&                RET => \*(AqHDRS\*(Aq,
\&                ORCPT => \*(Aqrfc822;my.other@address.com\*(Aq,
\&                ENVID => \*(Aqiuhsdfobwoe8t237\*(Aq,
\&        }
.Ve
.Sp
This option contains data for \s-1SMTP\s0 extensions, for example it allows you to request delivery
status notifications according to \s-1RFC1891.\s0
.Sp
\&\s-1NOTIFY \-\s0 to specify the conditions under which a delivery status notification should be generated.
Should be either \*(L"\s-1NEVER\*(R"\s0 or a comma separated list of \*(L"\s-1SUCCESS\*(R", \*(L"FAILURE\*(R" \s0 and \*(L"\s-1DELAY\*(R".\s0
.Sp
\&\s-1ORCPT \-\s0 used to convey the \*(L"original\*(R" (sender-specified) recipient address
.Sp
\&\s-1RET \-\s0 to request that Delivery Status Notifications containing an indication of delivery
failure either return the entire contents of a message or only the message headers. Must be either
\&\s-1FULL\s0 or \s-1HDRS\s0
.Sp
\&\s-1ENVID \-\s0 used to propagate an identifier for this message transmission envelope, which is also
known to the sender and will, if present, be returned in any Delivery Status Notifications  issued
for this transmission
.Sp
You do not need to worry about encoding the \s-1ORCPT\s0 or \s-1ENVID\s0 parameters.
.Sp
If the \s-1SMTP\s0 server you connect to doesn't support this extension, the options will be ignored.
.IP "debug" 4
.IX Item "debug"
\&\f(CW\*(C`\*(C'\fR=> \f(CW"/path/to/debug/file.txt"\fR
.Sp
or
.Sp
\&\f(CW\*(C`\*(C'\fR=>  \e*FILEHANDLE
.Sp
or
.Sp
\&\f(CW\*(C`\*(C'\fR=> \f(CW$FH\fR
.Sp
All the conversation with the server will be logged to that file or handle.
All lines in the file should end with \s-1CRLF \s0(the Windows and Internet format).
If even a single one of them does not, please let me know!
.Sp
If you pass the path to the log file, Mail::Sender will overwrite it. If you want to append to the file,
you have to open it yourself and pass the filehandle:
.Sp
.Vb 6
\&        open my $DEBUG, ">> /path/to/debug/file.txt"
\&                or die "Can\*(Aqt open the debug file: $!\en"
\&        $sender = new Mail::Sender ({
\&                ...
\&                debug => $DEBUG,
\&        });
.Ve
.IP "debug_level" 4
.IX Item "debug_level"
Only taken into account if the \f(CW\*(C`debug\*(C'\fR option is specified.
.Sp
.Vb 4
\&        1 \- only log the conversation with the server, skip all message data
\&        2 \- log the conversation and message headers
\&        3 \- log the conversation and the message and part headers
\&        4 \- log everything (default)
.Ve
.IP "auth" 4
.IX Item "auth"
the \s-1SMTP\s0 authentication protocol to use to login to the server
currently the only ones supported are \s-1LOGIN, PLAIN, CRAM\-MD5\s0 and \s-1NTLM.\s0
.Sp
Some protocols have module dependencies. \s-1CRAM\-MD5\s0 depends on
Digest::HMAC_MD5 and \s-1NTLM\s0 on Authen::NTLM.
.Sp
You may add support for other authentication protocols yourself. See below.
.IP "authid" 4
.IX Item "authid"
the username used to login to the server
.IP "authpwd" 4
.IX Item "authpwd"
the password used to login to the server
.IP "authdomain" 4
.IX Item "authdomain"
the domain name. Used optionaly by the \s-1NTLM\s0 authentication.
.Sp
Other authentication protocols may use other options as well.
They should all start with \*(L"auth\*(R" though.
.Sp
Please see the authentication section bellow.
.IP "auth_encoded" 4
.IX Item "auth_encoded"
If set to a true value the \s-1LOGIN\s0 authentication assumes the authid and authpwd
is already base64 encoded.
.IP "tls_allowed" 4
.IX Item "tls_allowed"
If set to a true value Mail::Sender attempts to use \s-1LTS \s0(\s-1SSL\s0 encrypted connection) whenever
the server supports it and you have IO::Socket::SSL and Net::SSLeay.
.Sp
The default value of this option is \s-1TRUE\s0! This means that if Mail::Server can send the data encrypted, it will.
.IP "tls_required" 4
.IX Item "tls_required"
If you set this option to a true value, the module will fail whenever it's unable to use \s-1TLS.\s0
.IP "ssl_..." 4
.IX Item "ssl_..."
The ssl_version, ssl_verify_mode, ssl_ca_path, ssl_ca_file, ssl_verifycb_name, ssl_verifycn_schema and ssl_hostname
options (if specified) are passed to IO::Socket::SSL\->\fIstart_SSL()\fR. The default for the first two is 'TLSv1' and \fIIO::Socket::SSL::SSL_VERIFY_NONE()\fR.
.Sp
If you change the ssl_verify_mode to \s-1SSL_VERIFY_PEER,\s0 you may need to specify also the ssl_ca_file. If you have Mozilla::CA installed, then setting it to
\&\fIMozilla::CA::SSL_ca_file()\fR may help.
.IP "keepconnection" 4
.IX Item "keepconnection"
If set to a true value causes the Mail::Sender to keep the connection open for several messages.
The connection will be closed if you call the \fIClose()\fR method with a true value or if you call Open,
OpenMultipart, MailMsg or MailFile with the \*(L"smtp\*(R" parameter.
This means that if you want the object to keep the connection you should pass the \*(L"smtp\*(R" either to \*(L"new Mail::Sender\*(R"
or only to the first Open, OpenMultipart, MailMsg or MailFile!
.IP "skip_bad_recipients" 4
.IX Item "skip_bad_recipients"
If this option is set to false or not specified then Mail::Sender stops trying to send a message as soon as
the first recipient's address fails. If it is set to a true value Mail::Sender skips the bad addresses and tries
to send the message at least to the good ones. If all addresses are rejected by the server it reports an
\&\*(L"All recipients were rejected\*(R" message.
.Sp
If any addresses were skipped the \f(CW\*(C`$sender\->{\*(Aqskipped_recipients\*(Aq}\*(C'\fR will be a reference to a hash
containing the failed address and the server's response.
.IP "createmessageid" 4
.IX Item "createmessageid"
This option allows you to overwrite the function that generates the message IDs for the emails.
The function gets the \*(L"pure\*(R" sender's address as it's only parameter and is supposed to return a string.
See the MessageID subroutine in Mail::Sender.pm.
.Sp
If you want to specify a message id you can also use the \*(L"messageid\*(R" parameter for the Open, OpenMultipart,
MailMsg or MailFile methods.
.IP "on_errors" 4
.IX Item "on_errors"
This option allows you to affect the way Mail::Sender reports errors.
.Sp
.Vb 3
\&        => \*(Aqdie\*(Aq \- raise an exception
\&        => \*(Aqcode\*(Aq \- return the negative error code (default)
\&        => \*(Aqundef\*(Aq \- return an undef
.Ve
.Sp
\&\f(CW$Mail::Sender::Error\fR, \f(CW$sender\fR\->{'error'} and \f(CW$sender\fR\->{'error_msg'} are set in all the cases.
.Sp
All methods return the \f(CW$sender\fR object if they succeed.
.Sp
P.S.: The die_on_errors option is deprecated. You may still use it, but it may be removed in future versions!
.SS "Return codes"
.IX Subsection "Return codes"
.Vb 1
\&  ref to a Mail::Sender object =  success
\&
\&  \-1 = $smtphost unknown
\&  \-2 = socket() failed
\&  \-3 = connect() failed
\&  \-4 = service not available
\&  \-5 = unspecified communication error
\&  \-6 = local user $to unknown on host $smtp
\&  \-7 = transmission of message failed
\&  \-8 = argument $to empty
\&  \-9 = no message specified in call to MailMsg or MailFile
\&  \-10 = no file name specified in call to SendFile or MailFile
\&  \-11 = file not found
\&  \-12 = not available in singlepart mode
\&  \-13 = site specific error
\&  \-14 = connection not established. Did you mean MailFile instead of SendFile?
\&  \-15 = no SMTP server specified
\&  \-16 = no From: address specified
\&  \-17 = authentication protocol not accepted by the server
\&  \-18 = login not accepted
\&  \-19 = authentication protocol is not implemented
\&  \-20 = all recipients were rejected by the server
\&  \-21 = file specified as an attachment cannot be read
\&  \-22 = failed to open the specified debug file for writing
\&  \-23 = STARTTLS failed (for SSL or TLS encrypted connections)
\&  \-24 = IO::Socket::SSL\->start_SSL failed
\&  \-25 = TLS required by the specified options, but the required modules are not available. Need IO::Socket::SSL and Net::SSLeay
\&  \-26 = TLS required by the specified options, but the server doesn\*(Aqt support it
\&  \-27 = unknown encoding specified for the mail body, part or attachment. Only base64, quoted\-printable, 7bit and 8bit supported.
.Ve
.PP
\&\f(CW$Mail::Sender::Error\fR contains a textual description of last error.
.SH "METHODS"
.IX Header "METHODS"
.SS "Open"
.IX Subsection "Open"
.Vb 2
\& Open([from [, replyto [, to [, smtp [, subject [, headers]]]]]])
\& Open({[from => "somebody@somewhere.com"] , [to => "else@nowhere.com"] [,...]})
.Ve
.PP
Opens a new message. If some parameters are unspecified or empty, it uses
the parameters passed to the "\f(CW\*(C`$Sender=new Mail::Sender(...)\*(C'\fR";
.PP
See \f(CW\*(C`new Mail::Sender\*(C'\fR for info about the parameters.
.PP
The only additional parameter that may not be specified directly in the \f(CW\*(C`new Mail::Sender\*(C'\fR
is messageid. If you set this option then the message will be sent with this Message-ID,
otherwise a new Message \s-1ID\s0 will be generated out of the sender's address, current date+time
and a random number (or by the function you specified in the \f(CW\*(C`createmessageid\*(C'\fR option).
.PP
After the message is sent \f(CW\*(C`$sender\->{messageid}\*(C'\fR will contain the Message-ID with
which the message was sent.
.PP
Returns ref to the Mail::Sender object if successful.
.SS "OpenMultipart"
.IX Subsection "OpenMultipart"
.Vb 2
\& OpenMultipart([from [, replyto [, to [, smtp [, subject [, headers [, boundary]]]]]]])
\& OpenMultipart({[from => "somebody@somewhere.com"] , [to => "else@nowhere.com"] [,...]})
.Ve
.PP
Opens a multipart message. If some parameters are unspecified or empty, it uses
the parameters passed to the \f(CW\*(C`$Sender=new Mail::Sender(...)\*(C'\fR.
.PP
See \f(CW\*(C`new Mail::Sender\*(C'\fR for info about the parameters.
.PP
Returns ref to the Mail::Sender object if successful.
.SS "MailMsg"
.IX Subsection "MailMsg"
.Vb 3
\& MailMsg([from [, replyto [, to [, smtp [, subject [, headers]]]]]], message)
\& MailMsg({[from => "somebody@somewhere.com"]
\&          [, to => "else@nowhere.com"] [,...], msg => "Message"})
.Ve
.PP
Sends a message. If a mail in \f(CW$sender\fR is opened it gets closed
and a new mail is created and sent. \f(CW$sender\fR is then closed.
If some parameters are unspecified or empty, it uses
the parameters passed to the "\f(CW\*(C`$Sender=new Mail::Sender(...)\*(C'\fR";
.PP
See \f(CW\*(C`new Mail::Sender\*(C'\fR for info about the parameters.
.PP
The module was made so that you could create an object initialized with
all the necesary options and then send several messages without need to
specify the \s-1SMTP\s0 server and others each time. If you need to send only
one mail using \fIMailMsg()\fR or \fIMailFile()\fR you do not have to create a named
object and then call the method. You may do it like this :
.PP
.Vb 1
\& (new Mail::Sender)\->MailMsg({smtp => \*(Aqmail.company.com\*(Aq, ...});
.Ve
.PP
Returns ref to the Mail::Sender object if successful.
.SS "MailFile"
.IX Subsection "MailFile"
.Vb 4
\& MailFile([from [, replyto [, to [, smtp [, subject [, headers]]]]]], message, file(s))
\& MailFile({[from => "somebody@somewhere.com"]
\&           [, to => "else@nowhere.com"] [,...],
\&           msg => "Message", file fs=> "File"})
.Ve
.PP
Sends one or more files by mail. If a mail in \f(CW$sender\fR is opened it gets closed
and a new mail is created and sent. \f(CW$sender\fR is then closed.
If some parameters are unspecified or empty, it uses
the parameters passed to the "\f(CW\*(C`$Sender=new Mail::Sender(...)\*(C'\fR";
.PP
The \f(CW\*(C`file\*(C'\fR parameter may be a \*(L"filename\*(R", a \*(L"list, of, file, names\*(R" or a \e@list_of_file_names.
.PP
see \f(CW\*(C`new Mail::Sender\*(C'\fR for info about the parameters.
.PP
Just keep in mind that parameters like ctype, charset and encoding
will be used for the attached file, not the body of the message.
If you want to specify those parameters for the body you have to use
b_ctype, b_charset and b_encoding. Sorry.
.PP
Returns ref to the Mail::Sender object if successful.
.SS "Send"
.IX Subsection "Send"
.Vb 1
\& Send(@strings)
.Ve
.PP
Prints the strings to the socket. Doesn't add any end-of-line characters.
Doesn't encode the data! You should use \f(CW\*(C`\er\en\*(C'\fR as the end-of-line!
.PP
\&\s-1UNLESS YOU ARE ABSOLUTELY SURE YOU KNOW WHAT YOU ARE DOING
YOU SHOULD USE\s0 \fISendEnc()\fR \s-1INSTEAD\s0!
.PP
Returns the object if successful.
.SS "SendLine"
.IX Subsection "SendLine"
.Vb 1
\& SendLine(@strings)
.Ve
.PP
Prints the strings to the socket. Adds the end-of-line character at the end.
Doesn't encode the data! You should use \f(CW\*(C`\er\en\*(C'\fR as the end-of-line!
.PP
\&\s-1UNLESS YOU ARE ABSOLUTELY SURE YOU KNOW WHAT YOU ARE DOING
YOU SHOULD USE\s0 \fISendLineEnc()\fR \s-1INSTEAD\s0!
.PP
Returns the object if successful.
.SS "print"
.IX Subsection "print"
Alias to \fISendEnc()\fR.
.PP
Keep in mind that you can't write :
.PP
.Vb 1
\&        print $sender "...";
.Ve
.PP
you have to use
.PP
.Vb 1
\&        $sender\->print("...");
.Ve
.PP
If you want to be able to print into the message as if it was a normal file handle take a look at \f(CW\*(C`GetHandle\*(C'\fR()
.SS "SendEnc"
.IX Subsection "SendEnc"
.Vb 1
\& SendEnc(@strings)
.Ve
.PP
Prints the strings to the socket. Doesn't add any end-of-line characters.
.PP
Encodes the text using the selected encoding (none/Base64/Quoted\-printable)
.PP
Returns the object if successful.
.SS "SendLineEnc"
.IX Subsection "SendLineEnc"
.Vb 1
\& SendLineEnc(@strings)
.Ve
.PP
Prints the strings to the socket and adds the end-of-line character at the end.
Encodes the text using the selected encoding (none/Base64/Quoted\-printable).
.PP
Do \s-1NOT\s0 mix up /Send(Line)?(Ex)?/ and /Send(Line)?Enc/! SendEnc does some buffering
necessary for correct Base64 encoding, and /Send(Ex)?/ is not aware of that!
.PP
Usage of /Send(Line)?(Ex)?/ in non xBIT parts not recommended.
Using \f(CW\*(C`Send(encode_base64($string))\*(C'\fR may work, but more likely it will not!
In particular if you use several such to create one part,
the data is very likely to get crippled.
.PP
Returns the object if successful.
.SS "SendEx"
.IX Subsection "SendEx"
.Vb 1
\& SendEx(@strings)
.Ve
.PP
Prints the strings to the socket. Doesn't add any end-of-line characters.
Changes all end-of-lines to \f(CW\*(C`\er\en\*(C'\fR. Doesn't encode the data!
.PP
\&\s-1UNLESS YOU ARE ABSOLUTELY SURE YOU KNOW WHAT YOU ARE DOING
YOU SHOULD USE\s0 \fISendEnc()\fR \s-1INSTEAD\s0!
.PP
Returns the object if successful.
.SS "SendLineEx"
.IX Subsection "SendLineEx"
.Vb 1
\& SendLineEx(@strings)
.Ve
.PP
Prints the strings to the socket. Adds an end-of-line character at the end.
Changes all end-of-lines to \f(CW\*(C`\er\en\*(C'\fR. Doesn't encode the data!
.PP
\&\s-1UNLESS YOU ARE ABSOLUTELY SURE YOU KNOW WHAT YOU ARE DOING
YOU SHOULD USE\s0 \fISendEnc()\fR \s-1INSTEAD\s0!
.PP
Returns the object if successful.
.SS "Part"
.IX Subsection "Part"
.Vb 3
\& Part( I<description>, I<ctype>, I<encoding>, I<disposition> [, I<content_id> [, I<msg>]]);
\& Part( {[description => "desc"], [ctype => "content/type"], [encoding => "..."],
\&     [disposition => "..."], [content_id => "..."], [msg => ...]});
.Ve
.PP
Prints a part header for the multipart message and (if specified) the contents.
The undefined or empty variables are ignored.
.IP "description" 2
.IX Item "description"
The title for this part.
.IP "ctype" 2
.IX Item "ctype"
the content type (\s-1MIME\s0 type) of this part. May contain some other
parameters, such as \fBcharset\fR or \fBname\fR.
.Sp
Defaults to \*(L"application/octet\-stream\*(R".
.Sp
Since 0.8.00 you may use even \*(L"multipart/...\*(R" types. Such a multipart part should be
closed by a call to \f(CW$sender\fR\->EndPart($ctype).
.Sp
.Vb 6
\&        ...
\&        $sender\->Part({ctype => "multipart/related", ...});
\&                $sender\->Part({ctype => \*(Aqtext/html\*(Aq, ...});
\&                $sender\->Attach({file => \*(Aqsome_image.gif\*(Aq, content_id => \*(Aqfoo\*(Aq, ...});
\&        $sender\->EndPart("multipart/related");
\&        ...
.Ve
.Sp
Please see the examples below.
.IP "encoding" 2
.IX Item "encoding"
the encoding used for this part of message. Eg. Base64, Uuencode, 7BIT
\&...
.Sp
Defaults to \*(L"7BIT\*(R".
.IP "disposition" 2
.IX Item "disposition"
This parts disposition. Eg: 'attachment; filename=\*(L"send.pl\*(R"'.
.Sp
Defaults to \*(L"attachment\*(R". If you specify \*(L"none\*(R" or "", the
Content-Disposition: line will not be included in the headers.
.IP "content_id" 2
.IX Item "content_id"
The content id of the part, used in multipart/related.
If not specified, the header is not included.
.IP "msg" 2
.IX Item "msg"
The content of the part. You do not have to specify the content here, you may use \fISendEnc()\fR
to add content to the part.
.IP "charset" 2
.IX Item "charset"
The charset of the part.
.PP
Returns the Mail::Sender object if successful, negative error code if not.
.SS "Body"
.IX Subsection "Body"
.Vb 2
\& Body([charset [, encoding [, content\-type]]]);
\& Body({charset => \*(Aq...\*(Aq, encoding => \*(Aq...\*(Aq, ctype => \*(Aq...\*(Aq, msg => \*(Aq...\*(Aq);
.Ve
.PP
Sends the head of the multipart message body. You can specify the
charset and the encoding. Default is \*(L"\s-1US\-ASCII\*(R",\*(L"7BIT\*(R",\s0'text/plain'.
.PP
If you pass undef or zero as the parameter, this function uses the default
value:
.PP
.Vb 1
\&    Body(0,0,\*(Aqtext/html\*(Aq);
.Ve
.PP
Returns the Mail::Sender object if successful, negative error code if not.
You should \s-1NOT\s0 use this method in single part messages, that is, it works after \fIOpenMultipart()\fR,
but has no meaning after \fIOpen()\fR!
.SS "SendFile"
.IX Subsection "SendFile"
Alias to \fIAttach()\fR
.SS "Attach"
.IX Subsection "Attach"
.Vb 3
\& Attach( I<description>, I<ctype>, I<encoding>, I<disposition>, I<file>);
\& Attach( { [description => "desc"] , [ctype => "ctype"], [encoding => "encoding"],
\&             [disposition => "disposition"], file => "file"});
\&
\& Sends a file as a separate part of the mail message. Only in multipart mode.
.Ve
.IP "description" 2
.IX Item "description"
The title for this part.
.IP "ctype" 2
.IX Item "ctype"
the content type (\s-1MIME\s0 type) of this part. May contain some other
parameters, such as \fBcharset\fR or \fBname\fR.
.Sp
Defaults to \*(L"application/octet\-stream\*(R".
.IP "encoding" 2
.IX Item "encoding"
the encoding used for this part of message. Eg. Base64, Uuencode, 7BIT
\&...
.Sp
Defaults to \*(L"Base64\*(R".
.IP "disposition" 2
.IX Item "disposition"
This parts disposition. Eg: 'attachment; filename=\*(L"send.pl\*(R"'. If you use
\&'attachment; filename=*' the * will be replaced by the respective names
of the sent files.
.Sp
Defaults to \*(L"attachment; filename=*\*(R". If you do not want to include this header use
"" as the value.
.IP "file" 2
.IX Item "file"
The name of the file to send or a 'list, of, names' or a
['reference','to','a','list','of','filenames']. Each file will be sent as
a separate part.
.Sp
Please keep in mind that if you pass a string as this parameter the module
will split it on commas! If your filenames may contain commas and you
want to be sure they are sent correctly you have to use the reference to array
format:
.Sp
.Vb 1
\&        file => [ $filename],
.Ve
.IP "content_id" 2
.IX Item "content_id"
The content id of the message part. Used in multipart/related.
.Sp
.Vb 3
\& Special values:
\&  "*" => the name of the file
\&  "#" => autoincremented number (starting from 0)
.Ve
.PP
Returns the Mail::Sender object if successful, negative error code if not.
.SS "EndPart"
.IX Subsection "EndPart"
.Vb 1
\& $sender\->EndPart($ctype);
.Ve
.PP
Closes a multipart part.
.PP
If the \f(CW$ctype\fR is not present or evaluates to false, only the current \s-1SIMPLE\s0 part is closed!
Don't do that unless you are really sure you know what you are doing.
.PP
It's best to always pass to the \->\fIEndPart()\fR the content type of the corresponding \->\fIPart()\fR.
.SS "Close"
.IX Subsection "Close"
.Vb 2
\& $sender\->Close;
\& $sender\->Close(1);
.Ve
.PP
Close and send the email message. If you pass a true value to the method the connection will be closed even
if the \*(L"keepconnection\*(R" was specified. You should only keep the connection open if you plan to send another
message immediately. And you should not keep it open for hundreds of emails even if you do send them all in a row.
.PP
This method should be called automatically when destructing the object, but you should not rely on it. If you want to be sure
your message \s-1WAS\s0 processed by the \s-1SMTP\s0 server you \s-1SHOULD\s0 call \fIClose()\fR explicitely.
.PP
Returns the Mail::Sender object if successful, negative error code if not, zero if \f(CW$sender\fR was not connected at all.
The zero usually means that the Open/OpenMultipart failed and you did not test its return value.
.SS "Cancel"
.IX Subsection "Cancel"
.Vb 1
\& $sender\->Cancel;
.Ve
.PP
Cancel an opened message.
.PP
SendFile and other methods may set \f(CW$sender\fR\->{'error'}.
In that case \*(L"undef \f(CW$sender\fR\*(R" calls \f(CW\*(C`$sender\-\*(C'\fR>Cancel not \f(CW\*(C`$sender\-\*(C'\fR>Close!!!
.PP
Returns the Mail::Sender object if successful, negative error code if not.
.SS "QueryAuthProtocols"
.IX Subsection "QueryAuthProtocols"
.Vb 2
\&        @protocols = $sender\->QueryAuthProtocols();
\&        @protocols = $sender\->QueryAuthProtocols( $smtpserver);
.Ve
.PP
Queryies the server (specified either in the default options for Mail::Sender,
the \*(L"new Mail::Sender\*(R" command or as a parameter to this method for
the authentication protocols it supports.
.SS "GetHandle"
.IX Subsection "GetHandle"
Returns a \*(L"filehandle\*(R" to which you can print the message or file to attach or whatever.
The data you print to this handle will be encoded as necessary. Closing this handle closes
either the message (for single part messages) or the part.
.PP
.Vb 6
\&        $sender\->Open({...});
\&        my $handle = $sender\->GetHandle();
\&        print $handle "Hello world.\en"
\&        my ($mday,$mon,$year) = (localtime())[3,4,5];
\&        printf $handle "Today is %04d/%02d/%02d.", $year+1900, $mon+1, $mday;
\&        close $handle;
.Ve
.PP
P.S.: There is a big difference between the handle stored in \f(CW$sender\fR\->{'socket'} and the handle
returned by this function ! If you print something to \f(CW$sender\fR\->{'socket'} it will be sent to the server
without any modifications, encoding, escaping, ...
You should \s-1NOT\s0 touch the \f(CW$sender\fR\->{'socket'} unless you really really know what you are doing.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "GuessCType"
.IX Subsection "GuessCType"
.Vb 1
\&        $ctype = GuessCType $filename, $filepath;
.Ve
.PP
Guesses the content type based on the filename or the file contents.
This function is used when you attach a file and do not specify the content type.
It is not exported by default!
.PP
The builtin version uses the filename extension to guess the type.
Currently there are only a few extensions defined, you may add other extensions this way:
.PP
.Vb 2
\&        $Mail::Sender::CTypes{\*(AqEXT\*(Aq} = \*(Aqcontent/type\*(Aq;
\&        ...
.Ve
.PP
The extension has to be in \s-1UPPERCASE\s0 and will be matched case sensitively.
.PP
The package now includes three addins improving the guesswork. If you \*(L"use\*(R" one of them in your script,
it replaces the builtin \fIGuessCType()\fR subroutine with a better one:
.PP
.Vb 6
\&        Mail::Sender::CType::Win32
\&                Win32 only, the content type is read from the registry
\&        Mail::Sender::CType::Ext
\&                any OS, a longer list of extensions from A. Guillaume
\&        Mail::Sender::CType::LWP
\&                any OS, uses LWP::MediaTypes::guess_media_type
.Ve
.SS "ResetGMTdiff"
.IX Subsection "ResetGMTdiff"
.Vb 1
\&        ResetGMTdiff()
.Ve
.PP
The module computes the local vs. \s-1GMT\s0 time difference to include in the timestamps
added into the message headers. As the time difference may change due to summer
savings time changes you may want to reset the time difference ocassionaly
in long running programs.
.SH "CONFIG"
.IX Header "CONFIG"
If you create a file named Sender.config in the same directory where
Sender.pm resides, this file will be \*(L"require\*(R"d as soon as you \*(L"use
Mail::Sender\*(R" in your script. Of course the Sender.config \s-1MUST \s0\*(L"return a
true value\*(R", that is it has to be succesfully compiled and the last
statement must return a true value. You may use this to forbide the use
of Mail::Sender to some users.
.PP
You may define the default settings for new Mail::Sender objects and do
a few more things.
.PP
The default options are stored in hash \f(CW%Mail::Sender::default\fR. You may
use all the options you'd use in \f(CW\*(C`new\*(C'\fR, \f(CW\*(C`Open\*(C'\fR, \f(CW\*(C`OpenMultipart\*(C'\fR,
\&\f(CW\*(C`MailMsg\*(C'\fR or \f(CW\*(C`MailFile\*(C'\fR.
.PP
.Vb 7
\& Eg.
\&  %default = (
\&    smtp => \*(Aqmail.yourhost.cz\*(Aq,
\&    from => getlogin.\*(Aqyourhost.cz\*(Aq,
\&    client => getlogin.\*(Aq.yourhost.cz\*(Aq
\&  );
\&  # of course you will use your own mail server here !
.Ve
.PP
The other options you may set here (or later of course) are
\&\f(CW$Mail::Sender::SITE_HEADERS\fR, \f(CW$Mail::Sender::NO_X_MAILER\fR and
\&\f(CW$Mail::Sender::NO_DATE\fR. (These are plain old scalar variables, there is no
function or method for modifying them. Just set them to anything you need.)
.PP
The \f(CW$Mail::Sender::SITE_HEADERS\fR may contain headers that will be added
to each mail message sent by this script, the \f(CW$Mail::Sender::NO_X_MAILER\fR
disables the header item specifying that the message was sent by
Mail::Sender and \f(CW$Mail::Sender::NO_DATE\fR turns off the Date: header generation.
.PP
!!! \f(CW$Mail::Sender::SITE_HEADERS\fR may \s-1NEVER\s0 end with \er\en !!!
.PP
If you want to set the \f(CW$Mail::Sender::SITE_HEADERS\fR for every script sent
from your server without your users being able to change it you may use
this hack:
.PP
.Vb 3
\& $loginname = something_that_identifies_the_user();
\& *Mail::Sender::SITE_HEADERS = \e"X\-Sender: $loginname via $0";
\& $Mail::Sender::NO_X_MAILER = 1;
.Ve
.PP
You may even \*(L"install\*(R" your custom function that will be evaluated for
each message just before contacting the server. You may change all the
options from within as well as stop sending the message.
.PP
All you have to do is to create a function named SiteHook in
Mail::Sender package. This function will get the Mail::Sender object as
its first argument. If it returns a \s-1TRUE\s0 value the message is sent,
if it returns \s-1FALSE\s0 the sending is canceled and the user gets
\&\*(L"Site specific error\*(R" error message.
.PP
If you want to give some better error message you may do it like this :
.PP
.Vb 10
\& sub SiteHook {
\&  my $self = shift;
\&  if (whatever($self)) {
\&    $self\->Error( SITEERROR);
\&    $Mail::Sender::Error = "I don\*(Aqt like this mail";
\&    return 0
\&  } else {
\&    return 1;
\&  }
\& }
.Ve
.PP
This example will ensure the from address is the users real address :
.PP
.Vb 6
\& sub SiteHook {
\&  my $self = shift;
\&  $self\->{\*(Aqfromaddr\*(Aq} = getlogin.\*(Aq@yoursite.com\*(Aq;
\&  $self\->{\*(Aqfrom\*(Aq} = getlogin.\*(Aq@yoursite.com\*(Aq;
\&  1;
\& }
.Ve
.PP
Please note that at this stage the from address is in two different
object properties.
.PP
\&\f(CW$self\fR\->{'from'} is the address as it will appear in the mail, that is
it may include the full name of the user or any other comment
( \*(L"Jan Krynicky <jenda@krynicky.cz>\*(R" for example), while the
\&\f(CW$self\fR\->{'fromaddr'} is realy just the email address per se and it will
be used in conversation with the \s-1SMTP\s0 server. It must be without
comments (\*(L"jenda@krynicky.cz\*(R" for example)!
.PP
Without write access to .../lib/Mail/Sender.pm or
\&.../lib/Mail/Sender.config your users will then be unable to get rid of
this header. Well ... everything is doable, if they are cheeky enough ... :\-(
.PP
So if you take care of some site with virtual servers for several
clients and implement some policy via \fISiteHook()\fR or
\&\f(CW$Mail::Sender::SITE_HEADERS\fR search the clients' scripts for \*(L"SiteHook\*(R"
and \*(L"\s-1SITE_HEADERS\*(R"\s0 from time to time. To see who's cheating.
.SH "AUTHENTICATION"
.IX Header "AUTHENTICATION"
If you get a \*(L"Local user \*(R"xxx@yyy.com\*(L" unknown on host \*(R"zzz"" message it usually means that
your mail server is set up to forbid mail relay. That is it only accepts messages to or from a local user.
If you need to be able to send a message with both the sender's and recipient's address remote, you
need to somehow authenticate to the server. You may need the help of the mail server's administrator
to find out what username and password and/or what authentication protocol are you supposed to use.
.PP
There are many authentication protocols defined for \s-1ESTMP,\s0 Mail::Sender natively supports
only \s-1PLAIN, LOGIN, CRAM\-MD5\s0 and \s-1NTLM \s0(please see the docs for \f(CW\*(C`new Mail::Sender\*(C'\fR).
.PP
If you want to know what protocols are supported by your server you may get the list by this:
.PP
.Vb 3
\&        /tmp# perl \-MMail::Sender \-e \*(AqMail::Sender\->printAuthProtocols("the.server.com")\*(Aq
\&  or
\&        c:\e> perl \-MMail::Sender \-e "Mail::Sender\->printAuthProtocols(\*(Aqthe.server.com\*(Aq)"
.Ve
.PP
There is one more way to authenticate. Some servers want you to login by \s-1POP3\s0 before you
can send a message. You have to use Net::POP3 or Mail::POP3Client to do this.
.SS "Other protocols"
.IX Subsection "Other protocols"
It is possible to add new authentication protocols to Mail::Sender. All you have to do is
to define a function Mail::Sender::Auth::PROTOCOL_NAME that will implement
the login. The function gets one parameter ... the Mail::Sender object.
It can access these properties:
.PP
.Vb 12
\&        $obj\->{\*(Aqsocket\*(Aq} : the socket to print to and read from
\&                you may use the send_cmd() function to send a request
\&                and read a response from the server
\&        $obj\->{\*(Aqauthid\*(Aq} : the username specified in the new Mail::Sender,
\&                Open or OpenMultipart call
\&        $obj\->{\*(Aqauthpwd\*(Aq} : the password
\&        $obj\->{auth...} : all unknown parameters passed to the constructor or the mail
\&                opening/creation methods are preserved in the object. If the protocol requires
\&                any other options, please use names starting with "auth". Eg. "authdomain", ...
\&        $obj\->{\*(Aqerror\*(Aq} : this should be set to a negative error number. Please use numbers
\&                below \-1000 for custom errors.
\&        $obj\->{\*(Aqerror_msg\*(Aq} : this should be set to the error message
\&
\&        If the login fails you should
\&                1) Set $Mail::Sender::Error to the error message
\&                2) Set $obj\->{\*(Aqerror_msg\*(Aq} to the error message
\&                2) Set $obj\->{\*(Aqerror\*(Aq} to a negative number
\&                3) return a negative number
\&        If it succeeds, please return "nothing" :
\&                return;
.Ve
.PP
Please use the protocols defined within Sender.pm as examples.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Object creation"
.IX Subsection "Object creation"
.Vb 3
\& ref ($sender = new Mail::Sender { from => \*(Aqsomebody@somewhere.com\*(Aq,
\&       smtp => \*(Aqmail.yourISP.com\*(Aq, boundary => \*(AqThis\-is\-a\-mail\-boundary\-435427\*(Aq})
\& or die "Error in mailing : $Mail::Sender::Error\en";
.Ve
.PP
or
.PP
.Vb 2
\& my $sender = new Mail::Sender { ... };
\& die "Error in mailing : $Mail::Sender::Error\en" unless ref $sender;
.Ve
.PP
or
.PP
.Vb 2
\& my $sender = new Mail::Sender { ..., on_errors => \*(Aqundef\*(Aq }
\&   or die "Error in mailing : $Mail::Sender::Error\en";
.Ve
.PP
You may specify the options either when creating the Mail::Sender object
or later when you open a message. You may also set the default options when
installing the module (See \f(CW\*(C`CONFIG\*(C'\fR section). This way the admin may set
the \s-1SMTP\s0 server and even the authentication options and the users do not have
to specify it again.
.PP
You should keep in mind that the way Mail::Sender reports failures depends on the 'on_errors'=>
option. If you set it to 'die' it throws an exception, if you set it to \f(CW\*(C`undef\*(C'\fR or \f(CW\*(Aqundef\*(Aq\fR it returns
undef and otherwise it returns a negative error code!
.SS "Simple single part message"
.IX Subsection "Simple single part message"
.Vb 10
\&        $sender = new Mail::Sender {
\&                smtp => \*(Aqmail.yourISP.com\*(Aq,
\&                from => \*(Aqsomebody@somewhere.com\*(Aq,
\&                on_errors => undef,
\&        }
\&                or die "Can\*(Aqt create the Mail::Sender object: $Mail::Sender::Error\en";
\&        $sender\->Open({
\&                to => \*(Aqmama@home.org, papa@work.com\*(Aq,
\&                cc => \*(Aqsomebody@somewhere.com\*(Aq,
\&                subject => \*(AqSorry, I\e\*(Aqll come later.\*(Aq
\&        })
\&                or die "Can\*(Aqt open the message: $sender\->{\*(Aqerror_msg\*(Aq}\en";
\&        $sender\->SendLineEnc("I\*(Aqm sorry, but thanks to the lusers,
\&                I\*(Aqll come at 10pm at best.");
\&        $sender\->SendLineEnc("\enHi, Jenda");
\&        $sender\->Close()
\&                or die "Failed to send the message: $sender\->{\*(Aqerror_msg\*(Aq}\en";
.Ve
.PP
or
.PP
.Vb 10
\&        eval {
\&                $sender = new Mail::Sender {
\&                        smtp => \*(Aqmail.yourISP.com\*(Aq,
\&                        from => \*(Aqsomebody@somewhere.com\*(Aq,
\&                        on_errors => \*(Aqdie\*(Aq,
\&                };
\&                $sender\->Open({
\&                        to => \*(Aqmama@home.org, papa@work.com\*(Aq,
\&                        cc => \*(Aqsomebody@somewhere.com\*(Aq,
\&                        subject => \*(AqSorry, I\e\*(Aqll come later.\*(Aq
\&                });
\&                $sender\->SendLineEnc("I\*(Aqm sorry, but thanks to the lusers,
\&                        I\*(Aqll come at 10pm at best.");
\&                $sender\->SendLineEnc("\enHi, Jenda");
\&                $sender\->Close();
\&        };
\&        if ($@) {
\&                die "Failed to send the message: $@\en";
\&        }
.Ve
.PP
or
.PP
.Vb 10
\&        $sender = new Mail::Sender {
\&                smtp => \*(Aqmail.yourISP.com\*(Aq,
\&                from => \*(Aqsomebody@somewhere.com\*(Aq,
\&                on_errors => \*(Aqcode\*(Aq,
\&        };
\&        die "Can\*(Aqt create the Mail::Sender object: $Mail::Sender::Error\en"
\&                unless ref $sender;
\&        ref $sender\->Open({
\&                to => \*(Aqmama@home.org, papa@work.com\*(Aq,
\&                cc => \*(Aqsomebody@somewhere.com\*(Aq,
\&                subject => \*(AqSorry, I\e\*(Aqll come later.\*(Aq
\&        })
\&                or die "Can\*(Aqt open the message: $sender\->{\*(Aqerror_msg\*(Aq}\en";
\&        $sender\->SendLineEnc("I\*(Aqm sorry, but thanks to the lusers,
\&                I\*(Aqll come at 10pm at best.");
\&        $sender\->SendLineEnc("\enHi, Jenda");
\&        ref $sender\->Close
\&                or die "Failed to send the message: $sender\->{\*(Aqerror_msg\*(Aq}\en";
.Ve
.SS "Using \fIGetHandle()\fP"
.IX Subsection "Using GetHandle()"
.Vb 6
\&  ref $sender\->Open({to => \*(Aqfriend@other.com\*(Aq, subject => \*(AqHello dear friend\*(Aq})
\&         or die "Error: $Mail::Sender::Error\en";
\&  my $FH = $sender\->GetHandle();
\&  print $FH "How are you?\en\en";
\&  print $FH <<\*(Aq*END*\*(Aq;
\&  I\*(Aqve found these jokes.
\&
\&   Doctor, I feel like a pack of cards.
\&   Sit down and I\*(Aqll deal with you later.
\&
\&   Doctor, I keep thinking I\*(Aqm a dustbin.
\&   Don\*(Aqt talk rubbish.
\&
\&  Hope you like\*(Aqem. Jenda
\&  *END*
\&
\&  $sender\->Close;
\&  # or
\&  # close $FH;
.Ve
.PP
or
.PP
.Vb 10
\&  eval {
\&    $sender\->Open({ on_errors => \*(Aqdie\*(Aq,
\&                         to => \*(Aqmama@home.org, papa@work.com\*(Aq,
\&                cc => \*(Aqsomebody@somewhere.com\*(Aq,
\&                subject => \*(AqSorry, I\e\*(Aqll come later.\*(Aq});
\&    $sender\->SendLineEnc("I\*(Aqm sorry, but due to a big load of work,
\&  I\*(Aqll come at 10pm at best.");
\&    $sender\->SendLineEnc("\enHi, Jenda");
\&    $sender\->Close;
\&  };
\&  if ($@) {
\&    print "Error sending the email: $@\en";
\&  } else {
\&    print "The mail was sent.\en";
\&  }
.Ve
.SS "Multipart message with attachment"
.IX Subsection "Multipart message with attachment"
.Vb 8
\& $sender\->OpenMultipart({to => \*(AqPerl\-Win32\-Users@activeware.foo\*(Aq,
\&                         subject => \*(AqMail::Sender.pm \- new module\*(Aq});
\& $sender\->Body;
\& $sender\->SendEnc(<<\*(Aq*END*\*(Aq);
\& Here is a new module Mail::Sender.
\& It provides an object based interface to sending SMTP mails.
\& It uses a direct socket connection, so it doesn\*(Aqt need any
\& additional program.
\&
\& Enjoy, Jenda
\& *END*
\& $sender\->Attach(
\&  {description => \*(AqPerl module Mail::Sender.pm\*(Aq,
\&   ctype => \*(Aqapplication/x\-zip\-encoded\*(Aq,
\&   encoding => \*(AqBase64\*(Aq,
\&   disposition => \*(Aqattachment; filename="Sender.zip"; type="ZIP archive"\*(Aq,
\&   file => \*(Aqsender.zip\*(Aq
\&  });
\& $sender\->Close;
.Ve
.PP
or
.PP
.Vb 7
\& $sender\->OpenMultipart({to => \*(AqPerl\-Win32\-Users@activeware.foo\*(Aq,
\&                         subject => \*(AqMail::Sender.pm \- new version\*(Aq});
\& $sender\->Body({ msg => <<\*(Aq*END*\*(Aq });
\& Here is a new module Mail::Sender.
\& It provides an object based interface to sending SMTP mails.
\& It uses a direct socket connection, so it doesn\*(Aqt need any
\& additional program.
\&
\& Enjoy, Jenda
\& *END*
\& $sender\->Attach(
\&  {description => \*(AqPerl module Mail::Sender.pm\*(Aq,
\&   ctype => \*(Aqapplication/x\-zip\-encoded\*(Aq,
\&   encoding => \*(AqBase64\*(Aq,
\&   disposition => \*(Aqattachment; filename="Sender.zip"; type="ZIP archive"\*(Aq,
\&   file => \*(Aqsender.zip\*(Aq
\&  });
\& $sender\->Close;
.Ve
.PP
or (in case you have the file contents in a scalar)
.PP
.Vb 7
\& $sender\->OpenMultipart({to => \*(AqPerl\-Win32\-Users@activeware.foo\*(Aq,
\&                         subject => \*(AqMail::Sender.pm \- new version\*(Aq});
\& $sender\->Body({ msg => <<\*(Aq*END*\*(Aq });
\& Here is a new module Mail::Sender.
\& It provides an object based interface to sending SMTP mails.
\& It uses a direct socket connection, so it doesn\*(Aqt need any
\& additional program.
\&
\& Enjoy, Jenda
\& *END*
\& $sender\->Part(
\&  {description => \*(AqPerl module Mail::Sender.pm\*(Aq,
\&   ctype => \*(Aqapplication/x\-zip\-encoded\*(Aq,
\&   encoding => \*(AqBase64\*(Aq,
\&   disposition => \*(Aqattachment; filename="Sender.zip"; type="ZIP archive"\*(Aq,
\&   msg => $sender_zip_contents,
\&  });
\& $sender\->Close;
.Ve
.SS "Using exceptions (no need to test return values after each function)"
.IX Subsection "Using exceptions (no need to test return values after each function)"
.Vb 9
\& use Mail::Sender;
\& eval {
\& (new Mail::Sender {on_errors => \*(Aqdie\*(Aq})
\&        \->OpenMultipart({smtp=> \*(Aqjenda.krynicky.cz\*(Aq, to => \*(Aqjenda@krynicky.cz\*(Aq,subject => \*(AqMail::Sender.pm \- new version\*(Aq})
\&        \->Body({ msg => <<\*(Aq*END*\*(Aq })
\& Here is a new module Mail::Sender.
\& It provides an object based interface to sending SMTP mails.
\& It uses a direct socket connection, so it doesn\*(Aqt need any
\& additional program.
\&
\& Enjoy, Jenda
\& *END*
\&        \->Attach({
\&                description => \*(AqPerl module Mail::Sender.pm\*(Aq,
\&                ctype => \*(Aqapplication/x\-zip\-encoded\*(Aq,
\&                encoding => \*(AqBase64\*(Aq,
\&                disposition => \*(Aqattachment; filename="Sender.zip"; type="ZIP archive"\*(Aq,
\&                file => \*(AqW:\ejenda\epackages\eMail\eSender\eMail\-Sender\-0.7.14.3.tar.gz\*(Aq
\&        })
\&        \->Close();
\& } or print "Error sending mail: $@\en";
.Ve
.SS "Using \fIMailMsg()\fP shortcut to send simple messages"
.IX Subsection "Using MailMsg() shortcut to send simple messages"
If everything you need is to send a simple message you may use:
.PP
.Vb 6
\& if (ref ($sender\->MailMsg({to =>\*(AqJenda@Krynicky.czX\*(Aq, subject => \*(Aqthis is a test\*(Aq,
\&                         msg => "Hi Johnie.\enHow are you?"}))) {
\&  print "Mail sent OK."
\& } else {
\&  die "$Mail::Sender::Error\en";
\& }
.Ve
.PP
or
.PP
.Vb 10
\& if ($sender\->MailMsg({
\&   smtp => \*(Aqmail.yourISP.com\*(Aq,
\&   from => \*(Aqsomebody@somewhere.com\*(Aq,
\&   to =>\*(AqJenda@Krynicky.czX\*(Aq,
\&   subject => \*(Aqthis is a test\*(Aq,
\&   msg => "Hi Johnie.\enHow are you?"
\& }) < 0) {
\&  die "$Mail::Sender::Error\en";
\& }
\& print "Mail sent OK."
.Ve
.SS "Using MailMsg and authentication"
.IX Subsection "Using MailMsg and authentication"
.Vb 10
\& if ($sender\->MailMsg({
\&   smtp => \*(Aqmail.yourISP.com\*(Aq,
\&   from => \*(Aqsomebody@somewhere.com\*(Aq,
\&   to =>\*(AqJenda@Krynicky.czX\*(Aq,
\&   subject => \*(Aqthis is a test\*(Aq,
\&   msg => "Hi Johnie.\enHow are you?"
\&   auth => \*(AqNTLM\*(Aq,
\&   authid => \*(Aqjenda\*(Aq,
\&   authpwd => \*(Aqbenda\*(Aq,
\& }) < 0) {
\&  die "$Mail::Sender::Error\en";
\& }
\& print "Mail sent OK."
.Ve
.SS "Using \fIMailFile()\fP shortcut to send an attachment"
.IX Subsection "Using MailFile() shortcut to send an attachment"
If you want to attach some files:
.PP
.Vb 8
\& (ref ($sender\->MailFile(
\&  {to =>\*(Aqyou@address.com\*(Aq, subject => \*(Aqthis is a test\*(Aq,
\&   msg => "Hi Johnie.\enI\*(Aqm sending you the pictures you wanted.",
\&   file => \*(Aqimage1.jpg,image2.jpg\*(Aq
\&  }))
\&  and print "Mail sent OK."
\& )
\& or die "$Mail::Sender::Error\en";
.Ve
.SS "Sending \s-1HTML\s0 messages"
.IX Subsection "Sending HTML messages"
If you are sure the \s-1HTML\s0 doesn't contain any accentuated characters (with codes above 127).
.PP
.Vb 6
\& open IN, $htmlfile or die "Cannot open $htmlfile : $!\en";
\& $sender\->Open({ from => \*(Aqyour@address.com\*(Aq, to => \*(Aqother@address.com\*(Aq,
\&        subject => \*(AqHTML test\*(Aq,
\&        ctype => "text/html",
\&        encoding => "7bit"
\& }) or die $Mail::Sender::Error,"\en";
\&
\& while (<IN>) { $sender\->SendEx($_) };
\& close IN;
\& $sender\->Close();
.Ve
.PP
Otherwise use \fISendEnc()\fR instead of \fISendEx()\fR and \*(L"quoted-printable\*(R" instead of \*(L"7bit\*(R".
.PP
Another ... quicker way ... would be:
.PP
.Vb 6
\& open IN, $htmlfile or die "Cannot open $htmlfile : $!\en";
\& $sender\->Open({ from => \*(Aqyour@address.com\*(Aq, to => \*(Aqother@address.com\*(Aq,
\&        subject => \*(AqHTML test\*(Aq,
\&        ctype => "text/html",
\&        encoding => "quoted\-printable"
\& }) or die $Mail::Sender::Error,"\en";
\&
\& while (read IN, $buff, 4096) { $sender\->SendEnc($buff) };
\& close IN;
\& $sender\->Close();
.Ve
.SS "Sending \s-1HTML\s0 messages with inline images"
.IX Subsection "Sending HTML messages with inline images"
.Vb 10
\&        if (ref $sender\->OpenMultipart({
\&                from => \*(Aqsomeone@somewhere.net\*(Aq, to => $recipients,
\&                subject => \*(AqEmbedded Image Test\*(Aq,
\&                boundary => \*(Aqboundary\-test\-1\*(Aq,
\&                multipart => \*(Aqrelated\*(Aq})) {
\&                $sender\->Attach(
\&                         {description => \*(Aqhtml body\*(Aq,
\&                         ctype => \*(Aqtext/html; charset=us\-ascii\*(Aq,
\&                         encoding => \*(Aq7bit\*(Aq,
\&                         disposition => \*(AqNONE\*(Aq,
\&                         file => \*(Aqtest.html\*(Aq
\&                });
\&                $sender\->Attach({
\&                        description => \*(Aqed\e\*(Aqs gif\*(Aq,
\&                        ctype => \*(Aqimage/gif\*(Aq,
\&                        encoding => \*(Aqbase64\*(Aq,
\&                        disposition => "inline; filename=\e"apache_pb.gif\e";\er\enContent\-ID: <img1>",
\&                        file => \*(Aqapache_pb.gif\*(Aq
\&                });
\&                $sender\->Close() or die "Close failed! $Mail::Sender::Error\en";
\&        } else {
\&                die "Cannot send mail: $Mail::Sender::Error\en";
\&        }
.Ve
.PP
And in the \s-1HTML\s0 you'll have this :
 ... <\s-1IMG\s0 src=\*(L"cid:img1\*(R"> ...
on the place where you want the inlined image.
.PP
Please keep in mind that the image name is unimportant, it's the Content-ID what counts!
.PP
# or using the eval{ \f(CW$obj\fR\->\fIMethod()\fR\->\fIMethod()\fR\->...\->\fIClose()\fR} trick ...
.PP
.Vb 10
\&        use Mail::Sender;
\&        eval {
\&        (new Mail::Sender)
\&                \->OpenMultipart({
\&                        to => \*(Aqsomeone@somewhere.com\*(Aq,
\&                        subject => \*(AqEmbedded Image Test\*(Aq,
\&                        boundary => \*(Aqboundary\-test\-1\*(Aq,
\&                        type => \*(Aqmultipart/related\*(Aq
\&                })
\&                \->Attach({
\&                        description => \*(Aqhtml body\*(Aq,
\&                        ctype => \*(Aqtext/html; charset=us\-ascii\*(Aq,
\&                        encoding => \*(Aq7bit\*(Aq,
\&                        disposition => \*(AqNONE\*(Aq,
\&                        file => \*(Aqc:\etemp\ezk\eHTMLTest.htm\*(Aq
\&                })
\&                \->Attach({
\&                        description => \*(AqTest gif\*(Aq,
\&                        ctype => \*(Aqimage/gif\*(Aq,
\&                        encoding => \*(Aqbase64\*(Aq,
\&                        disposition => "inline; filename=\e"test.gif\e";\er\enContent\-ID: <img1>",
\&                        file => \*(Aqtest.gif\*(Aq
\&                })
\&                \->Close()
\&        }
\&        or die "Cannot send mail: $Mail::Sender::Error\en";
.Ve
.SS "Sending message with plaintext and \s-1HTML\s0 alternatives"
.IX Subsection "Sending message with plaintext and HTML alternatives"
.Vb 1
\&        use Mail::Sender;
\&
\&        eval {
\&                (new Mail::Sender)
\&                \->OpenMultipart({
\&                        to => \*(Aqsomeone@somewhere.com\*(Aq,
\&                        subject => \*(AqAlternatives\*(Aq,
\&        #               debug => \*(Aqc:\etemp\ezkMailFlow.log\*(Aq,
\&                        multipart => \*(Aqmixed\*(Aq,
\&                })
\&                        \->Part({ctype => \*(Aqmultipart/alternative\*(Aq})
\&                                \->Part({ ctype => \*(Aqtext/plain\*(Aq, disposition => \*(AqNONE\*(Aq, msg => <<\*(Aq*END*\*(Aq })
\&        A long
\&        mail
\&        message.
\&        *END*
\&                                \->Part({ctype => \*(Aqtext/html\*(Aq, disposition => \*(AqNONE\*(Aq, msg => <<\*(Aq*END*\*(Aq})
\&        <html><body><h1>A long</h1><p align=center>
\&        mail
\&        message.
\&        </p></body></html>
\&        *END*
\&                        \->EndPart("multipart/alternative")
\&                \->Close();
\&        } or print "Error sending mail: $Mail::Sender::Error\en";
.Ve
.SS "Sending message with plaintext and \s-1HTML\s0 alternatives with inline images"
.IX Subsection "Sending message with plaintext and HTML alternatives with inline images"
.Vb 1
\&        use Mail::Sender;
\&
\&        eval {
\&                (new Mail::Sender)
\&                \->OpenMultipart({
\&                        to => \*(Aqsomeone@somewhere.com\*(Aq,
\&                        subject => \*(AqAlternatives with images\*(Aq,
\&        #               debug => \*(Aqc:\etemp\ezkMailFlow.log\*(Aq,
\&                        multipart => \*(Aqrelated\*(Aq,
\&                })
\&                        \->Part({ctype => \*(Aqmultipart/alternative\*(Aq})
\&                                \->Part({ ctype => \*(Aqtext/plain\*(Aq, disposition => \*(AqNONE\*(Aq, msg => <<\*(Aq*END*\*(Aq })
\&        A long
\&        mail
\&        message.
\&        *END*
\&                                \->Part({ctype => \*(Aqtext/html\*(Aq, disposition => \*(AqNONE\*(Aq, msg => <<\*(Aq*END*\*(Aq})
\&        <html><body><h1>A long</h1><p align=center>
\&        mail
\&        message.
\&        <img src="cid:img1">
\&        </p></body></html>
\&        *END*
\&                        \->EndPart("multipart/alternative")
\&                        \->Attach({
\&                                description => \*(Aqed\e\*(Aqs jpg\*(Aq,
\&                                ctype => \*(Aqimage/jpeg\*(Aq,
\&                                encoding => \*(Aqbase64\*(Aq,
\&                                disposition => "inline; filename=\e"0518m_b.jpg\e";\er\enContent\-ID: <img1>",
\&                                file => \*(AqE:\epix\ehumor\e0518m_b.jpg\*(Aq
\&                        })
\&                \->Close();
\&        } or print "Error sending mail: $Mail::Sender::Error\en";
.Ve
.PP
Keep in mind please that different mail clients display messages differently. You may
need to try several ways to create messages so that they appear the way you need.
These two examples looked like I expected in Pegasus Email and \s-1MS\s0 Outlook.
.PP
If this doesn't work with your mail client, please let me know and we might find a way.
.SS "Sending a file that was just uploaded from an \s-1HTML\s0 form"
.IX Subsection "Sending a file that was just uploaded from an HTML form"
.Vb 2
\& use CGI;
\& use Mail::Sender;
\&
\& $query = new CGI;
\&
\& # uploading the file...
\& $filename = $query\->param(\*(AqmailformFile\*(Aq);
\& if ($filename ne ""){
\&  $tmp_file = $query\->tmpFileName($filename);
\& }
\&
\& $sender = new Mail::Sender {from => \*(Aqscript@krynicky.cz\*(Aq,smtp => \*(Aqmail.krynicky.czX\*(Aq};
\& $sender\->OpenMultipart({to=> \*(Aqjenda@krynicky.czX\*(Aq,subject=> \*(Aqtest CGI attach\*(Aq});
\& $sender\->Body();
\& $sender\->Send(<<"*END*");
\& This is just a test of mail with an uploaded file.
\&
\& Jenda
\& *END*
\& $sender\->Attach({
\&    encoding => \*(AqBase64\*(Aq,
\&    description => $filename,
\&    ctype => $query\->uploadInfo($filename)\->{\*(AqContent\-Type\*(Aq},
\&    disposition => "attachment; filename = $filename",
\&    file => $tmp_file
\& });
\& $sender\->Close();
\&
\& print "Content\-Type: text/plain\en\enYes, it\*(Aqs sent\en\en";
.Ve
.SS "Listing the authentication protocols supported by the server"
.IX Subsection "Listing the authentication protocols supported by the server"
.Vb 4
\& use Mail::Sender;
\& my $sender = new Mail::Sender {smtp => \*(Aqlocalhost\*(Aq};
\& die "Error: $Mail::Sender::Error\en" unless ref $sender;
\& print join(\*(Aq, \*(Aq, $sender\->QueryAuthProtocols()),"\en";
.Ve
.PP
or (if you have Mail::Sender 0.8.05 or newer)
.PP
.Vb 2
\& use Mail::Sender;
\& print join(\*(Aq, \*(Aq, Mail::Sender\->QueryAuthProtocols(\*(Aqlocalhost\*(Aq)),"\en";
.Ve
.PP
or
.PP
.Vb 2
\& use Mail::Sender;
\& print join(\*(Aq, \*(Aq, Mail::Sender::QueryAuthProtocols(\*(Aqlocalhost\*(Aq)),"\en";
.Ve
.SS "\s-1FAQ\s0"
.IX Subsection "FAQ"
\fIForwarding the messages created by Mail::Sender removes accents. Why?\fR
.IX Subsection "Forwarding the messages created by Mail::Sender removes accents. Why?"
.PP
The most likely colprit is missing or incorrect charset specified for the body or
a part of the email. You should add something like
.PP
.Vb 2
\&        charset => \*(Aqiso\-8859\-1\*(Aq,
\&        encoding => \*(Aqquoted\-printable\*(Aq,
.Ve
.PP
to the parameters passed to \fIOpen()\fR, \fIOpenMultipart()\fR, \fIMailMsg()\fR, \fIBody()\fR or \fIPart()\fR or
.PP
.Vb 2
\&        b_charset => \*(Aqiso\-8859\-1\*(Aq,
\&        b_encoding => \*(Aqquoted\-printable\*(Aq,
.Ve
.PP
to the parameters for \fIMailFile()\fR.
.PP
If you use a different charset ('iso\-8859\-2', 'win\-1250', ...) you will of course need
to specify that charset. If you are not sure, try to send a mail with some other mail client
and then look at the message/part headers.
.SS "Sometimes there is an equals sign at the end of an attached file when I open the email in Outlook. What's wrong?"
.IX Subsection "Sometimes there is an equals sign at the end of an attached file when I open the email in Outlook. What's wrong?"
Outlook is. It has (had) a bug in its quoted printable decoding routines.
This problem happens only in quoted-printable encoded parts on multipart messages.
And only if the data in that part do not end with a newline. (This is new in 0.8.08, in older versions
it happened in all \s-1QP\s0 encoded parts.)
.PP
The problem is that an equals sign at the end of a line in a quoted printable encoded text means
\&\*(L"ignore the newline\*(R". That is
.PP
.Vb 2
\&        fooo sdfg sdfg sdfh dfh =
\&        dfsgdsfg
.Ve
.PP
should be decoded as
.PP
.Vb 1
\&        fooo sdfg sdfg sdfh dfh dfsgdsfg
.Ve
.PP
The problem is at the very end of a file. The part boundary (text separating different
parts of a multipart message) has to start on a new line, if the attached file ends by a newline everything is cool.
If it doesn't I need to add a newline and to denote that the newline is not part of the original file I add an equals:
.PP
.Vb 3
\&        dfgd dsfgh dfh dfh dfhdfhdfhdfgh
\&        this is the last line.=
\&        \-\-message\-boundary\-146464\-\-
.Ve
.PP
Otherwise I'd add a newline at the end of the file.
If you do not care about the newline and want to be sure Outlook doesn't add the equals to the file add
.PP
.Vb 1
\&        bypass_outlook_bug => 1
.Ve
.PP
parameter to \f(CW\*(C`new Mail::Sender\*(C'\fR or \f(CW\*(C`Open\*(C'\fR/\f(CW\*(C`OpenMultipart\*(C'\fR.
.SS "\s-1WARNING\s0"
.IX Subsection "WARNING"
\&\s-1DO NOT\s0 mix Open(Multipart)|Send(Line)(Ex)|Close with MailMsg or MailFile.
Both Mail(Msg/File) close any Open-ed mail.
Do not try this:
.PP
.Vb 6
\& $sender = new Mail::Sender ...;
\& $sender\->OpenMultipart...;
\& $sender\->Body;
\& $sender\->Send("...");
\& $sender\->MailFile({file => \*(Aqsomething.ext\*(Aq);
\& $sender\->Close;
.Ve
.PP
This \s-1WON\s0'T work!!!
.SS "\s-1GOTCHAS\s0"
.IX Subsection "GOTCHAS"
\fILocal user \*(L"someone@somewhere.com\*(R" doesn't exist\fR
.IX Subsection "Local user someone@somewhere.com doesn't exist"
.PP
\&\*(L"Thanks\*(R" to spammers mail servers usually do not allow just anyone to post a message through them.
Most often they require that either the sender or the recipient is local to the server
.PP
\fIMail::Sendmail works, Mail::Sender doesn't\fR
.IX Subsection "Mail::Sendmail works, Mail::Sender doesn't"
.PP
If you are able to connect to the mail server and scripts using Mail::Sendmail work, but Mail::Sender fails with
\&\*(L"\fIconnect()\fR failed\*(R", please review the settings in /etc/services. The port for \s-1SMTP\s0 should be 25.
.PP
\fI$/ and $\e\fR
.IX Subsection "$/ and $"
.PP
If you change the $/ ($RS, \f(CW$INPUT_RECORD_SEPARATOR\fR) or $\e ($ORS, \f(CW$OUTPUT_RECORD_SEPARATOR\fR)
or $, ($OFS, \f(CW$OUTPUT_FIELD_SEPARATOR\fR) Mail::Sender may stop working! Keep in mind that those variables are global
and therefore they change the behaviour of <> and print everywhere.
And since the \s-1SMTP\s0 is a plain text protocol if you change the notion of lines you can break it.
.PP
If you have to fiddle with $/, $\e or $, do it in the smallest possible block of code and \fIlocal()\fRize the change!
.PP
.Vb 3
\&        open my $IN, \*(Aq<\*(Aq, $filename or die "Can\*(Aqt open $filename: $!\en";
\&        my $data = do {local $/; <$IN>};
\&        close $IN;
.Ve
.SH "BUGS"
.IX Header "BUGS"
I'm sure there are many. Please let me know if you find any.
.PP
The problem with multiline responses from some \s-1SMTP\s0 servers (namely qmail) is solved. At last.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MIME::Lite, MIME::Entity, Mail::Sendmail, Mail::Mailer, ...
.PP
There are lots of mail related modules on \s-1CPAN,\s0 with different capabilities and interfaces. You
have to find the right one yourself :\-)
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This module is based on SendMail.pm Version : 1.21 that appeared in
Perl\-Win32\-Users@activeware.com mailing list. I don't remember the name
of the poster and it's not mentioned in the script. Thank you mr. \f(CW\*(C`undef\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jan Krynicky <Jenda@Krynicky.cz>
http://Jenda.Krynicky.cz
.PP
With help of Rodrigo Siqueira <rodrigo@insite.com.br>,
Ed McGuigan <itstech1@gate.net>,
John Sanche <john@quadrant.net>,
Brian Blakley <bblakley@mp5.net>,
and others.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2014 Jan Krynicky <Jenda@Krynicky.cz>. All rights reserved.
.PP
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
You are discouraged from using this module for sending \s-1SPAM\s0! (see
http://spam.abuse.net/ for definition). It is unethical and, in many
jurisdictions, illegal.
