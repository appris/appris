.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Search::Tiling::MapTileUtils 3pm"
.TH Bio::Search::Tiling::MapTileUtils 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Search::Tiling::MapTileUtils \- utilities for manipulating closed intervals for an HSP tiling algorithm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Not used directly.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Not used directly.
.SH "NOTE"
.IX Header "NOTE"
An \*(L"interval\*(R" in this module is defined as an arrayref \f(CW\*(C`[$a0, $a1]\*(C'\fR, where
\&\f(CW\*(C`$a0, $a1\*(C'\fR are scalar numbers satisfying \f(CW\*(C`$a0 <= $a1\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mark A. Jensen \- maj \-at\- fortinbras \-dot\- us
.SH "APPENDIX"
.IX Header "APPENDIX"
.SS "interval_tiling"
.IX Subsection "interval_tiling"
.Vb 6
\& Title   : interval_tiling()
\& Usage   : @tiling = interval_tiling( \e@array_of_intervals )
\& Function: Find minimal set of intervals covering the input set
\& Returns : array of arrayrefs of the form
\&  ( [$interval => [ @indices_of_collapsed_input_intervals ]], ...)
\& Args    : arrayref of intervals
.Ve
.SS "decompose_interval"
.IX Subsection "decompose_interval"
.Vb 10
\& Title   : decompose_interval
\& Usage   : @decomposition = decompose_interval( \e@overlappers )
\& Function: Calculate the disjoint decomposition of a set of
\&           overlapping intervals, each annotated with a list of
\&           covering intervals
\& Returns : array of arrayrefs of the form
\&           ( [[@interval] => [@indices_of_coverers]], ... )
\& Args    : arrayref of intervals (arrayrefs like [$a0, $a1], with
\& Note    : Each returned interval is associated with a list of indices of the
\&           original intervals that cover that decomposition component
\&           (scalar size of this list could be called the \*(Aqcoverage coefficient\*(Aq)
\& Note    : Coverage: each component of the decomp is completely contained
\&           in the input intervals that overlap it, by construction.
\& Caveat  : This routine expects the members of @overlappers to overlap,
\&           but doesn\*(Aqt check this.
.Ve
.SS "are_disjoint"
.IX Subsection "are_disjoint"
.Vb 5
\& Title   : are_disjoint
\& Usage   : are_disjoint( [$a0, $a1], [$b0, $b1] )
\& Function: Determine if two intervals are disjoint
\& Returns : True if the intervals are disjoint, false if they overlap
\& Args    : array of two intervals
.Ve
.SS "min_covering_interval"
.IX Subsection "min_covering_interval"
.Vb 5
\& Title   : min_covering_interval 
\& Usage   : $interval = min_covering_interval( [$a0,$a1],[$b0,$b1] )
\& Function: Determine the minimal covering interval for two intervals
\& Returns : an interval
\& Args    : two intervals
.Ve
.SS "get_intervals_from_hsps"
.IX Subsection "get_intervals_from_hsps"
.Vb 7
\& Title   : get_intervals_from_hsps
\& Usage   : @intervals = get_intervals_from_hsps($type, @hsp_objects)
\& Function: Return array of intervals of the form [ $start, $end ],
\&           from an array of hsp objects
\& Returns : an array of intervals
\& Args    : scalar $type, array of HSPI objects; where $type is one of \*(Aqhit\*(Aq,
\&           \*(Aqsubject\*(Aq, \*(Aqquery\*(Aq
.Ve
.SS "_allowable_filters"
.IX Subsection "_allowable_filters"
.Vb 11
\& Title   : _allowable_filters
\& Usage   : _allowable_filters($Bio_Search_Hit_HitI, $type)
\& Function: Return the HSP filters (strand, frame) allowed, 
\&           based on the reported algorithm
\& Returns : String encoding allowable filters: 
\&           s = strand, f = frame
\&           Empty string if no filters allowed
\&           undef if algorithm unrecognized
\& Args    : A Bio::Search::Hit::HitI object,
\&           scalar $type, one of \*(Aqhit\*(Aq, \*(Aqsubject\*(Aq, \*(Aqquery\*(Aq;
\&           default is \*(Aqquery\*(Aq
.Ve
.SS "_set_attributes"
.IX Subsection "_set_attributes"
.Vb 8
\& Title   : _set_attributes
\& Usage   : $tiling\->_set_attributes()
\& Function: Sets attributes for invocant
\&           that depend on algorithm name
\& Returns : True on success
\& Args    : none
\& Note    : setting based on the configuration table
\&           %alg_lookup
.Ve
.SS "\fBcontaining_hsps()\fP"
.IX Subsection "containing_hsps()"
.Vb 7
\& Title   : containing_hsps
\& Usage   : @hsps = containing_hsps($interval, @hsps_to_search)
\& Function: Return a list of hsps whose coordinates completely contain the
\&           given $interval
\& Returns : Array of HSP objects
\& Args    : $interval : [$int1, $int2],
\&           array of HSP objects
.Ve
.SS "\fBcovering_groups()\fP"
.IX Subsection "covering_groups()"
.Vb 7
\& Title   : covering_groups
\& Usage   : 
\& Function: divide a list of **ordered,disjoint** intervals (as from a 
\&           coverage map) into a set of disjoint covering groups
\& Returns : array of arrayrefs, each arrayref a covering set of 
\&           intervals
\& Args    : array of intervals
.Ve
.SS "matches_MT"
.IX Subsection "matches_MT"
.Vb 11
\& Title   : matches_MT
\& Usage   : $hsp\->matches($type, $action, $start, $end)
\& Purpose   : Get the total number of identical or conserved matches 
\&             in the query or sbjct sequence for the given HSP. Optionally can
\&             report data within a defined interval along the seq.
\& Returns   : scalar int 
\& Args      : 
\& Comments  : Relies on seq_str(\*(Aqmatch\*(Aq) to get the string of alignment symbols
\&             between the query and sbjct lines which are used for determining
\&             the number of identical and conservative matches.
\& Note      : Modeled on Bio::Search::HSP::HSPI::matches
.Ve
.SS "get_SeqFeatures"
.IX Subsection "get_SeqFeatures"
.Vb 3
\& Title   : get_SeqFeatures
\& Usage   :
\& Function: Get the feature objects held by this feature holder.
\&
\&           Features which are not top\-level are subfeatures of one or
\&           more of the returned feature objects, which means that you
\&           must traverse the subfeature arrays of each top\-level
\&           feature object in order to traverse all features associated
\&           with this sequence.
\&
\&           Top\-level features can be obtained by tag, specified in 
\&           the argument.
\&
\&           Use get_all_SeqFeatures() if you want the feature tree
\&           flattened into one single array.
\&
\& Example :
\& Returns : an array of Bio::SeqFeatureI implementing objects
\& Args    : [optional] scalar string (feature tag)
.Ve
.SS "feature_count"
.IX Subsection "feature_count"
.Vb 5
\& Title   : feature_count
\& Usage   : $seq\->feature_count()
\& Function: Return the number of SeqFeatures attached to a sequence
\& Returns : integer representing the number of SeqFeatures
\& Args    : None
.Ve
.SS "add_SeqFeature"
.IX Subsection "add_SeqFeature"
.Vb 9
\& Title   : add_SeqFeature
\& Usage   : $seq\->add_SeqFeature($feat);
\&           $seq\->add_SeqFeature(@feat);
\& Function: Adds the given feature object (or each of an array of feature
\&           objects to the feature array of this
\&           sequence. The object passed is required to implement the
\&           Bio::SeqFeatureI interface.
\& Returns : 1 on success
\& Args    : A Bio::SeqFeatureI implementing object, or an array of such objects.
.Ve
.SS "remove_SeqFeatures"
.IX Subsection "remove_SeqFeatures"
.Vb 3
\& Title   : remove_SeqFeatures
\& Usage   : $seq\->remove_SeqFeatures();
\& Function: Flushes all attached SeqFeatureI objects.
\&
\&           To remove individual feature objects, delete those from the returned
\&           array and re\-add the rest.
\& Example :
\& Returns : The array of Bio::SeqFeatureI objects removed from this seq.
\& Args    : None
.Ve
