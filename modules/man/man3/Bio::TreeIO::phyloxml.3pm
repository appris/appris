.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::TreeIO::phyloxml 3pm"
.TH Bio::TreeIO::phyloxml 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::TreeIO::phyloxml \- TreeIO implementation for parsing PhyloXML format.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # do not use this module directly
\&  use Bio::TreeIO;
\&  my $treeio = Bio::TreeIO\->new(\-format => \*(Aqphyloxml\*(Aq,
\&                                \-file => \*(Aqtree.dnd\*(Aq);
\&  my $tree = $treeio\->next_tree;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module handles parsing and writing of phyloXML format.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to the
Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted viax the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Mira Han"
.IX Header "AUTHOR - Mira Han"
Email mirhan@indiana.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "next_tree"
.IX Subsection "next_tree"
.Vb 5
\& Title   : next_tree
\& Usage   : my $tree = $treeio\->next_tree
\& Function: Gets the next tree in the stream
\& Returns : Bio::Tree::TreeI
\& Args    : none
.Ve
.SS "add_attribute"
.IX Subsection "add_attribute"
.Vb 6
\& Title   : add_phyloXML_annotation
\& Usage   : my $node = $treeio\->add_phyloXML_annotation(\-obj=>$node, \-attr=>"id_source = \e"A\e"")
\& Function: add attributes to an object 
\& Returns : the node that we added annotations to
\& Args    : \-obj   => object that will have the Annotation. (Bio::Tree::AnnotatableNode)
\&           \-attr  => string in the form "A = B", where A is the attribute name and B is the attribute value
.Ve
.SS "add_phyloXML_annotation"
.IX Subsection "add_phyloXML_annotation"
.Vb 3
\& Title   : add_phyloXML_annotation
\& Usage   : my $node = $treeio\->add_phyloXML_annotation(\-obj=>$node, \-xml=>$xmlstring)
\&           my $tree = $treeio\->add_phyloXML_annotation(\*(Aq\-obj\*(Aq=>$tree, \*(Aq\-xml\*(Aq=>\*(Aq<sequence_relation id_ref_0="A" id_ref_1="B" type="orthology"/>\*(Aq)
\&
\& Function: add annotations to a node in the phyloXML format string
\& Returns : the node that we added annotations to
\& Args    : \-obj   => object that will have the Annotation. (Bio::Tree::AnnotatableNode)
\&           \-xml  => string in phyloXML format that describes the annotation for the node
.Ve
.SS "write_tree"
.IX Subsection "write_tree"
.Vb 5
\& Title   : write_tree
\& Usage   : $treeio\->write_tree($tree);
\& Function: Write a tree out to data stream in phyloxml format
\& Returns : none
\& Args    : Bio::Tree::TreeI object
.Ve
.SS "_write_tree_Helper_annotatableNode"
.IX Subsection "_write_tree_Helper_annotatableNode"
.Vb 6
\& Title   : _write_tree_Helper_annotatableNode
\& Usage   : internal method used by write_tree, not to be used directly
\& Function: recursive helper function of write_tree for the annotatableNodes. 
\&           translates annotations into xml elements.
\& Returns : string describing the node
\& Args    : Bio::Node::AnnotatableNode object, string
.Ve
.SS "_write_tree_Helper_generic"
.IX Subsection "_write_tree_Helper_generic"
.Vb 6
\& Title   : _write_tree_Helper_generic
\& Usage   : internal method used by write_tree, not to be used directly
\& Function: recursive helper function of write_tree for generic NodesI. 
\&           all tags are translated into property elements.
\& Returns : string describing the node
\& Args    : Bio::Node::NodeI object, string
.Ve
.SS "_relation_to_string"
.IX Subsection "_relation_to_string"
.Vb 7
\& Title   : _relation_to_string
\& Usage   : internal method used by write_tree, not to be used directly
\& Function: internal function used by write_tree to translate Annotation::Relation objects into xml elements. 
\& Returns : string describing the node
\& Args    : Bio::Node::AnnotatableNode (or Bio::SeqI) object that contains the Annotation::Relation, 
\&           the Annotation::Relation object, 
\&           the string
.Ve
.SS "read_annotation"
.IX Subsection "read_annotation"
.Vb 8
\& Title   : read_annotation
\& Usage   : $treeio\->read_annotation(\-obj=>$node, \-path=>$path, \-attr=>1);
\& Function: read text value (or attribute value) of the annotations corresponding to the element path 
\& Returns : list of text values of the annotations matching the path
\& Args    : \-obj   => object that contains the Annotation. (Bio::Tree::AnnotatableNode or Bio::SeqI)
\&           \-path  => path of the nested elements
\&           \-attr  => Boolean value to indicate whether to get the attribute of the element or the text value. 
\&                    (default is 0, meaning text value is returned)
.Ve
.SH "Methods for parsing the XML document"
.IX Header "Methods for parsing the XML document"
.SS "processXMLNode"
.IX Subsection "processXMLNode"
.Vb 5
\& Title   : processXMLNode
\& Usage   : $treeio\->processXMLNode
\& Function: read the XML node and process according to the node type
\& Returns : none
\& Args    : none
.Ve
.SS "processAttribute"
.IX Subsection "processAttribute"
.Vb 5
\& Title   : processAttribute
\& Usage   : $treeio\->processAttribute(\e%hash_for_attribute);
\& Function: reads the attributes of the current element into a hash
\& Returns : none
\& Args    : hash reference where the attributes will be stored.
.Ve
.SS "element_phylogeny"
.IX Subsection "element_phylogeny"
.Vb 5
\& Title   : element_phylogeny
\& Usage   : $treeio\->element_phylogeny
\& Function: initialize the parsing of a tree
\& Returns : none 
\& Args    : none
.Ve
.SS "end_element_phylogeny"
.IX Subsection "end_element_phylogeny"
.Vb 5
\& Title   : end_element_phylogeny
\& Usage   : $treeio\->end_element_phylogeny
\& Function: ends the parsing of a tree building a Tree::TreeI object.
\& Returns : Tree::TreeI
\& Args    : none
.Ve
.SS "element_clade"
.IX Subsection "element_clade"
.Vb 6
\& Title   : element_clade
\& Usage   : $treeio\->element_clade
\& Function: initialize the parsing of a node
\&           creates a new AnnotatableNode with annotations
\& Returns : none 
\& Args    : none
.Ve
.SS "end_element_clade"
.IX Subsection "end_element_clade"
.Vb 5
\& Title   : end_element_clade
\& Usage   : $treeio\->end_element_clade
\& Function: ends the parsing of a node
\& Returns : none 
\& Args    : none
.Ve
.SS "element_relation"
.IX Subsection "element_relation"
.Vb 5
\& Title   : element_relation
\& Usage   : $treeio\->element_relation
\& Function: starts the parsing of clade relation & sequence relation
\& Returns : none 
\& Args    : none
.Ve
.SS "end_element_relation"
.IX Subsection "end_element_relation"
.Vb 5
\& Title   : end_element_relation
\& Usage   : $treeio\->end_element_relation
\& Function: ends the parsing of clade relation & sequence relation
\& Returns : none 
\& Args    : none
.Ve
.SS "element_default"
.IX Subsection "element_default"
.Vb 5
\& Title   : element_default
\& Usage   : $treeio\->element_default
\& Function: starts the parsing of all other elements
\& Returns : none 
\& Args    : none
.Ve
.SS "end_element_default"
.IX Subsection "end_element_default"
.Vb 5
\& Title   : end_element_default
\& Usage   : $treeio\->end_element_default
\& Function: ends the parsing of all other elements
\& Returns : none 
\& Args    : none
.Ve
.SS "annotateNode"
.IX Subsection "annotateNode"
.Vb 10
\& Title   : annotateNode
\& Usage   : $treeio\->annotateNode($element, $ac)
\& Function: adds text value and attributes to the AnnotationCollection 
\&           that has element name as key. If there are nested elements, 
\&           optional AnnotationCollections are added recursively, 
\&           with the nested element name as key.
\&           The structure of each AnnotationCollection is 
\&           \*(Aqelement\*(Aq => AnnotationCollection {
\&               \*(Aq_text\*(Aq => SimpleValue (text value)
\&               \*(Aq_attr\*(Aq => AnnotationCollection { 
\&                   attribute1 => SimpleValue (attribute value 1)
\&                   attribute2 => SimpleValue (attribute value 2)
\&                   ...
\&               } 
\&               [\*(Aqnested element\*(Aq => AnnotationCollection ]
\&           }
\& Returns : none 
\& Args    : none
.Ve
.SH "Methods for exploring the document"
.IX Header "Methods for exploring the document"
.SS "current_attr"
.IX Subsection "current_attr"
.Vb 5
\& Title   : current_attr
\& Usage   : $attr_hash = $treeio\->current_attr;
\& Function: returns the attribute hash for current item
\& Returns : reference of the attribute hash
\& Args    : none
.Ve
.SS "prev_attr"
.IX Subsection "prev_attr"
.Vb 5
\& Title   : prev_attr
\& Usage   : $hash_ref = $treeio\->prev_attr
\& Function: returns the attribute hash for previous item
\& Returns : reference of the attribute hash
\& Args    : none
.Ve
.SS "current_element"
.IX Subsection "current_element"
.Vb 5
\& Title   : current_element
\& Usage   : $element = $treeio\->current_element
\& Function: returns the name of the current element
\& Returns : string (element name)
\& Args    : none
.Ve
.SS "prev_element"
.IX Subsection "prev_element"
.Vb 5
\& Title   : prev_element
\& Usage   : $element = $treeio\->current_element
\& Function: returns the name of the previous element
\& Returns : string (element name)
\& Args    : none
.Ve
.SS "treetype"
.IX Subsection "treetype"
.Vb 5
\& Title   : treetype
\& Usage   : $obj\->treetype($newval)
\& Function: returns the tree type (default is Bio::Tree::Tree)
\& Returns : value of treetype
\& Args    : newvalue (optional)
.Ve
.SS "nodetype"
.IX Subsection "nodetype"
.Vb 5
\& Title   : nodetype
\& Usage   : $obj\->nodetype($newval)
\& Function: returns the node type (default is Bio::Node::AnnotatableNode)
\& Returns : value of nodetype
\& Args    : newvalue (optional)
.Ve
.SH "Methods for implementing to_string callback for AnnotatableNode"
.IX Header "Methods for implementing to_string callback for AnnotatableNode"
.SS "node_to_string"
.IX Subsection "node_to_string"
.Vb 5
\& Title   : node_to_string
\& Usage   : $annotatablenode\->to_string_callback(\e&node_to_string)
\& Function: set as callback in AnnotatableNode, prints the node information in string 
\& Returns : string of node information
\& Args    : none
.Ve
.SS "print_annotation"
.IX Subsection "print_annotation"
.Vb 6
\& Title   : print_annotation
\& Usage   : $str = $annotatablenode\->print_annotation($str, $annotationcollection)
\& Function: prints the annotationCollection in a phyloXML format.
\& Returns : string of annotation information
\& Args    : string to which the Annotation should be concatenated to,
\&           annotationCollection that holds the Annotations
.Ve
.SS "print_attr"
.IX Subsection "print_attr"
.Vb 6
\& Title   : print_attr
\& Usage   : $str = $annotatablenode\->print_attr($str, $annotationcollection)
\& Function: prints the annotationCollection in a phyloXML format.
\& Returns : string of attributes
\& Args    : string to which the Annotation should be concatenated to,
\&           AnnotationCollection that holds the attributes
.Ve
.SS "print_sequence_annotation"
.IX Subsection "print_sequence_annotation"
.Vb 7
\& Title   : print_sequence_annotation
\& Usage   : $str = $node\->print_seq_annotation( $str, $seq );
\& Function: prints the Bio::Seq object associated with the node 
\&           in a phyloXML format.
\& Returns : string that describes the sequence
\& Args    : string to which the Annotation should be concatenated to,
\&           Seq object to print in phyloXML
.Ve
