.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Search::HSP::PullHSPI 3pm"
.TH Bio::Search::HSP::PullHSPI 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Search::HSP::PullHSPI \- Bio::Search::HSP::HSPI interface for pull parsers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # This is an interface and cannot be instantiated
\&
\&  # generally we use Bio::SearchIO to build these objects
\&  use Bio::SearchIO;
\&  my $in = Bio::SearchIO\->new(\-format => \*(Aqhmmer_pull\*(Aq,
\&                              \-file   => \*(Aqresult.hmmer\*(Aq);
\&
\&  while (my $result = $in\->next_result) {
\&      while (my $hit = $result\->next_hit) {
\&          while (my $hsp = $hit\->next_hsp) {
\&              $r_type = $hsp\->algorithm;
\&              $pvalue = $hsp\->p();
\&              $evalue = $hsp\->evalue();
\&              $frac_id = $hsp\->frac_identical( [\*(Aqquery\*(Aq|\*(Aqhit\*(Aq|\*(Aqtotal\*(Aq] );
\&              $frac_cons = $hsp\->frac_conserved( [\*(Aqquery\*(Aq|\*(Aqhit\*(Aq|\*(Aqtotal\*(Aq] );
\&              $gaps = $hsp\->gaps( [\*(Aqquery\*(Aq|\*(Aqhit\*(Aq|\*(Aqtotal\*(Aq] );
\&              $qseq = $hsp\->query_string;
\&              $hseq = $hsp\->hit_string;
\&              $homo_string = $hsp\->homology_string;
\&              $len = $hsp\->length( [\*(Aqquery\*(Aq|\*(Aqhit\*(Aq|\*(Aqtotal\*(Aq] );
\&              $len = $hsp\->length( [\*(Aqquery\*(Aq|\*(Aqhit\*(Aq|\*(Aqtotal\*(Aq] );
\&              $rank = $hsp\->rank;
\&          }
\&      }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
PullHSP is for fast implementations that only do parsing work on the hsp
data when you actually request information by calling one of the \s-1HSPI\s0
methods.
.PP
Many methods of \s-1HSPI\s0 are implemented in a way suitable for inheriting classes
that use Bio::PullParserI. It only really makes sense for PullHSP modules to be
created by (and have as a \-parent) PullHit modules.
.PP
In addition to the usual \-chunk and \-parent, \-hsp_data is all you should supply
when making a PullHSP object. This will store that data and make it accessible
via _raw_hsp_data, which you can access in your subclass. It would be best to
simply provide the data as the input \-chunk instead, if the raw data is large
enough.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module inherits methods from these other modules:
.PP
Bio::SeqFeatureI,
Bio::SeqFeature::FeaturePair
Bio::SeqFeature::SimilarityPair
.PP
Please refer to these modules for documentation of the 
many additional inherited methods.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Sendu Bala"
.IX Header "AUTHOR - Sendu Bala"
Email bix@sendu.me.uk
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2006 Sendu Bala. All Rights Reserved.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "_setup"
.IX Subsection "_setup"
.Vb 6
\& Title   : _setup
\& Usage   : $self\->_setup(@args)
\& Function: Implementers should call this to setup common fields and deal with
\&           common arguments to new().
\& Returns : n/a
\& Args    : @args received in new().
.Ve
.SS "algorithm"
.IX Subsection "algorithm"
.Vb 5
\& Title   : algorithm
\& Usage   : my $r_type = $hsp\->algorithm
\& Function: Obtain the name of the algorithm used to obtain the HSP
\& Returns : string (e.g., BLASTP)
\& Args    : none
.Ve
.SS "pvalue"
.IX Subsection "pvalue"
.Vb 5
\& Title   : pvalue
\& Usage   : my $pvalue = $hsp\->pvalue();
\& Function: Returns the P\-value for this HSP or undef 
\& Returns : float or exponential (2e\-10)
\& Args    : none
.Ve
.SS "evalue"
.IX Subsection "evalue"
.Vb 5
\& Title   : evalue
\& Usage   : my $evalue = $hsp\->evalue();
\& Function: Returns the e\-value for this HSP
\& Returns : float or exponential (2e\-10)
\& Args    : none
.Ve
.SS "frac_identical"
.IX Subsection "frac_identical"
.Vb 8
\& Title   : frac_identical
\& Usage   : my $frac_id = $hsp\->frac_identical( [\*(Aqquery\*(Aq|\*(Aqhit\*(Aq|\*(Aqtotal\*(Aq] );
\& Function: Returns the fraction of identitical positions for this HSP 
\& Returns : Float in range 0.0 \-> 1.0
\& Args    : \*(Aqquery\*(Aq = num identical / length of query seq (without gaps)
\&           \*(Aqhit\*(Aq   = num identical / length of hit seq (without gaps)
\&           \*(Aqtotal\*(Aq = num identical / length of alignment (with gaps)
\&           default = \*(Aqtotal\*(Aq
.Ve
.SS "frac_conserved"
.IX Subsection "frac_conserved"
.Vb 10
\& Title    : frac_conserved
\& Usage    : my $frac_cons = $hsp\->frac_conserved( [\*(Aqquery\*(Aq|\*(Aqhit\*(Aq|\*(Aqtotal\*(Aq] );
\& Function : Returns the fraction of conserved positions for this HSP.
\&            This is the fraction of symbols in the alignment with a 
\&            positive score.
\& Returns : Float in range 0.0 \-> 1.0
\& Args    : \*(Aqquery\*(Aq = num conserved / length of query seq (without gaps)
\&           \*(Aqhit\*(Aq   = num conserved / length of hit seq (without gaps)
\&           \*(Aqtotal\*(Aq = num conserved / length of alignment (with gaps)
\&           default = \*(Aqtotal\*(Aq
.Ve
.SS "num_identical"
.IX Subsection "num_identical"
.Vb 5
\& Title   : num_identical
\& Usage   : $obj\->num_identical($newval)
\& Function: returns the number of identical residues in the alignment
\& Returns : integer
\& Args    : integer (optional)
.Ve
.SS "num_conserved"
.IX Subsection "num_conserved"
.Vb 5
\& Title   : num_conserved
\& Usage   : $obj\->num_conserved($newval)
\& Function: returns the number of conserved residues in the alignment
\& Returns : inetger
\& Args    : integer (optional)
.Ve
.SS "gaps"
.IX Subsection "gaps"
.Vb 5
\& Title    : gaps
\& Usage    : my $gaps = $hsp\->gaps( [\*(Aqquery\*(Aq|\*(Aqhit\*(Aq|\*(Aqtotal\*(Aq] );
\& Function : Get the number of gap characters in the query, hit, or total alignment.
\& Returns  : Integer, number of gap characters or 0 if none
\& Args     : \*(Aqquery\*(Aq, \*(Aqhit\*(Aq or \*(Aqtotal\*(Aq; default = \*(Aqtotal\*(Aq
.Ve
.SS "query_string"
.IX Subsection "query_string"
.Vb 5
\& Title   : query_string
\& Usage   : my $qseq = $hsp\->query_string;
\& Function: Retrieves the query sequence of this HSP as a string
\& Returns : string
\& Args    : none
.Ve
.SS "hit_string"
.IX Subsection "hit_string"
.Vb 5
\& Title   : hit_string
\& Usage   : my $hseq = $hsp\->hit_string;
\& Function: Retrieves the hit sequence of this HSP as a string
\& Returns : string
\& Args    : none
.Ve
.SS "homology_string"
.IX Subsection "homology_string"
.Vb 8
\& Title   : homology_string
\& Usage   : my $homo_string = $hsp\->homology_string;
\& Function: Retrieves the homology sequence for this HSP as a string.
\&         : The homology sequence is the string of symbols in between the 
\&         : query and hit sequences in the alignment indicating the degree
\&         : of conservation (e.g., identical, similar, not similar).
\& Returns : string
\& Args    : none
.Ve
.SS "length"
.IX Subsection "length"
.Vb 11
\& Title    : length
\& Usage    : my $len = $hsp\->length( [\*(Aqquery\*(Aq|\*(Aqhit\*(Aq|\*(Aqtotal\*(Aq] );
\& Function : Returns the length of the query or hit in the alignment (without gaps) 
\&            or the aggregate length of the HSP (including gaps;
\&            this may be greater than either hit or query )
\& Returns  : integer
\& Args     : \*(Aqquery\*(Aq = length of query seq (without gaps)
\&            \*(Aqhit\*(Aq   = length of hit seq (without gaps)
\&            \*(Aqtotal\*(Aq = length of alignment (with gaps)
\&            default = \*(Aqtotal\*(Aq 
\& Args    : none
.Ve
.SS "hsp_length"
.IX Subsection "hsp_length"
.Vb 5
\& Title   : hsp_length
\& Usage   : my $len = $hsp\->hsp_length()
\& Function: shortcut  length(\*(Aqhsp\*(Aq)
\& Returns : floating point between 0 and 100 
\& Args    : none
.Ve
.SS "percent_identity"
.IX Subsection "percent_identity"
.Vb 5
\& Title   : percent_identity
\& Usage   : my $percentid = $hsp\->percent_identity()
\& Function: Returns the calculated percent identity for an HSP
\& Returns : floating point between 0 and 100 
\& Args    : none
.Ve
.SS "get_aln"
.IX Subsection "get_aln"
.Vb 5
\& Title   : get_aln
\& Usage   : my $aln = $hsp\->get_aln
\& Function: Returns a Bio::SimpleAlign representing the HSP alignment
\& Returns : Bio::SimpleAlign
\& Args    : none
.Ve
.SS "seq_inds"
.IX Subsection "seq_inds"
.Vb 10
\& Title   : seq_inds
\& Purpose   : Get a list of residue positions (indices) for all identical 
\&           : or conserved residues in the query or sbjct sequence.
\& Example   : @s_ind = $hsp\->seq_inds(\*(Aqquery\*(Aq, \*(Aqidentical\*(Aq);
\&           : @h_ind = $hsp\->seq_inds(\*(Aqhit\*(Aq, \*(Aqconserved\*(Aq);
\&           : @h_ind = $hsp\->seq_inds(\*(Aqhit\*(Aq, \*(Aqconserved\*(Aq, 1);
\& Returns   : List of integers 
\&           : May include ranges if collapse is true.
\& Argument  : seq_type  = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq  (default = query)
\&              (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq) 
\&             class     = \*(Aqidentical\*(Aq or \*(Aqconserved\*(Aq or \*(Aqnomatch\*(Aq or \*(Aqgap\*(Aq
\&                          (default = identical)
\&                          (can be shortened to \*(Aqid\*(Aq or \*(Aqcons\*(Aq)
\&                                  Note that \*(Aqconserved\*(Aq includes identical unless you
\&                                  use \*(Aqconserved\-not\-identical\*(Aq
\&
\&             collapse  = boolean, if true, consecutive positions are merged
\&                         using a range notation, e.g., "1 2 3 4 5 7 9 10 11" 
\&                         collapses to "1\-5 7 9\-11". This is useful for 
\&                         consolidating long lists. Default = no collapse.
\& Throws    : n/a.
\& Comments  :
.Ve
.PP
See Also   : \fBBio::Search::BlastUtils::collapse_nums()\fR, \fBBio::Search::Hit::HitI::seq_inds()\fR
.SS "Inherited from Bio::SeqFeature::SimilarityPair"
.IX Subsection "Inherited from Bio::SeqFeature::SimilarityPair"
These methods come from Bio::SeqFeature::SimilarityPair
.SS "query"
.IX Subsection "query"
.Vb 5
\& Title   : query
\& Usage   : my $query = $hsp\->query
\& Function: Returns a SeqFeature representing the query in the HSP
\& Returns : Bio::SeqFeature::Similarity
\& Args    : [optional] new value to set
.Ve
.SS "hit"
.IX Subsection "hit"
.Vb 5
\& Title   : hit
\& Usage   : my $hit = $hsp\->hit
\& Function: Returns a SeqFeature representing the hit in the HSP
\& Returns : Bio::SeqFeature::Similarity
\& Args    : [optional] new value to set
.Ve
.SS "significance"
.IX Subsection "significance"
.Vb 6
\& Title   : significance
\& Usage   : $evalue = $obj\->significance();
\&           $obj\->significance($evalue);
\& Function: Get/Set the significance value (see Bio::SeqFeature::SimilarityPair)
\& Returns : significance value (scientific notation string)
\& Args    : significance value (sci notation string)
.Ve
.SS "score"
.IX Subsection "score"
.Vb 5
\& Title   : score
\& Usage   : my $score = $hsp\->score();
\& Function: Returns the score for this HSP or undef 
\& Returns : numeric           
\& Args    : [optional] numeric to set value
.Ve
.SS "bits"
.IX Subsection "bits"
.Vb 5
\& Title   : bits
\& Usage   : my $bits = $hsp\->bits();
\& Function: Returns the bit value for this HSP or undef 
\& Returns : numeric
\& Args    : none
.Ve
.SS "strand"
.IX Subsection "strand"
.Vb 7
\& Title   : strand
\& Usage   : $hsp\->strand(\*(Aqquery\*(Aq)
\& Function: Retrieves the strand for the HSP component requested
\& Returns : +1 or \-1 (0 if unknown)
\& Args    : \*(Aqhit\*(Aq or \*(Aqsubject\*(Aq or \*(Aqsbjct\*(Aq to retrieve the strand of the subject
\&           \*(Aqquery\*(Aq to retrieve the query strand (default)
\&           \*(Aqlist\*(Aq or \*(Aqarray\*(Aq to retrieve both query and hit together
.Ve
.SS "start"
.IX Subsection "start"
.Vb 7
\& Title   : start
\& Usage   : $hsp\->start(\*(Aqquery\*(Aq)
\& Function: Retrieves the start for the HSP component requested
\& Returns : integer, or list of two integers (query start and subject start) in
\&           list context
\& Args    : \*(Aqhit\*(Aq or \*(Aqsubject\*(Aq or \*(Aqsbjct\*(Aq to retrieve the start of the subject
\&           \*(Aqquery\*(Aq to retrieve the query start (default)
.Ve
.SS "end"
.IX Subsection "end"
.Vb 7
\& Title   : end
\& Usage   : $hsp\->end(\*(Aqquery\*(Aq)
\& Function: Retrieves the end for the HSP component requested
\& Returns : integer, or list of two integers (query end and subject end) in
\&           list context
\& Args    : \*(Aqhit\*(Aq or \*(Aqsubject\*(Aq or \*(Aqsbjct\*(Aq to retrieve the end of the subject
\&           \*(Aqquery\*(Aq to retrieve the query end (default)
.Ve
.SS "seq"
.IX Subsection "seq"
.Vb 7
\& Usage     : $hsp\->seq( [seq_type] );
\& Purpose   : Get the query or sbjct sequence as a Bio::Seq.pm object.
\& Example   : $seqObj = $hsp\->seq(\*(Aqquery\*(Aq);
\& Returns   : Object reference for a Bio::LocatableSeq object.
\& Argument  : seq_type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = \*(Aqquery\*(Aq).
\&           : (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq) 
\&           : default is \*(Aqquery\*(Aq
.Ve
.SS "seq_str"
.IX Subsection "seq_str"
.Vb 11
\& Usage     : $hsp\->seq_str( seq_type );
\& Purpose   : Get the full query, sbjct, or \*(Aqmatch\*(Aq sequence as a string.
\&           : The \*(Aqmatch\*(Aq sequence is the string of symbols in between the 
\&           : query and sbjct sequences.
\& Example   : $str = $hsp\->seq_str(\*(Aqquery\*(Aq);
\& Returns   : String
\& Argument  : seq_Type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq or \*(Aqmatch\*(Aq
\&           :  (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq)
\&           : default is \*(Aqquery\*(Aq
\& Throws    : Exception if the argument does not match an accepted seq_type.
\& Comments  :
.Ve
.PP
See Also   : \fBseq()\fR, \fBseq_inds()\fR, \fB\fB_set_match_seq()\fB\fR
.SS "rank"
.IX Subsection "rank"
.Vb 5
\& Usage     : $hsp\->rank( [string] );
\& Purpose   : Get the rank of the HSP within a given Blast hit.
\& Example   : $rank = $hsp\->rank;
\& Returns   : Integer (1..n) corresponding to the order in which the HSP
\&             appears in the BLAST report.
.Ve
.SS "matches"
.IX Subsection "matches"
.Vb 10
\& Usage     : $hsp\->matches(\-seq   => \*(Aqhit\*(Aq|\*(Aqquery\*(Aq, 
\&                           \-start => $start, 
\&                           \-stop  => $stop);
\& Purpose   : Get the total number of identical and conservative matches 
\&           : in the query or sbjct sequence for the given HSP. Optionally can
\&           : report data within a defined interval along the seq.
\& Example   : ($id,$cons) = $hsp_object\->matches(\-seq   => \*(Aqhit\*(Aq);
\&           : ($id,$cons) = $hsp_object\->matches(\-seq   => \*(Aqquery\*(Aq,
\&                                                \-start => 300,
\&                                                \-stop  => 400);
\& Returns   : 2\-element array of integers 
\& Argument  : (1) seq_type = \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq (default = query)
\&           :  (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq) 
\&           : (2) start = Starting coordinate (optional)
\&           : (3) stop  = Ending coordinate (optional)
.Ve
.SS "n"
.IX Subsection "n"
.Vb 9
\& Usage     : $hsp_obj\->n()
\& Purpose   : Get the N value (num HSPs on which P/Expect is based).
\& Returns   : Integer or null string if not defined.
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : The \*(AqN\*(Aq value is listed in parenthesis with P/Expect value:
\&           : e.g., P(3) = 1.2e\-30  \-\-\-> (N = 3).
\&           : Not defined in NCBI Blast2 with gaps.
\&           : This typically is equal to the number of HSPs but not always.
.Ve
.SS "range"
.IX Subsection "range"
.Vb 11
\& Usage     : $hsp\->range( [seq_type] );
\& Purpose   : Gets the (start, end) coordinates for the query or sbjct sequence
\&           : in the HSP alignment.
\& Example   : ($query_beg, $query_end) = $hsp\->range(\*(Aqquery\*(Aq);
\&           : ($hit_beg, $hit_end) = $hsp\->range(\*(Aqhit\*(Aq);
\& Returns   : Two\-element array of integers 
\& Argument  : seq_type = string, \*(Aqquery\*(Aq or \*(Aqhit\*(Aq or \*(Aqsbjct\*(Aq  (default = \*(Aqquery\*(Aq)
\&           :  (\*(Aqsbjct\*(Aq is synonymous with \*(Aqhit\*(Aq) 
\& Throws    : n/a
\& Comments  : This is a convenience method for constructions such as
\&             ($hsp\->query\->start, $hsp\->query\->end)
.Ve
