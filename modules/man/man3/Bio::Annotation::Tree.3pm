.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Annotation::Tree 3pm"
.TH Bio::Annotation::Tree 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Annotation::Tree \- Provide a tree as an annotation to a Bio::AnnotatableI
object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   # Read a tree and an alignment
\&
\&   $treeio=Bio::TreeIO\->new(\-file=>\*(Aqfoo.dnd\*(Aq, \-format=>\*(Aqnewic\*(Aq);
\&   $tree=$treeio\->next_tree;
\&   $alnio=Bio::AlignIO\->new(\-file=>\*(Aqfoo.aln\*(Aq, \-format=>\*(Aqclustalw\*(Aq);
\&   $aln=$alnio\->next_aln;
\&
\&   # Construct a tree annotation
\&   $ann_tree = Bio::Annotation::Tree\->new (\-tree_id  => \*(Aqmytree\*(Aq,
\&                                           \-tree_obj     => $tree,
\&                                            );
\&
\&   # Add the tree annotation to AlignI
\&   $ac = Bio::Annotation::Collection\->new();
\&   $ac\->add_Annotation(\*(Aqtree\*(Aq, $ann_tree);
\&   $aln\->annotation($ac);
\&
\&   # NOTE & TODO: 
\&   # The above procedures are sensible only if 
\&   # the tree is generated from the alignment.  However, 
\&   # currently no effort has been made to check the consistency
\&   # between the tree OTU names and the sequence names
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Provides a Bio::AnnotationI object which contains a Bio::Tree::TreeI, which can
be added to a Bio::AnnotationCollectionI, which in turn be attached to a
Bio::AnnotatableI (typically a Bio::AlignI object)
.SH "AUTHOR"
.IX Header "AUTHOR"
Weigang Qiu \- weigang at genectr.hunter.cuny.edu
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Aaron Mackey
Jason Stajich
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a '_'
.SH "AnnotationI implementing functions"
.IX Header "AnnotationI implementing functions"
.SS "as_text"
.IX Subsection "as_text"
.Vb 5
\& Title   : as_text
\& Usage   : $ann_tree\->as_text();
\& Function: output tree as a string
\& Returns : a newic tree file
\& Args    : None
.Ve
.SS "display_text"
.IX Subsection "display_text"
.Vb 4
\& Title   : display_text
\& Usage   : my $str = $ann\->display_text();
\& Function: returns a string. Unlike as_text(), this method returns a string
\&           formatted as would be expected for te specific implementation.
\&
\&           One can pass a callback as an argument which allows custom text
\&           generation; the callback is passed the current instance and any text
\&           returned
\& Example :
\& Returns : a string
\& Args    : [optional] callback
.Ve
.SS "hash_tree"
.IX Subsection "hash_tree"
.Vb 6
\& Title   : hash_tree
\& Usage   : my $hashtree = $value\->hash_tree
\& Function: For supporting the AnnotationI interface just returns the value
\&           as a hashref with the key \*(Aqvalue\*(Aq pointing to the value
\& Returns : hashrf to tree
\& Args    : none
.Ve
.SS "tagname"
.IX Subsection "tagname"
.Vb 11
\& Title   : tagname
\& Usage   : $obj\->tagname($newval)
\& Function: Get/set the tagname for this annotation value.
\&           Setting this is optional. If set, it obviates the need to
\&           provide a tag to Bio::AnnotationCollectionI when adding
\&           this object. When obtaining an AnnotationI object from the
\&           collection, the collection will set the value to the tag
\&           under which it was stored unless the object has a tag
\&           stored already.
\& Returns : value of tagname (a scalar)
\& Args    : new value (a scalar, optional)
.Ve
.SH "Specific accessors for Tree"
.IX Header "Specific accessors for Tree"
.SS "tree_id"
.IX Subsection "tree_id"
.Vb 5
\& Title   : tree_id
\& Usage   : $obj\->tree_id($newval)
\& Function: Get/set a name for the tree
\& Returns : value of tagname (a scalar)
\& Args    : new value (a scalar, optional)
.Ve
.SS "tree"
.IX Subsection "tree"
.Vb 5
\& Title   : tree
\& Usage   : $obj\->tree($newval)
\& Function: Get/set tree
\& Returns : tree ref
\& Args    : new value (a tree ref, optional)
.Ve
