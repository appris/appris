.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Seq::EncodedSeq 3pm"
.TH Bio::Seq::EncodedSeq 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Seq::EncodedSeq \- subtype of Bio::LocatableSeq to store DNA that encodes a protein
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  $obj = Bio::Seq::EncodedSeq\->new( \-seq      => $dna,
\&                                    \-encoding => "CCCCCCCIIIIICCCCC",
\&                                    \-start    => 1,
\&                                    \-strand   => 1,
\&                                    \-length   => 17 );
\&
\&  # splice out (and possibly revcomp) the coding sequence
\&  $cds = obj\->cds;
\&
\&  # obtain the protein translation of the sequence
\&  $prot = $obj\->translate;
\&
\&  # other access/inspection routines as with Bio::LocatableSeq and
\&  # Bio::SeqI; note that coordinates are relative only to the DNA
\&  # sequence, not it\*(Aqs implicit encoded protein sequence.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Seq::EncodedSeq is a Bio::LocatableSeq
object that holds a \s-1DNA\s0 sequence as well as information about the
coding potential of that \s-1DNA\s0 sequence.  It is meant to be useful in an
alignment context, where the \s-1DNA\s0 may contain frameshifts, gaps and/or
introns, or in describing the transcript of a gene.  An EncodedSeq
provides the ability to access the \*(L"spliced\*(R" coding sequence, meaning
that all introns and gaps are removed, and any frameshifts are
adjusted to provide a \*(L"clean\*(R" \s-1CDS.\s0
.PP
In order to make simultaneous use of either the \s-1DNA\s0 or the implicit
encoded protein sequence coordinates, please see
Bio::Coordinate::EncodingPair.
.SH "ENCODING"
.IX Header "ENCODING"
We use the term \*(L"encoding\*(R" here to refer to the series of symbols that
we use to identify which residues of a \s-1DNA\s0 sequence are protein-coding
(i.e. part of a codon), intronic, part of a 5' or 3', frameshift
\&\*(L"mutations\*(R", etc.  From this information, a Bio::Seq::EncodedSeq is
able to \*(L"figure out\*(R" its translational \s-1CDS.\s0  There are two sets of
coding characters, one termed \*(L"implicit\*(R" and one termed \*(L"explicit\*(R".
.PP
The \*(L"implicit\*(R" encoding is a bit simpler than the \*(L"explicit\*(R" encoding:
\&'C' is used for any nucleotide that's part of a codon, 'U' for any
\&\s-1UTR,\s0 etc.  The full list is shown below:
.PP
.Vb 8
\& Code  Meaning
\& \-\-\-\-  \-\-\-\-\-\-\-
\&  C    coding
\&  I    intronic
\&  U    untranslated
\&  G    gapped (for use in alignments)
\&  F    a "forward", +1 frameshift
\&  B    a "backward", \-1 frameshift
.Ve
.PP
The \*(L"explicit\*(R" encoding is just an expansion of the \*(L"implicit\*(R"
encoding, to denote phase:
.PP
.Vb 5
\& Code  Meaning
\& \-\-\-\-  \-\-\-\-\-\-\-
\&  C    coding, 1st codon position
\&  D    coding, 2nd codon position
\&  E    coding, 3rd codon position
\&
\&  I    intronic, phase 0 (relative to intron begin)
\&  J    intronic, phase 1
\&  K    intronic, phase 2
\&
\&  U    untranslated 3\*(AqUTR
\&  V    untranslated 5\*(AqUTR
\&
\&  G    gapped (for use in alignments)
\&  F    a "forward", +1 frameshift
\&  B    a "backward", \-1 frameshift
.Ve
.PP
Note that the explicit coding is meant to provide easy access to
position/phase specific nucleotides:
.PP
.Vb 3
\&  $obj = Bio::Seq::EncodedSeq\->new(\-seq => "ACAATCAGACTACG...",
\&                                   \-encoding => "CCCCCCIII..."
\&                                  );
\&
\&  # fetch arrays of nucleotides at each codon position:
\&  my @pos1 = $obj\->dnaseq(encoding => \*(AqC\*(Aq, explicit => 1);
\&  my @pos2 = $obj\->dnaseq(encoding => \*(AqD\*(Aq);
\&  my @pos3 = $obj\->dnaseq(encoding => \*(AqE\*(Aq);
\&
\&  # fetch arrays of "3\-1" codon dinucleotides, useful for genomic
\&  # signature analyses without compounding influences of codon bias:
\&  my @pairs = $obj\->dnaseq(encoding => \*(AqEC\*(Aq);
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Aaron Mackey"
.IX Header "AUTHOR - Aaron Mackey"
Email amackey@virginia.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 11
\& Title   : new
\& Usage   : $obj = Bio::Seq::EncodedSeq\->new(\-seq      => "AGTACGTGTCATG",
\&                                            \-encoding => "CCCCCCFCCCCCC",
\&                                            \-id       => "myseq",
\&                                            \-start    => 1,
\&                                            \-end      => 13,
\&                                            \-strand   => 1
\&                                      );
\& Function: creates a new Bio::Seq::EncodedSeq object from a supplied DNA
\&           sequence
\& Returns : a new Bio::Seq::EncodedSeq object
\&
\& Args    : seq      \- primary nucleotide sequence used to encode the
\&                      protein; note that any positions involved in a
\&                      gap (\*(AqG\*(Aq) or backward frameshift (\*(AqB\*(Aq) should
\&                      have one or more gap characters; if the encoding
\&                      specifies G or B, but no (or not enough) gap
\&                      characters exist, *they\*(Aqll be added*; similarly,
\&                      if there are gap characters without a
\&                      corresponding G or B encoding, G\*(Aqs will be
\&                      inserted into the encoding.  This allows some
\&                      flexibility in specifying your sequence and
\&                      coding without having to calculate a lot of the
\&                      encoding for yourself.
\&
\&           encoding \- a string of characters (see Encoding Table)
\&                      describing backwards frameshifts implied by the
\&                      encoding but not present in the sequence will be
\&                      added (as \*(Aq\-\*(Aqs) to the sequence.  If not
\&                      supplied, it will be assumed that all positions
\&                      are coding (C).  Encoding may include either
\&                      implicit phase encoding characters (i.e. "CCC")
\&                      and/or explicit encoding characters (i.e. "CDE").
\&                      Additionally, prefixed numbers may be used to
\&                      denote repetition (i.e. "27C3I28C").
\&
\&                      Alternatively, encoding may be a hashref
\&                      datastructure, with encoding characters as keys
\&                      and Bio::LocationI objects (or arrayrefs of
\&                      Bio::LocationI objects) as values, e.g.:
\&
\&                      { C => [ Bio::Location::Simple\->new(1,9),
\&                               Bio::Location::Simple\->new(11,13) ],
\&                        F => Bio::Location::Simple\->new(10,10),
\&                      } # same as "CCCCCCCCCFCCC"
\&
\&                      Note that if the location ranges overlap, the
\&                      behavior of the encoding will be undefined
\&                      (well, it will be defined, but only according to
\&                      the order in which the hash keys are read, which
\&                      is basically undefined ... just don\*(Aqt do that).
\&
\&           id, start, end, strand \- as with Bio::LocatableSeq; note
\&                      that the coordinates are relative to the
\&                      encoding DNA sequence, not the implicit protein
\&                      sequence.  If strand is reversed, then the
\&                      encoding is assumed to be relative to the
\&                      reverse strand as well.
.Ve
.SS "encoding"
.IX Subsection "encoding"
.Vb 11
\& Title   : encoding
\& Usage   : $obj\->encoding("CCCCCC");
\&           $obj\->encoding( \-encoding => { I => $location } );
\&           $enc = $obj\->encoding(\-explicit => 1);
\&           $enc = $obj\->encoding("CCCCCC", \-explicit => 1);
\&           $enc = $obj\->encoding(\-location => $location,
\&                                 \-explicit => 1,
\&                                 \-absolute => 1 );
\& Function: get/set the objects encoding, either globally or by location(s).
\& Returns : the (possibly new) encoding string.
\& Args    : encoding \- see the encoding argument to the new() function.
\&
\&           explicit \- whether or not to return explicit phase
\&                      information in the coding (i.e. "CCC" becomes
\&                      "CDE", "III" becomes "IJK", etc); defaults to 0.
\&
\&           location \- optional; location to get/set the encoding.
\&                      Defaults to the entire sequence.
\&
\&           absolute \- whether or not the locational elements (either
\&                      in the encoding hashref or the location
\&                      argument) are relative to the absolute start/end
\&                      of the Bio::LocatableSeq, or to the internal,
\&                      relative coordinate system (beginning at 1);
\&                      defaults to 0 (i.e. relative)
.Ve
.SS "cds"
.IX Subsection "cds"
.Vb 10
\& Title   : cds
\& Usage   : $cds = $obj\->cds(\-nogaps => 1);
\& Function: obtain the "spliced" DNA sequence, by removing any
\&           nucleotides that participate in an UTR, forward frameshift
\&           or intron, and replacing any unknown nucleotide implied by
\&           a backward frameshift or gap with N\*(Aqs.
\& Returns : a Bio::Seq::EncodedSeq object, with an encoding consisting only
\&           of "CCCC..".
\& Args    : nogaps \- strip any gap characters (resulting from \*(AqG\*(Aq or \*(AqB\*(Aq
\&           encodings), rather than replacing them with N\*(Aqs.
.Ve
.SS "translate"
.IX Subsection "translate"
.Vb 6
\& Title   : translate
\& Usage   : $prot = $obj\->translate(@args);
\& Function: obtain the protein sequence encoded by the underlying DNA
\&           sequence; same as $obj\->cds()\->translate(@args).
\& Returns : a Bio::PrimarySeq object.
\& Args    : same as the translate() function of Bio::PrimarySeqI
.Ve
.SS "protseq"
.IX Subsection "protseq"
.Vb 9
\& Title   : seq
\& Usage   : $protseq = $obj\->protseq();
\& Function: obtain the raw protein sequence encoded by the underlying
\&           DNA sequence; This is the same as calling
\&           $obj\->translate()\->seq();
\& Returns : a string of single\-letter amino acid codes
\& Args :    same as the seq() function of Bio::PrimarySeq; note that this
\&           function may not be used to set the protein sequence; see
\&           the dnaseq() function for that.
.Ve
.SS "dnaseq"
.IX Subsection "dnaseq"
.Vb 10
\& Title   : dnaseq
\& Usage   : $dnaseq = $obj\->dnaseq();
\&           $obj\->dnaseq("ACGTGTCGT", "CCCCCCCCC");
\&           $obj\->dnaseq(\-seq      => "ATG",
\&                        \-encoding => "CCC",
\&                        \-location => $loc );
\&           @introns = $obj\->$dnaseq(\-encoding => \*(AqI\*(Aq)
\& Function: get/set the underlying DNA sequence; will overwrite any
\&           current DNA and/or encoding information present.
\& Returns : a string of single\-letter nucleotide codes, including any
\&           gaps implied by the encoding.
\& Args    : seq      \- the DNA sequence to be used as a replacement
\&           encoding \- the encoding of the DNA sequence (see the new()
\&                      constructor); defaults to all \*(AqC\*(Aq if setting a
\&                      new DNA sequence.  If no new DNA sequence is
\&                      being provided, then the encoding is used as a
\&                      "filter" for which to return fragments of
\&                      non\-overlapping DNA that match the encoding.
\&           location \- optional, the location of the DNA sequence to
\&                      get/set; defaults to the entire sequence.
.Ve
