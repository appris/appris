.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Seq::RichSeq 3pm"
.TH Bio::Seq::RichSeq 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Seq::RichSeq \- Module implementing a sequence created from a rich
sequence database entry
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Bio::Seq::RichSeqI and documentation of methods.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements Bio::Seq::RichSeqI, an interface for sequences
created from or created for entries from/of rich sequence databanks,
like \s-1EMBL,\s0 GenBank, and SwissProt. Methods added to the Bio::SeqI
interface therefore focus on databank-specific information. Note that
not every rich databank format may use all of the properties provided.
.PP
For more information, please see the relevant
.SH "Implemented Interfaces"
.IX Header "Implemented Interfaces"
This class implementes the following interfaces.
.IP "Bio::Seq::RichSeqI" 4
.IX Item "Bio::Seq::RichSeqI"
Note that this includes implementing Bio::PrimarySeqI and Bio::SeqI,
specifically via Bio::Seq and Bio::PrimarySeq. Please review the
documentation for those modules on implementation details relevant to those
interfaces, as well as the ones below.
.IP "Bio::IdentifiableI" 4
.IX Item "Bio::IdentifiableI"
.PD 0
.IP "Bio::DescribableI" 4
.IX Item "Bio::DescribableI"
.IP "Bio::AnnotatableI" 4
.IX Item "Bio::AnnotatableI"
.PD
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this
and other Bioperl modules. Send your comments and suggestions preferably
 to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Email birney@ebi.ac.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : $seq    = Bio::Seq::RichSeq\->new( \-seq => \*(AqATGGGGGTGGTGGTACCCT\*(Aq,
\&                                             \-id  => \*(Aqhuman_id\*(Aq,
\&                                             \-accession_number => \*(AqAL000012\*(Aq,
\&                                            );
\&
\& Function: Returns a new seq object from
\&           basic constructors, being a string for the sequence
\&           and strings for id and accession_number
\& Returns : a new Bio::Seq::RichSeq object
.Ve
.SS "division"
.IX Subsection "division"
.Vb 5
\& Title   : division
\& Usage   : $obj\->division($newval)
\& Function: 
\& Returns : value of division
\& Args    : newvalue (optional)
.Ve
.SS "molecule"
.IX Subsection "molecule"
.Vb 5
\& Title   : molecule
\& Usage   : $obj\->molecule($newval)
\& Function: 
\& Returns : type of molecule (DNA, mRNA)
\& Args    : newvalue (optional)
.Ve
.SS "add_date"
.IX Subsection "add_date"
.Vb 3
\& Title   : add_date
\& Usage   : $self\->add_date($datestr)
\& Function: adds one or more dates
\&
\&           This implementation stores dates as keyed annotation, the
\&           key being \*(Aqdate_changed\*(Aq. You can take advantage of this
\&           fact when accessing the annotation collection directly.
\&
\& Example :
\& Returns : 
\& Args    : a date string or an array of such strings
.Ve
.SS "get_dates"
.IX Subsection "get_dates"
.Vb 6
\& Title   : get_dates
\& Usage   : my @dates = $seq\->get_dates;
\& Function: Get the dates of the sequence (usually, when it was created and
\&           changed.
\& Returns : an array of date strings
\& Args    :
.Ve
.SS "pid"
.IX Subsection "pid"
.Vb 6
\& Title   : pid
\& Usage   : my $pid = $seq\->pid();
\& Function: Get (and set, depending on the implementation) the PID property
\&           for the sequence.
\& Returns : a string
\& Args    :
.Ve
.SS "accession"
.IX Subsection "accession"
.Vb 4
\& Title   : accession
\& Usage   : $obj\->accession($newval)
\& Function: Whilst the underlying sequence object does not 
\&           have an accession, so we need one here.
\&
\&           In this implementation this is merely a synonym for
\&           accession_number().
\& Example : 
\& Returns : value of accession
\& Args    : newvalue (optional)
.Ve
.SS "add_secondary_accession"
.IX Subsection "add_secondary_accession"
.Vb 3
\& Title   : add_secondary_accession
\& Usage   : $self\->add_domment($ref)
\& Function: adds a secondary_accession
\&
\&           This implementation stores secondary accession numbers as
\&           keyed annotation, the key being \*(Aqsecondary_accession\*(Aq. You
\&           can take advantage of this fact when accessing the
\&           annotation collection directly.
\&
\& Example :
\& Returns : 
\& Args    : a string or an array of strings
.Ve
.SS "get_secondary_accessions"
.IX Subsection "get_secondary_accessions"
.Vb 5
\& Title   : get_secondary_accessions
\& Usage   : my @acc = $seq\->get_secondary_accessions();
\& Function: Get the secondary accession numbers as strings.
\& Returns : An array of strings
\& Args    : none
.Ve
.SS "seq_version"
.IX Subsection "seq_version"
.Vb 8
\& Title   : seq_version
\& Usage   : $obj\->seq_version($newval)
\& Function: Get/set the sequence version
\& Returns : value of seq_version (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
\& Note    : this differs from Bio::PrimarySeq version() in that this explicitly
\&           refers to the sequence record version one would find in a typical
\&           sequence file.
.Ve
.SS "add_keyword"
.IX Subsection "add_keyword"
.Vb 3
\& Title   : add_keyword
\& Usage   : $obj\->add_keyword($newval)
\& Function: Add a new keyword to the annotation of the sequence.
\&
\&           This implementation stores keywords as keyed annotation,
\&           the key being \*(Aqkeyword\*(Aq. You can take advantage of this
\&           fact when accessing the annotation collection directly.
\&
\& Returns : 
\& Args    : value to be added (optional) (a string)
.Ve
.SS "get_keywords"
.IX Subsection "get_keywords"
.Vb 5
\& Title   : get_keywords
\& Usage   : $obj\->get_keywords($newval)
\& Function: Get the keywords for this sequence as an array of strings.
\& Returns : an array of strings
\& Args    :
.Ve
.SH "Private methods and synonyms for backward compatibility"
.IX Header "Private methods and synonyms for backward compatibility"
.SS "_add_annotation_value"
.IX Subsection "_add_annotation_value"
.Vb 6
\& Title   : _add_annotation_value
\& Usage   :
\& Function: Adds a value to the annotation collection under the specified
\&           key. Note that this is not a public method.
\& Returns : 
\& Args    : key (a string), value(s) (one or more scalars)
.Ve
.SS "_get_annotation_values"
.IX Subsection "_get_annotation_values"
.Vb 8
\& Title   : _get_annotation_values
\& Usage   :
\& Function: Gets the values of a specific annotation as identified by the
\&           key from the annotation collection. Note that this is not a
\&           public method.
\& Example :
\& Returns : an array of strings
\& Args    : the key (a string)
.Ve
