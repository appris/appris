.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Matrix::PSM::SiteMatrix 3pm"
.TH Bio::Matrix::PSM::SiteMatrix 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Matrix::PSM::SiteMatrix \- SiteMatrixI implementation, holds a
position scoring matrix (or position weight matrix) and log\-odds
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use Bio::Matrix::PSM::SiteMatrix;
\&  # Create from memory by supplying probability matrix hash
\&  # both as strings or arrays
\&  # where the frequencies  $a,$c,$g and $t are supplied either as
\&  # arrayref or string. Accordingly, lA, lC, lG and lT are the log
\&  # odds (only as arrays, no checks done right now)
\&  my ($a,$c,$g,$t,$score,$ic, $mid)=@_; 
\&  #or
\&  my ($a,$c,$g,$t,$score,$ic,$mid)=(\*(Aq05a011\*(Aq,\*(Aq110550\*(Aq,\*(Aq400001\*(Aq,
\&                                    \*(Aq100104\*(Aq,0.001,19.2,\*(AqCRE1\*(Aq);
\&  #Where a stands for all (this frequency=1), see explanation below
\&  my %param=(\-pA=>$a,\-pC=>$c,\-pG=>$g,\-pT=>$t,
\&             \-lA=>$la, \-lC=>$lc,\-lG=>$lg,\-lT=>$l,
\&             \-IC=>$ic,\-e_val=>$score, \-id=>$mid);
\&  my $site=Bio::Matrix::PSM::SiteMatrix\->new(%param);
\&  #Or get it from a file:
\&  use Bio::Matrix::PSM::IO;
\&  my $psmIO= Bio::Matrix::PSM::IO\->new(\-file=>$file, \-format=>\*(Aqtransfac\*(Aq);
\&  while (my $psm=$psmIO\->next_psm) {
\&    #Now we have a Bio::Matrix::PSM::Psm object, 
\&    # see Bio::Matrix::PSM::PsmI for details
\&    #This is a Bio::Matrix::PSM::SiteMatrix object now
\&    my $matrix=$psm\->matrix;  
\&  }
\&
\&  # Get a simple consensus, where alphabet is {A,C,G,T,N}, 
\&  # choosing the character that both satisfies a supplied or default threshold
\&  # frequency and is the most frequenct character at each position, or N.
\&  # So for the position with A, C, G, T frequencies of 0.5, 0.25, 0.10, 0.15,
\&  # the simple consensus character will be \*(AqA\*(Aq, whilst for 0.5, 0.5, 0, 0 it
\&  # would be \*(AqN\*(Aq.
\&  my $consensus=$site\->consensus;
\&
\&  # Get the IUPAC ambiguity code representation of the data in the matrix.
\&  # Because the frequencies may have been pseudo\-count corrected, insignificant
\&  # frequences (below 0.05 by default) are ignored. So a position with
\&  # A, C, G, T frequencies of 0.5, 0.5, 0.01, 0.01 will get the IUPAC code \*(AqM\*(Aq,
\&  # while 0.97, 0.01, 0.01, 0.01 will get the code \*(AqA\*(Aq and
\&  # 0.25, 0.25, 0.25, 0.25 would get \*(AqN\*(Aq.
\&  my $iupac=$site\->IUPAC;
\&
\&  # Getting/using regular expression (a representation of the IUPAC string)
\&  my $regexp=$site\->regexp;
\&  my $count=grep($regexp,$seq);
\&  my $count=($seq=~ s/$regexp/$1/eg);
\&  print "Motif $mid is present $count times in this sequence\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SiteMatrix is designed to provide some basic methods when working with position
scoring (weight) matrices, such as transcription factor binding sites for
example. A \s-1DNA PSM\s0 consists of four vectors with frequencies {A,C,G,T}. This is
the minimum information you should provide to construct a \s-1PSM\s0 object. The
vectors can be provided as strings with frequenciesx10 rounded to an int, going
from {0..a} and 'a' represents the maximum (10). This is like \s-1MEME\s0's compressed
representation of a matrix and it is quite useful when working with relational
\&\s-1DB.\s0 If arrays are provided as an input (references to arrays actually) they can
be any number, real or integer (frequency or count).
.PP
When creating the object you can ask the constructor to make a simple pseudo
count correction by adding a number (typically 1) to all positions (with the
\&\-correction option). After adding the number the frequencies will be
calculated. Only use correction when you supply counts, not frequencies.
.PP
Throws an exception if: You mix as an input array and string (for example A
matrix is given as array, C \- as string). The position vector is (0,0,0,0). One
of the probability vectors is shorter than the rest.
.PP
Summary of the methods I use most frequently (details below):
.PP
.Vb 10
\&  iupac \- return IUPAC compliant consensus as a string
\&  score \- Returns the score as a real number
\&  IC \- information content. Returns a real number
\&  id \- identifier. Returns a string
\&  accession \- accession number. Returns a string
\&  next_pos \- return the sequence probably for each letter, IUPAC
\&      symbol, IUPAC probability and simple sequence
\&  consenus letter for this position. Rewind at the end. Returns a hash.
\&  pos \- current position get/set. Returns an integer.
\&  regexp \- construct a regular expression based on IUPAC consensus.
\&      For example AGWV will be [Aa][Gg][AaTt][AaCcGg]
\&  width \- site width
\&  get_string \- gets the probability vector for a single base as a string.
\&  get_array \- gets the probability vector for a single base as an array.
\&  get_logs_array \- gets the log\-odds vector for a single base as an array.
.Ve
.PP
New methods, which might be of interest to anyone who wants to store
\&\s-1PSM\s0 in a relational database without creating an entry for each
position is the ability to compress the \s-1PSM\s0 vector into a string with
losing usually less than 1% of the data.  this can be done with:
.PP
.Vb 3
\&  my $str=$matrix\->get_compressed_freq(\*(AqA\*(Aq);
\&or
\&  my $str=$matrix\->get_compressed_logs(\*(AqA\*(Aq);
.Ve
.PP
Loading from a database should be done with new, but is not yest implemented.
However you can still uncompress such string with:
.PP
.Vb 3
\&  my @arr=Bio::Matrix::PSM::_uncompress_string ($str,1,1); for PSM
\&or
\&  my @arr=Bio::Matrix::PSM::_uncompress_string ($str,1000,2); for log odds
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- Stefan Kirov"
.IX Header "AUTHOR - Stefan Kirov"
Email skirov@utk.edu
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Sendu Bala, bix@sendu.me.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : my $site=Bio::Matrix::PSM::SiteMatrix\->new(\-pA=>$a,\-pC=>$c,
\&                                                     \-pG=>$g,\-pT=>$t,
\&                                                     \-IC=>$ic,
\&                                                     \-e_val=>$score, 
\&                                                     \-id=>$mid);
\& Function: Creates a new Bio::Matrix::PSM::SiteMatrix object from memory
\& Throws :  If inconsistent data for all vectors (A,C,G and T) is
\&           provided, if you mix input types (string vs array) or if a
\&           position freq is 0.
\& Returns :  Bio::Matrix::PSM::SiteMatrix object
\& Args    :  \-pA    => vector with the frequencies or counts of A
\&            \-pC    => vector for C
\&            \-pG    => vector for G
\&            \-pt    => vector for T
\&            \-lA    => vector for the log of A
\&            \-lC    => vector for the log of C
\&            \-lG    => vector for the log of G
\&            \-lT    => vector for the log of T
\&            \-IC    => real number, the information content of this matrix
\&            \-e_val => real number, the expect value
\&            \-id    => string, an identifier
\&            \-width => int, width of the matrix in nucleotides
\&            \-sites => int, the number of sites that went into this matrix
\&            \-model => hash ref, background frequencies for A, C, G and T
\&            \-correction => number, the number to add to all positions to achieve
\&                           pseudo count correction (default 0: no correction)
\&                           NB: do not use correction when your input is
\&                           frequences!
\&            \-accession_number => string, an accession number
\&
\&            Vectors can be strings of the frequencies where the frequencies are
\&            multiplied by 10 and rounded to the nearest whole number, and where
\&            \*(Aqa\*(Aq is used to denote the maximal frequency 10. There should be no
\&            punctuation (spaces etc.) in the string. For example, \*(Aqa0501\*(Aq.
\&            Alternatively frequencies or counts can be represented by an array
\&            ref containing the counts, frequencies or logs as any kind of
\&            number.
.Ve
.SS "_calculate_consensus"
.IX Subsection "_calculate_consensus"
.Vb 2
\& Title   : _calculate_consensus
\& Function: Internal stuff
.Ve
.SS "calc_weight"
.IX Subsection "calc_weight"
.Vb 7
\& Title   : calc_weight
\& Usage   : $obj\->calc_weight({A=>0.2562, C=>0.2438, G=>0.2432, T=>0.2568});
\& Function: Recalculates the PSM (or weights) based on the PFM (the frequency
\&           matrix) and user supplied background model.
\& Throws  : if no model is supplied
\& Returns : n/a
\& Args    : reference to a hash with background frequencies for A,C,G and T
.Ve
.SS "next_pos"
.IX Subsection "next_pos"
.Vb 7
\& Title   : next_pos
\& Usage   :
\& Function: Retrieves the next position features: frequencies for A,C,G,T, the
\&           main letter (as in consensus) and the probabilty for this letter to
\&           occur at this position and the current position
\& Returns : hash (pA,pC,pG,pT,logA,logC,logG,logT,base,prob,rel)
\& Args    : none
.Ve
.SS "curpos"
.IX Subsection "curpos"
.Vb 6
\& Title   : curpos
\& Usage   :
\& Function: Gets/sets the current position. Converts to 0 if argument is minus
\&           and to width if greater than width
\& Returns : integer
\& Args    : integer
.Ve
.SS "e_val"
.IX Subsection "e_val"
.Vb 5
\& Title   : e_val
\& Usage   : 
\& Function: Gets/sets the e\-value
\& Returns : real number
\& Args    : none to get, real number to set
.Ve
.SS "\s-1IC\s0"
.IX Subsection "IC"
.Vb 5
\& Title   : IC
\& Usage   :
\& Function: Get/set the Information Content
\& Returns : real number
\& Args    : none to get, real number to set
.Ve
.SS "accession_number"
.IX Subsection "accession_number"
.Vb 6
\& Title   : accession_number
\& Function: Get/set the accession number, this will be unique id for the
\&           SiteMatrix object as well for any other object, inheriting from
\&           SiteMatrix
\& Returns : string
\& Args    : none to get, string to set
.Ve
.SS "consensus"
.IX Subsection "consensus"
.Vb 7
\& Title   : consensus
\& Usage   :
\& Function: Returns the consensus
\& Returns : string
\& Args    : (optional) threshold value 1 to 10, default 5
\&           \*(Aq5\*(Aq means the returned characters had a 50% or higher presence at
\&           their position
.Ve
.SS "width"
.IX Subsection "width"
.Vb 5
\& Title   : width
\& Usage   :
\& Function: Returns the length of the sites in used to make this matrix
\& Returns : int
\& Args    : none
.Ve
.SS "sites"
.IX Subsection "sites"
.Vb 5
\& Title   : sites
\& Usage   :
\& Function: Get/set the number of sites that were used to make this matrix
\& Returns : int
\& Args    : none to get, int to set
.Ve
.SS "\s-1IUPAC\s0"
.IX Subsection "IUPAC"
.Vb 8
\& Title   : IUPAC
\& Usage   :
\& Function: Returns IUPAC compliant consensus
\& Returns : string
\& Args    : optionally, also supply a whole number (int) of 1 or higher to set
\&           the significance level when considering the frequencies. 1 (the
\&           default) means a 0.05 significance level: frequencies lower than
\&           0.05 will be ignored. 2 Means a 0.005 level, and so on.
.Ve
.SS "_to_IUPAC"
.IX Subsection "_to_IUPAC"
.Vb 6
\& Title   : _to_IUPAC
\& Usage   :
\& Function: Converts a single position to IUPAC compliant symbol.
\&           For rules see the implementation
\& Returns : char, real number
\& Args    : real numbers for frequencies of A,C,G,T (positional)
\&
\&           optionally, also supply a whole number (int) of 1 or higher to set
\&           the significance level when considering the frequencies. 1 (the
\&           default) means a 0.05 significance level: frequencies lower than
\&           0.05 will be ignored. 2 Means a 0.005 level, and so on.
.Ve
.SS "_to_cons"
.IX Subsection "_to_cons"
.Vb 9
\& Title   : _to_cons
\& Usage   :
\& Function: Converts a single position to simple consensus character and returns
\&           its probability. For rules see the implementation
\& Returns : char, real number
\& Args    : real numbers for A,C,G,T (positional), and optional 5th argument of
\&           threshold (as a number between 1 and 10, where 5 is default and
\&           means the returned character had a 50% or higher presence at this
\&           position)
.Ve
.SS "get_string"
.IX Subsection "get_string"
.Vb 7
\& Title   : get_string
\& Usage   :
\& Function: Returns given probability vector as a string. Useful if you want to
\&           store things in a rel database, where arrays are not first choice
\& Throws  : If the argument is outside {A,C,G,T}
\& Returns : string
\& Args    : character {A,C,G,T}
.Ve
.SS "get_array"
.IX Subsection "get_array"
.Vb 5
\& Title   : get_array
\& Usage   :
\& Function: Returns an array with frequencies for a specified base
\& Returns : array
\& Args    : char
.Ve
.SS "get_logs_array"
.IX Subsection "get_logs_array"
.Vb 5
\& Title   : get_logs_array
\& Usage   :
\& Function: Returns an array with log_odds for a specified base
\& Returns : array
\& Args    : char
.Ve
.SS "id"
.IX Subsection "id"
.Vb 5
\& Title   : id
\& Usage   :
\& Function: Gets/sets the site id
\& Returns : string
\& Args    : string
.Ve
.SS "regexp"
.IX Subsection "regexp"
.Vb 6
\& Title   : regexp
\& Usage   :
\& Function: Returns a regular expression which matches the IUPAC convention.
\&           N will match X, N, \- and .
\& Returns : string
\& Args    : none (works at the threshold last used for making the IUPAC string)
.Ve
.SS "regexp_array"
.IX Subsection "regexp_array"
.Vb 8
\& Title   : regexp_array
\& Usage   :
\& Function: Returns a regular expression which matches the IUPAC convention.
\&           N will match X, N, \- and .
\& Returns : array
\& Args    : none (works at the threshold last used for making the IUPAC string)
\& To do   : I have separated regexp and regexp_array, but
\&           maybe they can be rewritten as one \- just check what should be returned
.Ve
.SS "_compress_array"
.IX Subsection "_compress_array"
.Vb 8
\& Title   : _compress_array
\& Usage   :
\& Function: Will compress an array of real signed numbers to a string (ie vector
\&           of bytes) \-127 to +127 for bi\-directional(signed) and 0..255 for
\&           unsigned
\& Returns : String
\& Args    : array reference, followed by an max value and direction (optional,
\&           default 1\-unsigned),1 unsigned, any other is signed.
.Ve
.SS "_uncompress_string"
.IX Subsection "_uncompress_string"
.Vb 7
\& Title   : _uncompress_string
\& Usage   :
\& Function: Will uncompress a string (vector of bytes) to create an array of
\&           real signed numbers (opposite to_compress_array)
\& Returns : string, followed by an max value and
\&                   direction (optional, default 1\-unsigned), 1 unsigned, any other is signed.
\& Args    : array
.Ve
.SS "get_compressed_freq"
.IX Subsection "get_compressed_freq"
.Vb 9
\& Title   : get_compressed_freq
\& Usage   :
\& Function: A method to provide a compressed frequency vector. It uses one byte
\&           to code the frequence for one of the probability vectors for one
\&           position. Useful for relational database. Improvement of the previous
\&           0..a coding.
\& Example :  my $strA=$self\->get_compressed_freq(\*(AqA\*(Aq);
\& Returns :  String
\& Args    :  char
.Ve
.SS "get_compressed_logs"
.IX Subsection "get_compressed_logs"
.Vb 7
\& Title   : get_compressed_logs
\& Usage   :
\& Function: A method to provide a compressed log\-odd vector. It uses one byte to
\&                   code the log value for one of the log\-odds vectors for one position.
\& Example : my $strA=$self\->get_compressed_logs(\*(AqA\*(Aq);
\& Returns : String
\& Args    : char
.Ve
.SS "sequence_match_weight"
.IX Subsection "sequence_match_weight"
.Vb 9
\& Title   : sequence_match_weight
\& Usage   :
\& Function: This method will calculate the score of a match, based on the PWM
\&           if such is associated with the matrix object. Returns undef if no
\&           PWM data is available.
\& Throws  : if the length of the sequence is different from the matrix width
\& Example : my $score=$matrix\->sequence_match_weight(\*(AqACGGATAG\*(Aq);
\& Returns : Floating point
\& Args    : string
.Ve
.SS "get_all_vectors"
.IX Subsection "get_all_vectors"
.Vb 8
\& Title   : get_all_vectors
\& Usage   :
\& Function: returns all possible sequence vectors to satisfy the PFM under
\&           a given threshold
\& Throws  : If threshold outside of 0..1 (no sense to do that)
\& Example : my @vectors=$self\->get_all_vectors(4);
\& Returns : Array of strings
\& Args    : (optional) floating
.Ve
