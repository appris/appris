.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Bio::Matrix::PSM::ProtMatrix 3pm"
.TH Bio::Matrix::PSM::ProtMatrix 3pm "2021-02-03" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::Matrix::PSM::ProtMatrix \- SiteMatrixI implementation, holds a
position scoring matrix (or position weight matrix) with log\-odds scoring
information.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&   use Bio::Matrix::PSM::ProtMatrix;
\&   # Create from memory by supplying probability matrix hash both as strings or
\&   # arrays where the frequencies   Hash entries of the form lN refer to an array
\&   # of position\-specific log\-odds scores for amino acid N. Hash entries of the
\&   # form pN represent the position\-specific probability of finding amino acid N.
\&
\&   my %param = (
\&             \*(Aqid\*(Aq => \*(AqA. thaliana protein atp1\*(Aq,
\&             \*(Aq\-e_val\*(Aq => $score,
\&             \*(AqlS\*(Aq => [ \*(Aq\-2\*(Aq, \*(Aq3\*(Aq, \*(Aq\-3\*(Aq, \*(Aq2\*(Aq, \*(Aq\-3\*(Aq, \*(Aq1\*(Aq, \*(Aq1\*(Aq, \*(Aq3\*(Aq ],
\&             \*(AqlF\*(Aq => [ \*(Aq\-1\*(Aq, \*(Aq\-4\*(Aq, \*(Aq0\*(Aq, \*(Aq\-5\*(Aq, \*(Aq0\*(Aq, \*(Aq\-5\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-4\*(Aq ],
\&             \*(AqlT\*(Aq => [ \*(Aq\-1\*(Aq, \*(Aq1\*(Aq, \*(Aq0\*(Aq, \*(Aq1\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-1\*(Aq, \*(Aq0\*(Aq, \*(Aq1\*(Aq ],
\&             \*(AqlN\*(Aq => [ \*(Aq\-3\*(Aq, \*(Aq\-1\*(Aq, \*(Aq\-2\*(Aq, \*(Aq3\*(Aq, \*(Aq\-5\*(Aq, \*(Aq5\*(Aq, \*(Aq\-2\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqlK\*(Aq => [ \*(Aq\-2\*(Aq, \*(Aq0\*(Aq, \*(Aq\-3\*(Aq, \*(Aq2\*(Aq, \*(Aq\-3\*(Aq, \*(Aq2\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-1\*(Aq ],
\&             \*(AqlY\*(Aq => [ \*(Aq\-2\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-4\*(Aq ],
\&             \*(AqlE\*(Aq => [ \*(Aq\-3\*(Aq, \*(Aq4\*(Aq, \*(Aq\-3\*(Aq, \*(Aq2\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-3\*(Aq, \*(Aq2\*(Aq ],
\&             \*(AqlV\*(Aq => [ \*(Aq0\*(Aq, \*(Aq\-2\*(Aq, \*(Aq1\*(Aq, \*(Aq\-4\*(Aq, \*(Aq1\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-1\*(Aq, \*(Aq\-3\*(Aq ],
\&             \*(AqlQ\*(Aq => [ \*(Aq\-1\*(Aq, \*(Aq0\*(Aq, \*(Aq\-2\*(Aq, \*(Aq3\*(Aq, \*(Aq\-4\*(Aq, \*(Aq1\*(Aq, \*(Aq\-3\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqlM\*(Aq => [ \*(Aq8\*(Aq, \*(Aq\-3\*(Aq, \*(Aq8\*(Aq, \*(Aq\-3\*(Aq, \*(Aq1\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-3\*(Aq ],
\&             \*(AqlC\*(Aq => [ \*(Aq\-2\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-3\*(Aq ],
\&             \*(AqlL\*(Aq => [ \*(Aq1\*(Aq, \*(Aq\-3\*(Aq, \*(Aq1\*(Aq, \*(Aq\-4\*(Aq, \*(Aq3\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-4\*(Aq ],
\&             \*(AqlA\*(Aq => [ \*(Aq\-2\*(Aq, \*(Aq1\*(Aq, \*(Aq\-2\*(Aq, \*(Aq0\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-2\*(Aq, \*(Aq2\*(Aq, \*(Aq2\*(Aq ],
\&             \*(AqlW\*(Aq => [ \*(Aq\-2\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-5\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-5\*(Aq, \*(Aq\-5\*(Aq, \*(Aq\-5\*(Aq ],
\&             \*(AqlP\*(Aq => [ \*(Aq\-3\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-1\*(Aq, \*(Aq\-3\*(Aq, \*(Aq6\*(Aq, \*(Aq\-3\*(Aq ],
\&             \*(AqlH\*(Aq => [ \*(Aq\-2\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-5\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-3\*(Aq ],
\&             \*(AqlD\*(Aq => [ \*(Aq\-4\*(Aq, \*(Aq\-1\*(Aq, \*(Aq\-3\*(Aq, \*(Aq1\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-1\*(Aq, \*(Aq\-3\*(Aq, \*(Aq4\*(Aq ],
\&             \*(AqlR\*(Aq => [ \*(Aq\-2\*(Aq, \*(Aq\-1\*(Aq, \*(Aq\-3\*(Aq, \*(Aq0\*(Aq, \*(Aq\-4\*(Aq, \*(Aq4\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-3\*(Aq ],
\&             \*(AqlI\*(Aq => [ \*(Aq0\*(Aq, \*(Aq\-3\*(Aq, \*(Aq0\*(Aq, \*(Aq\-4\*(Aq, \*(Aq6\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-2\*(Aq ],
\&             \*(AqlG\*(Aq => [ \*(Aq\-4\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-4\*(Aq, \*(Aq\-2\*(Aq, \*(Aq\-5\*(Aq, \*(Aq\-3\*(Aq, \*(Aq\-1\*(Aq, \*(Aq\-2\*(Aq ],
\&             \*(AqpS\*(Aq => [ \*(Aq0\*(Aq, \*(Aq33\*(Aq, \*(Aq0\*(Aq, \*(Aq16\*(Aq, \*(Aq1\*(Aq, \*(Aq12\*(Aq, \*(Aq11\*(Aq, \*(Aq25\*(Aq ],
\&             \*(AqpF\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq2\*(Aq, \*(Aq0\*(Aq, \*(Aq3\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqpT\*(Aq => [ \*(Aq0\*(Aq, \*(Aq8\*(Aq, \*(Aq7\*(Aq, \*(Aq10\*(Aq, \*(Aq1\*(Aq, \*(Aq2\*(Aq, \*(Aq7\*(Aq, \*(Aq8\*(Aq ],
\&             \*(AqpN\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq2\*(Aq, \*(Aq13\*(Aq, \*(Aq0\*(Aq, \*(Aq36\*(Aq, \*(Aq1\*(Aq, \*(Aq4\*(Aq ],
\&             \*(AqpK\*(Aq => [ \*(Aq0\*(Aq, \*(Aq5\*(Aq, \*(Aq0\*(Aq, \*(Aq13\*(Aq, \*(Aq1\*(Aq, \*(Aq15\*(Aq, \*(Aq0\*(Aq, \*(Aq2\*(Aq ],
\&             \*(AqpY\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqpE\*(Aq => [ \*(Aq0\*(Aq, \*(Aq41\*(Aq, \*(Aq1\*(Aq, \*(Aq12\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq15\*(Aq ],
\&             \*(AqpV\*(Aq => [ \*(Aq0\*(Aq, \*(Aq3\*(Aq, \*(Aq9\*(Aq, \*(Aq0\*(Aq, \*(Aq2\*(Aq, \*(Aq0\*(Aq, \*(Aq3\*(Aq, \*(Aq1\*(Aq ],
\&             \*(AqpQ\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq15\*(Aq, \*(Aq0\*(Aq, \*(Aq4\*(Aq, \*(Aq0\*(Aq, \*(Aq3\*(Aq ],
\&             \*(AqpM\*(Aq => [ \*(Aq100\*(Aq, \*(Aq0\*(Aq, \*(Aq66\*(Aq, \*(Aq0\*(Aq, \*(Aq2\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqpC\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqpL\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq8\*(Aq, \*(Aq0\*(Aq, \*(Aq25\*(Aq, \*(Aq0\*(Aq, \*(Aq4\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqpA\*(Aq => [ \*(Aq0\*(Aq, \*(Aq10\*(Aq, \*(Aq1\*(Aq, \*(Aq9\*(Aq, \*(Aq2\*(Aq, \*(Aq0\*(Aq, \*(Aq22\*(Aq, \*(Aq16\*(Aq ],
\&             \*(AqpW\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqpP\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq3\*(Aq, \*(Aq1\*(Aq, \*(Aq45\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqpH\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq1\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqpD\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq1\*(Aq, \*(Aq7\*(Aq, \*(Aq2\*(Aq, \*(Aq2\*(Aq, \*(Aq0\*(Aq, \*(Aq22\*(Aq ],
\&             \*(AqpR\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq3\*(Aq, \*(Aq0\*(Aq, \*(Aq27\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq ],
\&             \*(AqpI\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq3\*(Aq, \*(Aq0\*(Aq, \*(Aq59\*(Aq, \*(Aq1\*(Aq, \*(Aq2\*(Aq, \*(Aq3\*(Aq ],
\&             \*(AqpG\*(Aq => [ \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq1\*(Aq, \*(Aq0\*(Aq, \*(Aq0\*(Aq, \*(Aq4\*(Aq, \*(Aq1\*(Aq ],
\&   );
\&
\&   my $matrix = Bio::Matrix::PSM::ProtMatrix( %param );
\&
\&
\&   my $site = Bio::Matrix::PSM::ProtMatrix\->new(%param);
\&   # Or get it from a file:
\&   use Bio::Matrix::PSM::IO;
\&   my $psmIO = Bio::Matrix::PSM::IO\->new(\-file => $file, \-format => \*(Aqpsi\-blast\*(Aq);
\&   while (my $psm = $psmIO\->next_psm) {
\&      #Now we have a Bio::Matrix::PSM::Psm object, 
\&      # see Bio::Matrix::PSM::PsmI for details
\&      #This is a Bio::Matrix::PSM::ProtMatrix object now
\&      my $matrix = $psm\->matrix;   
\&   }
\&
\&   # Get a simple consensus, where alphabet is:
\&   # {A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V,}
\&   # choosing the highest probability or N if prob is too low
\&   my $consensus = $site\->consensus;
\&
\&   # Retrieving and using regular expressions:
\&   my $regexp = $site\->regexp;
\&   my $count = grep($regexp,$seq);
\&   my $count = ($seq=~ s/$regexp/$1/eg);
\&   print "Motif $mid is present $count times in this sequence\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
ProtMatrix is designed to provide some basic methods when working with
position scoring (weight) matrices related to protein sequences.  A
protein \s-1PSM\s0 consists of 20 vectors with 20 frequencies (one per amino
acid per position).  This is the minimum information you should
provide to construct a \s-1PSM\s0 object.  The vectors can be provided as
strings with frequencies where the frequency is {0..a} and a=1. This
is the way \s-1MEME\s0 compressed representation of a matrix and it is quite
useful when working with relational \s-1DB.\s0  If arrays are provided as an
input (references to arrays actually) they can be any number, real or
integer (frequency or count).
.PP
When creating the object the constructor will check for positions that
equal 0.  If such is found it will increase the count for all
positions by one and recalculate the frequency.  Potential bug \- if
you are using frequencies and one of the positions is 0 it will change
significantly.  However, you should never have frequency that equals
0.
.PP
Throws an exception if: You mix as an input array and string (for
example A matrix is given as array, C \- as string).  The position
vector is (0,0,0,0).  One of the probability vectors is shorter than
the rest.
.PP
Summary of the methods I use most frequently (details below):
.PP
.Vb 10
\&   iupac \- return IUPAC compliant consensus as a string
\&   score \- Returns the score as a real number
\&   IC \- information content. Returns a real number
\&   id \- identifier. Returns a string
\&   accession \- accession number. Returns a string
\&   next_pos \- return the sequence probably for each letter, IUPAC
\&         symbol, IUPAC probability and simple sequence
\&   consenus letter for this position. Rewind at the end. Returns a hash.
\&   pos \- current position get/set. Returns an integer.
\&   regexp \- construct a regular expression based on IUPAC consensus.
\&         For example AGWV will be [Aa][Gg][AaTt][AaCcGg]
\&   width \- site width
\&   get_string \- gets the probability vector for a single base as a string.
\&   get_array \- gets the probability vector for a single base as an array.
\&   get_logs_array \- gets the log\-odds vector for a single base as an array.
.Ve
.PP
New methods, which might be of interest to anyone who wants to store
\&\s-1PSM\s0 in a relational database without creating an entry for each
position is the ability to compress the \s-1PSM\s0 vector into a string with
losing usually less than 1% of the data.  this can be done with:
.PP
.Vb 2
\&   my $str=$matrix\->get_compressed_freq(\*(AqA\*(Aq);
\&or
\&
\&   my $str=$matrix\->get_compressed_logs(\*(AqA\*(Aq);
.Ve
.PP
Loading from a database should be done with new, but is not yet implemented.
However you can still uncompress such string with:
.PP
.Vb 1
\&   my @arr=Bio::Matrix::PSM::_uncompress_string ($str,1,1); for PSM
.Ve
.PP
or
.PP
.Vb 1
\&   my @arr=Bio::Matrix::PSM::_uncompress_string ($str,1000,2); for log odds
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.SS "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.   Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl\-l@bioperl.org                  \- General discussion
\&  http://bioperl.org/wiki/Mailing_lists  \- About the mailing lists
.Ve
.SS "Support"
.IX Subsection "Support"
Please direct usage questions or support issues to the mailing list:
.PP
\&\fIbioperl\-l@bioperl.org\fR
.PP
rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.
.SS "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  https://github.com/bioperl/bioperl\-live/issues
.Ve
.SH "AUTHOR \- James Thompson"
.IX Header "AUTHOR - James Thompson"
Email tex@biosysadmin.com
.SH "APPENDIX"
.IX Header "APPENDIX"
.SS "new"
.IX Subsection "new"
.Vb 10
\& Title    : new
\& Usage    : my $site = Bio::Matrix::PSM::ProtMatrix\->new( 
\&               %probs,
\&               %logs,
\&               \-IC    => $ic,
\&               \-e_val => $score, 
\&               \-id    => $mid
\&               \-model => \e%model
\&            );
\& Function : Creates a new Bio::Matrix::PSM::ProtMatrix object from memory
\& Throws   : If inconsistent data for all vectors (all 20 amino acids) is
\&               provided, if you mix input types (string vs array) or if a
\&               position freq is 0.
\& Example  :
\& Returns  : Bio::Matrix::PSM::ProtMatrix object
\& Args     : Hash references to log\-odds scores and probabilities for
\&            position\-specific scoring info, e\-value (optional), information
\&            content (optional), id (optional), model for background distribution
\&            of proteins (optional).
.Ve
.SS "alphabet"
.IX Subsection "alphabet"
.Vb 8
\& Title    : Returns an array (or array reference if desired) to the alphabet 
\& Usage    :
\& Function : Returns an array (or array reference) containing all of the
\&            allowable characters for this matrix.
\& Throws   :
\& Example  :
\& Returns  : Array or arrary reference.
\& Args     :
.Ve
.SS "_calculate_consensus"
.IX Subsection "_calculate_consensus"
.Vb 7
\& Title    : _calculate_consensus
\& Usage    :
\& Function : Calculates the consensus sequence for this matrix. 
\& Throws   :
\& Example  :
\& Returns  :
\& Args     :
.Ve
.SS "next_pos"
.IX Subsection "next_pos"
.Vb 10
\& Title    : next_pos
\& Usage    :
\& Function : Retrieves the next position features: frequencies for all 20 amino
\&            acids, log\-odds scores for all 20 amino acids at this position,
\&            the main (consensus) letter at this position, the probability
\&            for the consensus letter to occur at this position and the relative
\&            current position as an integer.
\& Throws   :
\& Example  :
\& Returns  : hash (or hash reference) (pA,pR,pN,pD,...,logA,logR,logN,logD,aa,prob,rel)
\&            \- pN entries represent the probability for amino acid N
\&            to be at this position
\&            \- logN entries represent the log\-odds score for having amino acid
\&            N at this position
\&            \- aa is the consensus amino acid
\&            \- prob is the probability for the consensus amino acid to be at this 
\&            position
\&            \- rel is the relative index of the current position (integer)
\& Args      : none
.Ve
.SS "curpos"
.IX Subsection "curpos"
.Vb 7
\& Title    : curpos
\& Usage    :
\& Function : Gets/sets the current position. 
\& Throws   :
\& Example  :
\& Returns  : Current position (integer).
\& Args     : New position (integer).
.Ve
.SS "e_val"
.IX Subsection "e_val"
.Vb 7
\& Title    : e_val
\& Usage    :
\& Function : Gets/sets the e\-value
\& Throws   :
\& Example  :
\& Returns  : 
\& Args     : real number
.Ve
.SS "\s-1IC\s0"
.IX Subsection "IC"
.Vb 7
\& Title    : IC
\& Usage    :
\& Function : Position\-specific information content.
\& Throws   :
\& Example  :
\& Returns  : Information content for current position.
\& Args     : Information content for current position.
.Ve
.SS "accession_number"
.IX Subsection "accession_number"
.Vb 8
\& Title    : accession_number
\& Usage    :
\& Function: accession number, this will be unique id for the ProtMatrix object as
\&            well for any other object, inheriting from ProtMatrix.
\& Throws   :
\& Example  :
\& Returns  : New accession number (string)
\& Args     : Accession number (string)
.Ve
.SS "consensus"
.IX Subsection "consensus"
.Vb 7
\& Title    : consensus
\& Usage    :
\& Function : Returns the consensus sequence for this PSM.
\& Throws   : if supplied with thresold outisde 5..10 range
\& Example  :
\& Returns  : string
\& Args     : (optional) threshold value 5 to 10 (corresponds to 50\-100% at each position
.Ve
.SS "get_string"
.IX Subsection "get_string"
.Vb 8
\& Title   : get_string
\& Usage   :
\& Function: Returns given probability vector as a string. Useful if you want to
\&            store things in a rel database, where arrays are not first choice
\& Throws  : If the argument is outside {A,C,G,T}
\& Example :
\& Returns : string
\& Args    : character {A,C,G,T}
.Ve
.SS "width"
.IX Subsection "width"
.Vb 7
\& Title    : width
\& Usage    :
\& Function : Returns the length of the site
\& Throws   :
\& Example  :
\& Returns  : number
\& Args     :
.Ve
.SS "get_array"
.IX Subsection "get_array"
.Vb 7
\& Title    : get_array
\& Usage    :
\& Function : Returns an array with frequencies for a specified amino acid.
\& Throws   :
\& Example  :
\& Returns  : Array representing frequencies for specified amino acid.
\& Args     : Single amino acid (character).
.Ve
.SS "get_logs_array"
.IX Subsection "get_logs_array"
.Vb 7
\& Title    : get_logs_array
\& Usage    :
\& Function : Returns an array with log_odds for a specified base
\& Throws   :
\& Example  :
\& Returns  : Array representing log\-odds scores for specified amino acid.
\& Args     : Single amino acid (character).
.Ve
.SS "id"
.IX Subsection "id"
.Vb 7
\& Title    : id
\& Usage    :
\& Function : Gets/sets the site id
\& Throws   :
\& Example  :
\& Returns  : string
\& Args     : string
.Ve
.SS "regexp"
.IX Subsection "regexp"
.Vb 9
\& Title    : regexp
\& Usage    :
\& Function : Returns a case\-insensitive regular expression which matches the
\&            IUPAC convention.  X\*(Aqs in consensus sequence will match anything.     
\& Throws   :
\& Example  :
\& Returns  : string
\& Args     : Threshold for calculating consensus sequence (number in range 0\-100
\&            representing a percentage). Threshold defaults to 20.
.Ve
.SS "regexp_array"
.IX Subsection "regexp_array"
.Vb 10
\& Title    : regexp_array
\& Usage    :
\& Function : Returns an array of position\-specific regular expressions.
\&             X\*(Aqs in consensus sequence will match anything.      
\& Throws   :
\& Example  :
\& Returns  : Array of position\-specific regular expressions.
\& Args     : Threshold for calculating consensus sequence (number in range 0\-100
\&            representing a percentage). Threshold defaults to 20.
\& Notes    : Simply calls regexp method in list context.
.Ve
.SS "_compress_array"
.IX Subsection "_compress_array"
.Vb 9
\& Title    : _compress_array
\& Usage    :
\& Function :  Will compress an array of real signed numbers to a string (ie vector of bytes)
\&             \-127 to +127 for bi\-directional(signed) and 0..255 for unsigned ;
\& Throws   :
\& Example  :  Internal stuff
\& Returns  :  String
\& Args     :  array reference, followed by max value and direction (optional, defaults to 1),
\&             direction of 1 is unsigned, anything else is signed.
.Ve
.SS "_uncompress_string"
.IX Subsection "_uncompress_string"
.Vb 9
\& Title    : _uncompress_string
\& Usage    :
\& Function :   Will uncompress a string (vector of bytes) to create an array of real
\&                  signed numbers (opposite to_compress_array)
\& Throws   :
\& Example  :   Internal stuff
\& Returns  :   string, followed by max value and direction (optional, defaults to 1),
\&              direction of 1 is unsigned, anything else is signed.
\& Args     :   array
.Ve
.SS "get_compressed_freq"
.IX Subsection "get_compressed_freq"
.Vb 9
\& Title    : get_compressed_freq
\& Usage    :
\& Function:   A method to provide a compressed frequency vector. It uses one byte to
\&             code the frequence for one of the probability vectors for one position.
\&             Useful for relational database. Improvement of the previous 0..a coding.
\& Throws   :
\& Example  :   my $strA=$self\->get_compressed_freq(\*(AqA\*(Aq);
\& Returns  :   String
\& Args     :   char
.Ve
.SS "sequence_match_weight"
.IX Subsection "sequence_match_weight"
.Vb 9
\& Title    : sequence_match_weight
\& Usage    :
\& Function :   This method will calculate the score of a match, based on the PSM
\&              if such is associated with the matrix object. Returns undef if no
\&              PSM data is available.
\& Throws   :   if the length of the sequence is different from the matrix width
\& Example  :   my $score=$matrix\->sequence_match_weight(\*(AqACGGATAG\*(Aq);
\& Returns  :   Floating point
\& Args     :   string
.Ve
.SS "_to_IUPAC"
.IX Subsection "_to_IUPAC"
.Vb 9
\& Title   : _to_IUPAC
\& Usage   :
\& Function: Converts a single position to IUPAC compliant symbol and returns its probability.
\&            Currently returns the most likely amino acid/probability combination.
\& Throws  :
\& Example :
\& Returns : char, real number representing an amino acid and a probability.
\& Args    : real numbers for all 20 amino acids (ordered by alphabet contained
\&            in $self\->{_alphabet}, minimum probability threshold.
.Ve
.SS "_to_cons"
.IX Subsection "_to_cons"
.Vb 8
\& Title   : _to_cons
\& Usage   :
\& Function: Converts a single position to simple consensus character and returns
\&            its probability. Currently just calls the _to_IUPAC subroutine. 
\& Throws  :
\& Example :
\& Returns : char, real number
\& Args    : real numbers for A,C,G,T (positional)
.Ve
.SS "get_all_vectors"
.IX Subsection "get_all_vectors"
.Vb 8
\& Title    : get_all_vectors
\& Usage    :
\& Function :  returns all possible sequence vectors to satisfy the PFM under
\&             a given threshold
\& Throws   :  If threshold outside of 0..1 (no sense to do that)
\& Example  :  my @vectors = $self\->get_all_vectors(4);
\& Returns  :  Array of strings
\& Args     :  (optional) floating
.Ve
